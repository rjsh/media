<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>avdevice.h source code [ffmpeg/libavdevice/avdevice.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="AVAppToDevMessageType,AVDevToAppMessageType,AVDeviceCapabilitiesQuery,AVDeviceInfo,AVDeviceInfoList,AVDeviceRect "/>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'ffmpeg/libavdevice/avdevice.h'; var root_path = '../..'; var data_path = '../../../data';</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>ffmpeg</a>/<a href='./'>libavdevice</a>/<a href='avdevice.h.html'>avdevice.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * This file is part of FFmpeg.</i></td></tr>
<tr><th id="3">3</th><td><i> *</i></td></tr>
<tr><th id="4">4</th><td><i> * FFmpeg is free software; you can redistribute it and/or</i></td></tr>
<tr><th id="5">5</th><td><i> * modify it under the terms of the GNU Lesser General Public</i></td></tr>
<tr><th id="6">6</th><td><i> * License as published by the Free Software Foundation; either</i></td></tr>
<tr><th id="7">7</th><td><i> * version 2.1 of the License, or (at your option) any later version.</i></td></tr>
<tr><th id="8">8</th><td><i> *</i></td></tr>
<tr><th id="9">9</th><td><i> * FFmpeg is distributed in the hope that it will be useful,</i></td></tr>
<tr><th id="10">10</th><td><i> * but WITHOUT ANY WARRANTY; without even the implied warranty of</i></td></tr>
<tr><th id="11">11</th><td><i> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</i></td></tr>
<tr><th id="12">12</th><td><i> * Lesser General Public License for more details.</i></td></tr>
<tr><th id="13">13</th><td><i> *</i></td></tr>
<tr><th id="14">14</th><td><i> * You should have received a copy of the GNU Lesser General Public</i></td></tr>
<tr><th id="15">15</th><td><i> * License along with FFmpeg; if not, write to the Free Software</i></td></tr>
<tr><th id="16">16</th><td><i> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</i></td></tr>
<tr><th id="17">17</th><td><i> */</i></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><u>#<span data-ppcond="19">ifndef</span> <span class="macro" data-ref="_M/AVDEVICE_AVDEVICE_H">AVDEVICE_AVDEVICE_H</span></u></td></tr>
<tr><th id="20">20</th><td><u>#define <dfn class="macro" id="_M/AVDEVICE_AVDEVICE_H" data-ref="_M/AVDEVICE_AVDEVICE_H">AVDEVICE_AVDEVICE_H</dfn></u></td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td><u>#include <a href="version.h.html">"version.h"</a></u></td></tr>
<tr><th id="23">23</th><td></td></tr>
<tr><th id="24">24</th><td><i class="doc">/**</i></td></tr>
<tr><th id="25">25</th><td><i class="doc"> *<span class="command"> @file</span></i></td></tr>
<tr><th id="26">26</th><td><i class="doc"> * <span class="command">@ingroup</span> <span class="verb">lavd</span></i></td></tr>
<tr><th id="27">27</th><td><i class="doc"> * Main libavdevice API header</i></td></tr>
<tr><th id="28">28</th><td><i class="doc"> */</i></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><i class="doc">/**</i></td></tr>
<tr><th id="31">31</th><td><i class="doc"> * <span class="command">@defgroup</span> <span class="verb">lavd libavdevice</span></i></td></tr>
<tr><th id="32">32</th><td><i class="doc"> * Special devices muxing/demuxing library.</i></td></tr>
<tr><th id="33">33</th><td><i class="doc"> *</i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> * Libavdevice is a complementary library to <span class="command">@ref</span> <span class="verb">libavf "libavformat". It</span></i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * provides various "special" platform-specific muxers and demuxers, e.g. for</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> * grabbing devices, audio capture and playback etc. As a consequence, the</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> * (de)muxers in libavdevice are of the AVFMT_NOFILE type (they use their own</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * I/O functions). The filename passed to avformat_open_input() often does not</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> * refer to an actually existing file, but has some special device-specific</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> * meaning - e.g. for x11grab it is the display name.</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> *</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> * To use libavdevice, simply call avdevice_register_all() to register all</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> * compiled muxers and demuxers. They all use standard libavformat API.</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> *</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> * @{</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> */</i></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><u>#include <a href="../libavutil/log.h.html">"libavutil/log.h"</a></u></td></tr>
<tr><th id="49">49</th><td><u>#include <a href="../libavutil/opt.h.html">"libavutil/opt.h"</a></u></td></tr>
<tr><th id="50">50</th><td><u>#include <a href="../libavutil/dict.h.html">"libavutil/dict.h"</a></u></td></tr>
<tr><th id="51">51</th><td><u>#include <a href="../libavformat/avformat.h.html">"libavformat/avformat.h"</a></u></td></tr>
<tr><th id="52">52</th><td></td></tr>
<tr><th id="53">53</th><td><i class="doc">/**</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> * Return the LIBAVDEVICE_VERSION_INT constant.</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> */</i></td></tr>
<tr><th id="56">56</th><td><em>unsigned</em> <dfn class="decl" id="avdevice_version" title='avdevice_version' data-ref="avdevice_version">avdevice_version</dfn>(<em>void</em>);</td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td><i class="doc">/**</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> * Return the libavdevice build-time configuration.</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> */</i></td></tr>
<tr><th id="61">61</th><td><em>const</em> <em>char</em> *<dfn class="decl" id="avdevice_configuration" title='avdevice_configuration' data-ref="avdevice_configuration">avdevice_configuration</dfn>(<em>void</em>);</td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i class="doc">/**</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> * Return the libavdevice license.</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> */</i></td></tr>
<tr><th id="66">66</th><td><em>const</em> <em>char</em> *<dfn class="decl" id="avdevice_license" title='avdevice_license' data-ref="avdevice_license">avdevice_license</dfn>(<em>void</em>);</td></tr>
<tr><th id="67">67</th><td></td></tr>
<tr><th id="68">68</th><td><i class="doc">/**</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> * Initialize libavdevice and register all the input and output devices.</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> * <span class="command">@warning</span> This function is not thread safe.</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> */</i></td></tr>
<tr><th id="72">72</th><td><em>void</em> <a class="decl" href="alldevices.c.html#avdevice_register_all" title='avdevice_register_all' data-ref="avdevice_register_all" id="avdevice_register_all">avdevice_register_all</a>(<em>void</em>);</td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><i class="doc">/**</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> * Audio input devices iterator.</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> *</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> * If d is NULL, returns the first registered input audio/video device,</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> * if d is non-NULL, returns the next registered input audio/video device after d</i></td></tr>
<tr><th id="79">79</th><td><i class="doc"> * or NULL if d is the last one.</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> */</i></td></tr>
<tr><th id="81">81</th><td><a class="typedef" href="../libavformat/avformat.h.html#AVInputFormat" title='AVInputFormat' data-type='struct AVInputFormat' data-ref="AVInputFormat">AVInputFormat</a> *<dfn class="decl" id="av_input_audio_device_next" title='av_input_audio_device_next' data-ref="av_input_audio_device_next">av_input_audio_device_next</dfn>(<a class="typedef" href="../libavformat/avformat.h.html#AVInputFormat" title='AVInputFormat' data-type='struct AVInputFormat' data-ref="AVInputFormat">AVInputFormat</a>  *<dfn class="local col1 decl" id="2341d" title='d' data-type='AVInputFormat *' data-ref="2341d">d</dfn>);</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td><i class="doc">/**</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * Video input devices iterator.</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> *</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> * If d is NULL, returns the first registered input audio/video device,</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * if d is non-NULL, returns the next registered input audio/video device after d</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> * or NULL if d is the last one.</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> */</i></td></tr>
<tr><th id="90">90</th><td><a class="typedef" href="../libavformat/avformat.h.html#AVInputFormat" title='AVInputFormat' data-type='struct AVInputFormat' data-ref="AVInputFormat">AVInputFormat</a> *<dfn class="decl" id="av_input_video_device_next" title='av_input_video_device_next' data-ref="av_input_video_device_next">av_input_video_device_next</dfn>(<a class="typedef" href="../libavformat/avformat.h.html#AVInputFormat" title='AVInputFormat' data-type='struct AVInputFormat' data-ref="AVInputFormat">AVInputFormat</a>  *<dfn class="local col2 decl" id="2342d" title='d' data-type='AVInputFormat *' data-ref="2342d">d</dfn>);</td></tr>
<tr><th id="91">91</th><td></td></tr>
<tr><th id="92">92</th><td><i class="doc">/**</i></td></tr>
<tr><th id="93">93</th><td><i class="doc"> * Audio output devices iterator.</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> *</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> * If d is NULL, returns the first registered output audio/video device,</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * if d is non-NULL, returns the next registered output audio/video device after d</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> * or NULL if d is the last one.</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> */</i></td></tr>
<tr><th id="99">99</th><td><a class="typedef" href="../libavformat/avformat.h.html#AVOutputFormat" title='AVOutputFormat' data-type='struct AVOutputFormat' data-ref="AVOutputFormat">AVOutputFormat</a> *<dfn class="decl" id="av_output_audio_device_next" title='av_output_audio_device_next' data-ref="av_output_audio_device_next">av_output_audio_device_next</dfn>(<a class="typedef" href="../libavformat/avformat.h.html#AVOutputFormat" title='AVOutputFormat' data-type='struct AVOutputFormat' data-ref="AVOutputFormat">AVOutputFormat</a> *<dfn class="local col3 decl" id="2343d" title='d' data-type='AVOutputFormat *' data-ref="2343d">d</dfn>);</td></tr>
<tr><th id="100">100</th><td></td></tr>
<tr><th id="101">101</th><td><i class="doc">/**</i></td></tr>
<tr><th id="102">102</th><td><i class="doc"> * Video output devices iterator.</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> *</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> * If d is NULL, returns the first registered output audio/video device,</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> * if d is non-NULL, returns the next registered output audio/video device after d</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> * or NULL if d is the last one.</i></td></tr>
<tr><th id="107">107</th><td><i class="doc"> */</i></td></tr>
<tr><th id="108">108</th><td><a class="typedef" href="../libavformat/avformat.h.html#AVOutputFormat" title='AVOutputFormat' data-type='struct AVOutputFormat' data-ref="AVOutputFormat">AVOutputFormat</a> *<dfn class="decl" id="av_output_video_device_next" title='av_output_video_device_next' data-ref="av_output_video_device_next">av_output_video_device_next</dfn>(<a class="typedef" href="../libavformat/avformat.h.html#AVOutputFormat" title='AVOutputFormat' data-type='struct AVOutputFormat' data-ref="AVOutputFormat">AVOutputFormat</a> *<dfn class="local col4 decl" id="2344d" title='d' data-type='AVOutputFormat *' data-ref="2344d">d</dfn>);</td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="AVDeviceRect" title='AVDeviceRect' data-ref="AVDeviceRect"><a class="type" href="#AVDeviceRect" title='AVDeviceRect' data-ref="AVDeviceRect">AVDeviceRect</a></dfn> {</td></tr>
<tr><th id="111">111</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceRect::x" title='AVDeviceRect::x' data-ref="AVDeviceRect::x">x</dfn>;      <i class="doc">/**&lt; x coordinate of top left corner */</i></td></tr>
<tr><th id="112">112</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceRect::y" title='AVDeviceRect::y' data-ref="AVDeviceRect::y">y</dfn>;      <i class="doc">/**&lt; y coordinate of top left corner */</i></td></tr>
<tr><th id="113">113</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceRect::width" title='AVDeviceRect::width' data-ref="AVDeviceRect::width">width</dfn>;  <i class="doc">/**&lt; width */</i></td></tr>
<tr><th id="114">114</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceRect::height" title='AVDeviceRect::height' data-ref="AVDeviceRect::height">height</dfn>; <i class="doc">/**&lt; height */</i></td></tr>
<tr><th id="115">115</th><td>} <dfn class="typedef" id="AVDeviceRect" title='AVDeviceRect' data-type='struct AVDeviceRect' data-ref="AVDeviceRect">AVDeviceRect</dfn>;</td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><i class="doc">/**</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> * Message types used by avdevice_app_to_dev_control_message().</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> */</i></td></tr>
<tr><th id="120">120</th><td><b>enum</b> <dfn class="type def" id="AVAppToDevMessageType" title='AVAppToDevMessageType' data-ref="AVAppToDevMessageType">AVAppToDevMessageType</dfn> {</td></tr>
<tr><th id="121">121</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="122">122</th><td><i class="doc">     * Dummy message.</i></td></tr>
<tr><th id="123">123</th><td><i class="doc">     */</i></td></tr>
<tr><th id="124">124</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_NONE" title='AVAppToDevMessageType::AV_APP_TO_DEV_NONE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_NONE">AV_APP_TO_DEV_NONE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;E&apos;) | ((&apos;N&apos;) &lt;&lt; 8) | ((&apos;O&apos;) &lt;&lt; 16) | ((unsigned)(&apos;N&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'N'</kbd>,<kbd>'O'</kbd>,<kbd>'N'</kbd>,<kbd>'E'</kbd>),</td></tr>
<tr><th id="125">125</th><td></td></tr>
<tr><th id="126">126</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="127">127</th><td><i class="doc">     * Window size change message.</i></td></tr>
<tr><th id="128">128</th><td><i class="doc">     *</i></td></tr>
<tr><th id="129">129</th><td><i class="doc">     * Message is sent to the device every time the application changes the size</i></td></tr>
<tr><th id="130">130</th><td><i class="doc">     * of the window device renders to.</i></td></tr>
<tr><th id="131">131</th><td><i class="doc">     * Message should also be sent right after window is created.</i></td></tr>
<tr><th id="132">132</th><td><i class="doc">     *</i></td></tr>
<tr><th id="133">133</th><td><i class="doc">     * data: AVDeviceRect: new window size.</i></td></tr>
<tr><th id="134">134</th><td><i class="doc">     */</i></td></tr>
<tr><th id="135">135</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_SIZE" title='AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_SIZE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_SIZE">AV_APP_TO_DEV_WINDOW_SIZE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;M&apos;) | ((&apos;O&apos;) &lt;&lt; 8) | ((&apos;E&apos;) &lt;&lt; 16) | ((unsigned)(&apos;G&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'G'</kbd>,<kbd>'E'</kbd>,<kbd>'O'</kbd>,<kbd>'M'</kbd>),</td></tr>
<tr><th id="136">136</th><td></td></tr>
<tr><th id="137">137</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="138">138</th><td><i class="doc">     * Repaint request message.</i></td></tr>
<tr><th id="139">139</th><td><i class="doc">     *</i></td></tr>
<tr><th id="140">140</th><td><i class="doc">     * Message is sent to the device when window has to be repainted.</i></td></tr>
<tr><th id="141">141</th><td><i class="doc">     *</i></td></tr>
<tr><th id="142">142</th><td><i class="doc">     * data: AVDeviceRect: area required to be repainted.</i></td></tr>
<tr><th id="143">143</th><td><i class="doc">     *       NULL: whole area is required to be repainted.</i></td></tr>
<tr><th id="144">144</th><td><i class="doc">     */</i></td></tr>
<tr><th id="145">145</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_REPAINT" title='AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_REPAINT' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_WINDOW_REPAINT">AV_APP_TO_DEV_WINDOW_REPAINT</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;A&apos;) | ((&apos;P&apos;) &lt;&lt; 8) | ((&apos;E&apos;) &lt;&lt; 16) | ((unsigned)(&apos;R&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'R'</kbd>,<kbd>'E'</kbd>,<kbd>'P'</kbd>,<kbd>'A'</kbd>),</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="148">148</th><td><i class="doc">     * Request pause/play.</i></td></tr>
<tr><th id="149">149</th><td><i class="doc">     *</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">     * Application requests pause/unpause playback.</i></td></tr>
<tr><th id="151">151</th><td><i class="doc">     * Mostly usable with devices that have internal buffer.</i></td></tr>
<tr><th id="152">152</th><td><i class="doc">     * By default devices are not paused.</i></td></tr>
<tr><th id="153">153</th><td><i class="doc">     *</i></td></tr>
<tr><th id="154">154</th><td><i class="doc">     * data: NULL</i></td></tr>
<tr><th id="155">155</th><td><i class="doc">     */</i></td></tr>
<tr><th id="156">156</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_PAUSE" title='AVAppToDevMessageType::AV_APP_TO_DEV_PAUSE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_PAUSE">AV_APP_TO_DEV_PAUSE</dfn>        = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos; &apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;A&apos;) &lt;&lt; 16) | ((unsigned)(&apos;P&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'P'</kbd>, <kbd>'A'</kbd>, <kbd>'U'</kbd>, <kbd>' '</kbd>),</td></tr>
<tr><th id="157">157</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_PLAY" title='AVAppToDevMessageType::AV_APP_TO_DEV_PLAY' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_PLAY">AV_APP_TO_DEV_PLAY</dfn>         = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;Y&apos;) | ((&apos;A&apos;) &lt;&lt; 8) | ((&apos;L&apos;) &lt;&lt; 16) | ((unsigned)(&apos;P&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'P'</kbd>, <kbd>'L'</kbd>, <kbd>'A'</kbd>, <kbd>'Y'</kbd>),</td></tr>
<tr><th id="158">158</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_PAUSE" title='AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_PAUSE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_PAUSE">AV_APP_TO_DEV_TOGGLE_PAUSE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;A&apos;) &lt;&lt; 16) | ((unsigned)(&apos;P&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'P'</kbd>, <kbd>'A'</kbd>, <kbd>'U'</kbd>, <kbd>'T'</kbd>),</td></tr>
<tr><th id="159">159</th><td></td></tr>
<tr><th id="160">160</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="161">161</th><td><i class="doc">     * Volume control message.</i></td></tr>
<tr><th id="162">162</th><td><i class="doc">     *</i></td></tr>
<tr><th id="163">163</th><td><i class="doc">     * Set volume level. It may be device-dependent if volume</i></td></tr>
<tr><th id="164">164</th><td><i class="doc">     * is changed per stream or system wide. Per stream volume</i></td></tr>
<tr><th id="165">165</th><td><i class="doc">     * change is expected when possible.</i></td></tr>
<tr><th id="166">166</th><td><i class="doc">     *</i></td></tr>
<tr><th id="167">167</th><td><i class="doc">     * data: double: new volume with range of 0.0 - 1.0.</i></td></tr>
<tr><th id="168">168</th><td><i class="doc">     */</i></td></tr>
<tr><th id="169">169</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_SET_VOLUME" title='AVAppToDevMessageType::AV_APP_TO_DEV_SET_VOLUME' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_SET_VOLUME">AV_APP_TO_DEV_SET_VOLUME</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;L&apos;) | ((&apos;O&apos;) &lt;&lt; 8) | ((&apos;V&apos;) &lt;&lt; 16) | ((unsigned)(&apos;S&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'S'</kbd>, <kbd>'V'</kbd>, <kbd>'O'</kbd>, <kbd>'L'</kbd>),</td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="172">172</th><td><i class="doc">     * Mute control messages.</i></td></tr>
<tr><th id="173">173</th><td><i class="doc">     *</i></td></tr>
<tr><th id="174">174</th><td><i class="doc">     * Change mute state. It may be device-dependent if mute status</i></td></tr>
<tr><th id="175">175</th><td><i class="doc">     * is changed per stream or system wide. Per stream mute status</i></td></tr>
<tr><th id="176">176</th><td><i class="doc">     * change is expected when possible.</i></td></tr>
<tr><th id="177">177</th><td><i class="doc">     *</i></td></tr>
<tr><th id="178">178</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="179">179</th><td><i class="doc">     */</i></td></tr>
<tr><th id="180">180</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_MUTE" title='AVAppToDevMessageType::AV_APP_TO_DEV_MUTE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_MUTE">AV_APP_TO_DEV_MUTE</dfn>        = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;M&apos;) &lt;&lt; 16) | ((unsigned)(&apos; &apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>' '</kbd>, <kbd>'M'</kbd>, <kbd>'U'</kbd>, <kbd>'T'</kbd>),</td></tr>
<tr><th id="181">181</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_UNMUTE" title='AVAppToDevMessageType::AV_APP_TO_DEV_UNMUTE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_UNMUTE">AV_APP_TO_DEV_UNMUTE</dfn>      = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;M&apos;) &lt;&lt; 16) | ((unsigned)(&apos;U&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'U'</kbd>, <kbd>'M'</kbd>, <kbd>'U'</kbd>, <kbd>'T'</kbd>),</td></tr>
<tr><th id="182">182</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_MUTE" title='AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_MUTE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_TOGGLE_MUTE">AV_APP_TO_DEV_TOGGLE_MUTE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;M&apos;) &lt;&lt; 16) | ((unsigned)(&apos;T&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'T'</kbd>, <kbd>'M'</kbd>, <kbd>'U'</kbd>, <kbd>'T'</kbd>),</td></tr>
<tr><th id="183">183</th><td></td></tr>
<tr><th id="184">184</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="185">185</th><td><i class="doc">     * Get volume/mute messages.</i></td></tr>
<tr><th id="186">186</th><td><i class="doc">     *</i></td></tr>
<tr><th id="187">187</th><td><i class="doc">     * Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or</i></td></tr>
<tr><th id="188">188</th><td><i class="doc">     * AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.</i></td></tr>
<tr><th id="189">189</th><td><i class="doc">     *</i></td></tr>
<tr><th id="190">190</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="191">191</th><td><i class="doc">     */</i></td></tr>
<tr><th id="192">192</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_GET_VOLUME" title='AVAppToDevMessageType::AV_APP_TO_DEV_GET_VOLUME' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_GET_VOLUME">AV_APP_TO_DEV_GET_VOLUME</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;L&apos;) | ((&apos;O&apos;) &lt;&lt; 8) | ((&apos;V&apos;) &lt;&lt; 16) | ((unsigned)(&apos;G&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'G'</kbd>, <kbd>'V'</kbd>, <kbd>'O'</kbd>, <kbd>'L'</kbd>),</td></tr>
<tr><th id="193">193</th><td>    <dfn class="enum" id="AVAppToDevMessageType::AV_APP_TO_DEV_GET_MUTE" title='AVAppToDevMessageType::AV_APP_TO_DEV_GET_MUTE' data-ref="AVAppToDevMessageType::AV_APP_TO_DEV_GET_MUTE">AV_APP_TO_DEV_GET_MUTE</dfn>   = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;M&apos;) &lt;&lt; 16) | ((unsigned)(&apos;G&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'G'</kbd>, <kbd>'M'</kbd>, <kbd>'U'</kbd>, <kbd>'T'</kbd>),</td></tr>
<tr><th id="194">194</th><td>};</td></tr>
<tr><th id="195">195</th><td></td></tr>
<tr><th id="196">196</th><td><i class="doc">/**</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> * Message types used by avdevice_dev_to_app_control_message().</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> */</i></td></tr>
<tr><th id="199">199</th><td><b>enum</b> <dfn class="type def" id="AVDevToAppMessageType" title='AVDevToAppMessageType' data-ref="AVDevToAppMessageType">AVDevToAppMessageType</dfn> {</td></tr>
<tr><th id="200">200</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="201">201</th><td><i class="doc">     * Dummy message.</i></td></tr>
<tr><th id="202">202</th><td><i class="doc">     */</i></td></tr>
<tr><th id="203">203</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_NONE" title='AVDevToAppMessageType::AV_DEV_TO_APP_NONE' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_NONE">AV_DEV_TO_APP_NONE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;E&apos;) | ((&apos;N&apos;) &lt;&lt; 8) | ((&apos;O&apos;) &lt;&lt; 16) | ((unsigned)(&apos;N&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'N'</kbd>,<kbd>'O'</kbd>,<kbd>'N'</kbd>,<kbd>'E'</kbd>),</td></tr>
<tr><th id="204">204</th><td></td></tr>
<tr><th id="205">205</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="206">206</th><td><i class="doc">     * Create window buffer message.</i></td></tr>
<tr><th id="207">207</th><td><i class="doc">     *</i></td></tr>
<tr><th id="208">208</th><td><i class="doc">     * Device requests to create a window buffer. Exact meaning is device-</i></td></tr>
<tr><th id="209">209</th><td><i class="doc">     * and application-dependent. Message is sent before rendering first</i></td></tr>
<tr><th id="210">210</th><td><i class="doc">     * frame and all one-shot initializations should be done here.</i></td></tr>
<tr><th id="211">211</th><td><i class="doc">     * Application is allowed to ignore preferred window buffer size.</i></td></tr>
<tr><th id="212">212</th><td><i class="doc">     *</i></td></tr>
<tr><th id="213">213</th><td><i class="doc">     * <span class="command">@note</span>: Application is obligated to inform about window buffer size</i></td></tr>
<tr><th id="214">214</th><td><i class="doc">     *        with AV_APP_TO_DEV_WINDOW_SIZE message.</i></td></tr>
<tr><th id="215">215</th><td><i class="doc">     *</i></td></tr>
<tr><th id="216">216</th><td><i class="doc">     * data: AVDeviceRect: preferred size of the window buffer.</i></td></tr>
<tr><th id="217">217</th><td><i class="doc">     *       NULL: no preferred size of the window buffer.</i></td></tr>
<tr><th id="218">218</th><td><i class="doc">     */</i></td></tr>
<tr><th id="219">219</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_CREATE_WINDOW_BUFFER" title='AVDevToAppMessageType::AV_DEV_TO_APP_CREATE_WINDOW_BUFFER' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_CREATE_WINDOW_BUFFER">AV_DEV_TO_APP_CREATE_WINDOW_BUFFER</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;E&apos;) | ((&apos;R&apos;) &lt;&lt; 8) | ((&apos;C&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'C'</kbd>,<kbd>'R'</kbd>,<kbd>'E'</kbd>),</td></tr>
<tr><th id="220">220</th><td></td></tr>
<tr><th id="221">221</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="222">222</th><td><i class="doc">     * Prepare window buffer message.</i></td></tr>
<tr><th id="223">223</th><td><i class="doc">     *</i></td></tr>
<tr><th id="224">224</th><td><i class="doc">     * Device requests to prepare a window buffer for rendering.</i></td></tr>
<tr><th id="225">225</th><td><i class="doc">     * Exact meaning is device- and application-dependent.</i></td></tr>
<tr><th id="226">226</th><td><i class="doc">     * Message is sent before rendering of each frame.</i></td></tr>
<tr><th id="227">227</th><td><i class="doc">     *</i></td></tr>
<tr><th id="228">228</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="229">229</th><td><i class="doc">     */</i></td></tr>
<tr><th id="230">230</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER" title='AVDevToAppMessageType::AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER">AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;E&apos;) | ((&apos;R&apos;) &lt;&lt; 8) | ((&apos;P&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'P'</kbd>,<kbd>'R'</kbd>,<kbd>'E'</kbd>),</td></tr>
<tr><th id="231">231</th><td></td></tr>
<tr><th id="232">232</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="233">233</th><td><i class="doc">     * Display window buffer message.</i></td></tr>
<tr><th id="234">234</th><td><i class="doc">     *</i></td></tr>
<tr><th id="235">235</th><td><i class="doc">     * Device requests to display a window buffer.</i></td></tr>
<tr><th id="236">236</th><td><i class="doc">     * Message is sent when new frame is ready to be displayed.</i></td></tr>
<tr><th id="237">237</th><td><i class="doc">     * Usually buffers need to be swapped in handler of this message.</i></td></tr>
<tr><th id="238">238</th><td><i class="doc">     *</i></td></tr>
<tr><th id="239">239</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="240">240</th><td><i class="doc">     */</i></td></tr>
<tr><th id="241">241</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER" title='AVDevToAppMessageType::AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER">AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;S&apos;) | ((&apos;I&apos;) &lt;&lt; 8) | ((&apos;D&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'D'</kbd>,<kbd>'I'</kbd>,<kbd>'S'</kbd>),</td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="244">244</th><td><i class="doc">     * Destroy window buffer message.</i></td></tr>
<tr><th id="245">245</th><td><i class="doc">     *</i></td></tr>
<tr><th id="246">246</th><td><i class="doc">     * Device requests to destroy a window buffer.</i></td></tr>
<tr><th id="247">247</th><td><i class="doc">     * Message is sent when device is about to be destroyed and window</i></td></tr>
<tr><th id="248">248</th><td><i class="doc">     * buffer is not required anymore.</i></td></tr>
<tr><th id="249">249</th><td><i class="doc">     *</i></td></tr>
<tr><th id="250">250</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="251">251</th><td><i class="doc">     */</i></td></tr>
<tr><th id="252">252</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER" title='AVDevToAppMessageType::AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER">AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;S&apos;) | ((&apos;E&apos;) &lt;&lt; 8) | ((&apos;D&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'D'</kbd>,<kbd>'E'</kbd>,<kbd>'S'</kbd>),</td></tr>
<tr><th id="253">253</th><td></td></tr>
<tr><th id="254">254</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="255">255</th><td><i class="doc">     * Buffer fullness status messages.</i></td></tr>
<tr><th id="256">256</th><td><i class="doc">     *</i></td></tr>
<tr><th id="257">257</th><td><i class="doc">     * Device signals buffer overflow/underflow.</i></td></tr>
<tr><th id="258">258</th><td><i class="doc">     *</i></td></tr>
<tr><th id="259">259</th><td><i class="doc">     * data: NULL.</i></td></tr>
<tr><th id="260">260</th><td><i class="doc">     */</i></td></tr>
<tr><th id="261">261</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_OVERFLOW" title='AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_OVERFLOW' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_OVERFLOW">AV_DEV_TO_APP_BUFFER_OVERFLOW</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;L&apos;) | ((&apos;F&apos;) &lt;&lt; 8) | ((&apos;O&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'O'</kbd>,<kbd>'F'</kbd>,<kbd>'L'</kbd>),</td></tr>
<tr><th id="262">262</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_UNDERFLOW" title='AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_UNDERFLOW' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_UNDERFLOW">AV_DEV_TO_APP_BUFFER_UNDERFLOW</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;L&apos;) | ((&apos;F&apos;) &lt;&lt; 8) | ((&apos;U&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'U'</kbd>,<kbd>'F'</kbd>,<kbd>'L'</kbd>),</td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="265">265</th><td><i class="doc">     * Buffer readable/writable.</i></td></tr>
<tr><th id="266">266</th><td><i class="doc">     *</i></td></tr>
<tr><th id="267">267</th><td><i class="doc">     * Device informs that buffer is readable/writable.</i></td></tr>
<tr><th id="268">268</th><td><i class="doc">     * When possible, device informs how many bytes can be read/write.</i></td></tr>
<tr><th id="269">269</th><td><i class="doc">     *</i></td></tr>
<tr><th id="270">270</th><td><i class="doc">     * <span class="command">@warning</span> Device may not inform when number of bytes than can be read/write changes.</i></td></tr>
<tr><th id="271">271</th><td><i class="doc">     *</i></td></tr>
<tr><th id="272">272</th><td><i class="doc">     * data: int64_t: amount of bytes available to read/write.</i></td></tr>
<tr><th id="273">273</th><td><i class="doc">     *       NULL: amount of bytes available to read/write is not known.</i></td></tr>
<tr><th id="274">274</th><td><i class="doc">     */</i></td></tr>
<tr><th id="275">275</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_READABLE" title='AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_READABLE' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_READABLE">AV_DEV_TO_APP_BUFFER_READABLE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos; &apos;) | ((&apos;D&apos;) &lt;&lt; 8) | ((&apos;R&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'R'</kbd>,<kbd>'D'</kbd>,<kbd>' '</kbd>),</td></tr>
<tr><th id="276">276</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_WRITABLE" title='AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_WRITABLE' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_BUFFER_WRITABLE">AV_DEV_TO_APP_BUFFER_WRITABLE</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos; &apos;) | ((&apos;R&apos;) &lt;&lt; 8) | ((&apos;W&apos;) &lt;&lt; 16) | ((unsigned)(&apos;B&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'B'</kbd>,<kbd>'W'</kbd>,<kbd>'R'</kbd>,<kbd>' '</kbd>),</td></tr>
<tr><th id="277">277</th><td></td></tr>
<tr><th id="278">278</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="279">279</th><td><i class="doc">     * Mute state change message.</i></td></tr>
<tr><th id="280">280</th><td><i class="doc">     *</i></td></tr>
<tr><th id="281">281</th><td><i class="doc">     * Device informs that mute state has changed.</i></td></tr>
<tr><th id="282">282</th><td><i class="doc">     *</i></td></tr>
<tr><th id="283">283</th><td><i class="doc">     * data: int: 0 for not muted state, non-zero for muted state.</i></td></tr>
<tr><th id="284">284</th><td><i class="doc">     */</i></td></tr>
<tr><th id="285">285</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_MUTE_STATE_CHANGED" title='AVDevToAppMessageType::AV_DEV_TO_APP_MUTE_STATE_CHANGED' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_MUTE_STATE_CHANGED">AV_DEV_TO_APP_MUTE_STATE_CHANGED</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;T&apos;) | ((&apos;U&apos;) &lt;&lt; 8) | ((&apos;M&apos;) &lt;&lt; 16) | ((unsigned)(&apos;C&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'C'</kbd>,<kbd>'M'</kbd>,<kbd>'U'</kbd>,<kbd>'T'</kbd>),</td></tr>
<tr><th id="286">286</th><td></td></tr>
<tr><th id="287">287</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="288">288</th><td><i class="doc">     * Volume level change message.</i></td></tr>
<tr><th id="289">289</th><td><i class="doc">     *</i></td></tr>
<tr><th id="290">290</th><td><i class="doc">     * Device informs that volume level has changed.</i></td></tr>
<tr><th id="291">291</th><td><i class="doc">     *</i></td></tr>
<tr><th id="292">292</th><td><i class="doc">     * data: double: new volume with range of 0.0 - 1.0.</i></td></tr>
<tr><th id="293">293</th><td><i class="doc">     */</i></td></tr>
<tr><th id="294">294</th><td>    <dfn class="enum" id="AVDevToAppMessageType::AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED" title='AVDevToAppMessageType::AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED' data-ref="AVDevToAppMessageType::AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED">AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED</dfn> = <a class="macro" href="../libavutil/common.h.html#343" title="((&apos;L&apos;) | ((&apos;O&apos;) &lt;&lt; 8) | ((&apos;V&apos;) &lt;&lt; 16) | ((unsigned)(&apos;C&apos;) &lt;&lt; 24))" data-ref="_M/MKBETAG">MKBETAG</a>(<kbd>'C'</kbd>,<kbd>'V'</kbd>,<kbd>'O'</kbd>,<kbd>'L'</kbd>),</td></tr>
<tr><th id="295">295</th><td>};</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i class="doc">/**</i></td></tr>
<tr><th id="298">298</th><td><i class="doc"> * Send control message from application to device.</i></td></tr>
<tr><th id="299">299</th><td><i class="doc"> *</i></td></tr>
<tr><th id="300">300</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">s</span>         device context.</i></td></tr>
<tr><th id="301">301</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">type</span>      message type.</i></td></tr>
<tr><th id="302">302</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">data</span>      message data. Exact type depends on message type.</i></td></tr>
<tr><th id="303">303</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">data_size</span> size of message data.</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> * <span class="command">@return</span> &gt;= 0 on success, negative on error.</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> *         AVERROR(ENOSYS) when device doesn't implement handler of the message.</i></td></tr>
<tr><th id="306">306</th><td><i class="doc"> */</i></td></tr>
<tr><th id="307">307</th><td><em>int</em> <dfn class="decl" id="avdevice_app_to_dev_control_message" title='avdevice_app_to_dev_control_message' data-ref="avdevice_app_to_dev_control_message">avdevice_app_to_dev_control_message</dfn>(<b>struct</b> <a class="type" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="local col5 decl" id="2345s" title='s' data-type='struct AVFormatContext *' data-ref="2345s">s</dfn>,</td></tr>
<tr><th id="308">308</th><td>                                        <b>enum</b> <a class="type" href="#AVAppToDevMessageType" title='AVAppToDevMessageType' data-ref="AVAppToDevMessageType">AVAppToDevMessageType</a> <dfn class="local col6 decl" id="2346type" title='type' data-type='enum AVAppToDevMessageType' data-ref="2346type">type</dfn>,</td></tr>
<tr><th id="309">309</th><td>                                        <em>void</em> *<dfn class="local col7 decl" id="2347data" title='data' data-type='void *' data-ref="2347data">data</dfn>, <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col8 decl" id="2348data_size" title='data_size' data-type='size_t' data-ref="2348data_size">data_size</dfn>);</td></tr>
<tr><th id="310">310</th><td></td></tr>
<tr><th id="311">311</th><td><i class="doc">/**</i></td></tr>
<tr><th id="312">312</th><td><i class="doc"> * Send control message from device to application.</i></td></tr>
<tr><th id="313">313</th><td><i class="doc"> *</i></td></tr>
<tr><th id="314">314</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">s</span>         device context.</i></td></tr>
<tr><th id="315">315</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">type</span>      message type.</i></td></tr>
<tr><th id="316">316</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">data</span>      message data. Can be NULL.</i></td></tr>
<tr><th id="317">317</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">data_size</span> size of message data.</i></td></tr>
<tr><th id="318">318</th><td><i class="doc"> * <span class="command">@return</span> &gt;= 0 on success, negative on error.</i></td></tr>
<tr><th id="319">319</th><td><i class="doc"> *         AVERROR(ENOSYS) when application doesn't implement handler of the message.</i></td></tr>
<tr><th id="320">320</th><td><i class="doc"> */</i></td></tr>
<tr><th id="321">321</th><td><em>int</em> <dfn class="decl" id="avdevice_dev_to_app_control_message" title='avdevice_dev_to_app_control_message' data-ref="avdevice_dev_to_app_control_message">avdevice_dev_to_app_control_message</dfn>(<b>struct</b> <a class="type" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="local col9 decl" id="2349s" title='s' data-type='struct AVFormatContext *' data-ref="2349s">s</dfn>,</td></tr>
<tr><th id="322">322</th><td>                                        <b>enum</b> <a class="type" href="#AVDevToAppMessageType" title='AVDevToAppMessageType' data-ref="AVDevToAppMessageType">AVDevToAppMessageType</a> <dfn class="local col0 decl" id="2350type" title='type' data-type='enum AVDevToAppMessageType' data-ref="2350type">type</dfn>,</td></tr>
<tr><th id="323">323</th><td>                                        <em>void</em> *<dfn class="local col1 decl" id="2351data" title='data' data-type='void *' data-ref="2351data">data</dfn>, <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col2 decl" id="2352data_size" title='data_size' data-type='size_t' data-ref="2352data_size">data_size</dfn>);</td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><i class="doc">/**</i></td></tr>
<tr><th id="326">326</th><td><i class="doc"> * Following API allows user to probe device capabilities (supported codecs,</i></td></tr>
<tr><th id="327">327</th><td><i class="doc"> * pixel formats, sample formats, resolutions, channel counts, etc).</i></td></tr>
<tr><th id="328">328</th><td><i class="doc"> * It is build on top op AVOption API.</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> * Queried capabilities make it possible to set up converters of video or audio</i></td></tr>
<tr><th id="330">330</th><td><i class="doc"> * parameters that fit to the device.</i></td></tr>
<tr><th id="331">331</th><td><i class="doc"> *</i></td></tr>
<tr><th id="332">332</th><td><i class="doc"> * List of capabilities that can be queried:</i></td></tr>
<tr><th id="333">333</th><td><i class="doc"> *  - Capabilities valid for both audio and video devices:</i></td></tr>
<tr><th id="334">334</th><td><i class="doc"> *    - codec:          supported audio/video codecs.</i></td></tr>
<tr><th id="335">335</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT (AVCodecID value)</i></td></tr>
<tr><th id="336">336</th><td><i class="doc"> *  - Capabilities valid for audio devices:</i></td></tr>
<tr><th id="337">337</th><td><i class="doc"> *    - sample_format:  supported sample formats.</i></td></tr>
<tr><th id="338">338</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT (AVSampleFormat value)</i></td></tr>
<tr><th id="339">339</th><td><i class="doc"> *    - sample_rate:    supported sample rates.</i></td></tr>
<tr><th id="340">340</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT</i></td></tr>
<tr><th id="341">341</th><td><i class="doc"> *    - channels:       supported number of channels.</i></td></tr>
<tr><th id="342">342</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT</i></td></tr>
<tr><th id="343">343</th><td><i class="doc"> *    - channel_layout: supported channel layouts.</i></td></tr>
<tr><th id="344">344</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT64</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"> *  - Capabilities valid for video devices:</i></td></tr>
<tr><th id="346">346</th><td><i class="doc"> *    - pixel_format:   supported pixel formats.</i></td></tr>
<tr><th id="347">347</th><td><i class="doc"> *                      type: AV_OPT_TYPE_INT (AVPixelFormat value)</i></td></tr>
<tr><th id="348">348</th><td><i class="doc"> *    - window_size:    supported window sizes (describes size of the window size presented to the user).</i></td></tr>
<tr><th id="349">349</th><td><i class="doc"> *                      type: AV_OPT_TYPE_IMAGE_SIZE</i></td></tr>
<tr><th id="350">350</th><td><i class="doc"> *    - frame_size:     supported frame sizes (describes size of provided video frames).</i></td></tr>
<tr><th id="351">351</th><td><i class="doc"> *                      type: AV_OPT_TYPE_IMAGE_SIZE</i></td></tr>
<tr><th id="352">352</th><td><i class="doc"> *    - fps:            supported fps values</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"> *                      type: AV_OPT_TYPE_RATIONAL</i></td></tr>
<tr><th id="354">354</th><td><i class="doc"> *</i></td></tr>
<tr><th id="355">355</th><td><i class="doc"> * Value of the capability may be set by user using av_opt_set() function</i></td></tr>
<tr><th id="356">356</th><td><i class="doc"> * and AVDeviceCapabilitiesQuery object. Following queries will</i></td></tr>
<tr><th id="357">357</th><td><i class="doc"> * limit results to the values matching already set capabilities.</i></td></tr>
<tr><th id="358">358</th><td><i class="doc"> * For example, setting a codec may impact number of formats or fps values</i></td></tr>
<tr><th id="359">359</th><td><i class="doc"> * returned during next query. Setting invalid value may limit results to zero.</i></td></tr>
<tr><th id="360">360</th><td><i class="doc"> *</i></td></tr>
<tr><th id="361">361</th><td><i class="doc"> * Example of the usage basing on opengl output device:</i></td></tr>
<tr><th id="362">362</th><td><i class="doc"> *</i></td></tr>
<tr><th id="363">363</th><td><i class="doc"> * <span class="command">@code</span></i></td></tr>
<tr><th id="364">364</th><td><i class="doc"> *<span class="verb">  AVFormatContext *oc = NULL;</span></i></td></tr>
<tr><th id="365">365</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  AVDeviceCapabilitiesQuery *caps = NULL;</span></i></td></tr>
<tr><th id="366">366</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  AVOptionRanges *ranges;</span></i></td></tr>
<tr><th id="367">367</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  int ret;</span></i></td></tr>
<tr><th id="368">368</th><td><i class="doc"><span class="verb"></span> *<span class="verb"></span></i></td></tr>
<tr><th id="369">369</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  if ((ret = avformat_alloc_output_context2(&amp;oc, NULL, "opengl", NULL)) &lt; 0)</span></i></td></tr>
<tr><th id="370">370</th><td><i class="doc"><span class="verb"></span> *<span class="verb">      goto fail;</span></i></td></tr>
<tr><th id="371">371</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  if (avdevice_capabilities_create(&amp;caps, oc, NULL) &lt; 0)</span></i></td></tr>
<tr><th id="372">372</th><td><i class="doc"><span class="verb"></span> *<span class="verb">      goto fail;</span></i></td></tr>
<tr><th id="373">373</th><td><i class="doc"><span class="verb"></span> *<span class="verb"></span></i></td></tr>
<tr><th id="374">374</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //query codecs</span></i></td></tr>
<tr><th id="375">375</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  if (av_opt_query_ranges(&amp;ranges, caps, "codec", AV_OPT_MULTI_COMPONENT_RANGE)) &lt; 0)</span></i></td></tr>
<tr><th id="376">376</th><td><i class="doc"><span class="verb"></span> *<span class="verb">      goto fail;</span></i></td></tr>
<tr><th id="377">377</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //pick codec here and set it</span></i></td></tr>
<tr><th id="378">378</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  av_opt_set(caps, "codec", AV_CODEC_ID_RAWVIDEO, 0);</span></i></td></tr>
<tr><th id="379">379</th><td><i class="doc"><span class="verb"></span> *<span class="verb"></span></i></td></tr>
<tr><th id="380">380</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //query format</span></i></td></tr>
<tr><th id="381">381</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  if (av_opt_query_ranges(&amp;ranges, caps, "pixel_format", AV_OPT_MULTI_COMPONENT_RANGE)) &lt; 0)</span></i></td></tr>
<tr><th id="382">382</th><td><i class="doc"><span class="verb"></span> *<span class="verb">      goto fail;</span></i></td></tr>
<tr><th id="383">383</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //pick format here and set it</span></i></td></tr>
<tr><th id="384">384</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  av_opt_set(caps, "pixel_format", AV_PIX_FMT_YUV420P, 0);</span></i></td></tr>
<tr><th id="385">385</th><td><i class="doc"><span class="verb"></span> *<span class="verb"></span></i></td></tr>
<tr><th id="386">386</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //query and set more capabilities</span></i></td></tr>
<tr><th id="387">387</th><td><i class="doc"><span class="verb"></span> *<span class="verb"></span></i></td></tr>
<tr><th id="388">388</th><td><i class="doc"><span class="verb"></span> *<span class="verb"> fail:</span></i></td></tr>
<tr><th id="389">389</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  //clean up code</span></i></td></tr>
<tr><th id="390">390</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  avdevice_capabilities_free(&amp;query, oc);</span></i></td></tr>
<tr><th id="391">391</th><td><i class="doc"><span class="verb"></span> *<span class="verb">  avformat_free_context(oc);</span></i></td></tr>
<tr><th id="392">392</th><td><i class="doc"><span class="verb"></span> * @endcode</i></td></tr>
<tr><th id="393">393</th><td><i class="doc"> */</i></td></tr>
<tr><th id="394">394</th><td></td></tr>
<tr><th id="395">395</th><td><i class="doc">/**</i></td></tr>
<tr><th id="396">396</th><td><i class="doc"> * Structure describes device capabilities.</i></td></tr>
<tr><th id="397">397</th><td><i class="doc"> *</i></td></tr>
<tr><th id="398">398</th><td><i class="doc"> * It is used by devices in conjunction with av_device_capabilities AVOption table</i></td></tr>
<tr><th id="399">399</th><td><i class="doc"> * to implement capabilities probing API based on AVOption API. Should not be used directly.</i></td></tr>
<tr><th id="400">400</th><td><i class="doc"> */</i></td></tr>
<tr><th id="401">401</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="AVDeviceCapabilitiesQuery" title='AVDeviceCapabilitiesQuery' data-ref="AVDeviceCapabilitiesQuery"><a class="type" href="#AVDeviceCapabilitiesQuery" title='AVDeviceCapabilitiesQuery' data-ref="AVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a></dfn> {</td></tr>
<tr><th id="402">402</th><td>    <em>const</em> <a class="typedef" href="../libavutil/log.h.html#AVClass" title='AVClass' data-type='struct AVClass' data-ref="AVClass">AVClass</a> *<dfn class="decl" id="AVDeviceCapabilitiesQuery::av_class" title='AVDeviceCapabilitiesQuery::av_class' data-ref="AVDeviceCapabilitiesQuery::av_class">av_class</dfn>;</td></tr>
<tr><th id="403">403</th><td>    <a class="typedef" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-type='struct AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="decl" id="AVDeviceCapabilitiesQuery::device_context" title='AVDeviceCapabilitiesQuery::device_context' data-ref="AVDeviceCapabilitiesQuery::device_context">device_context</dfn>;</td></tr>
<tr><th id="404">404</th><td>    <b>enum</b> <a class="type" href="../libavcodec/avcodec.h.html#AVCodecID" title='AVCodecID' data-ref="AVCodecID">AVCodecID</a> <dfn class="decl" id="AVDeviceCapabilitiesQuery::codec" title='AVDeviceCapabilitiesQuery::codec' data-ref="AVDeviceCapabilitiesQuery::codec">codec</dfn>;</td></tr>
<tr><th id="405">405</th><td>    <b>enum</b> <a class="type" href="../libavutil/samplefmt.h.html#AVSampleFormat" title='AVSampleFormat' data-ref="AVSampleFormat">AVSampleFormat</a> <dfn class="decl" id="AVDeviceCapabilitiesQuery::sample_format" title='AVDeviceCapabilitiesQuery::sample_format' data-ref="AVDeviceCapabilitiesQuery::sample_format">sample_format</dfn>;</td></tr>
<tr><th id="406">406</th><td>    <b>enum</b> <a class="type" href="../libavutil/pixfmt.h.html#AVPixelFormat" title='AVPixelFormat' data-ref="AVPixelFormat">AVPixelFormat</a> <dfn class="decl" id="AVDeviceCapabilitiesQuery::pixel_format" title='AVDeviceCapabilitiesQuery::pixel_format' data-ref="AVDeviceCapabilitiesQuery::pixel_format">pixel_format</dfn>;</td></tr>
<tr><th id="407">407</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::sample_rate" title='AVDeviceCapabilitiesQuery::sample_rate' data-ref="AVDeviceCapabilitiesQuery::sample_rate">sample_rate</dfn>;</td></tr>
<tr><th id="408">408</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::channels" title='AVDeviceCapabilitiesQuery::channels' data-ref="AVDeviceCapabilitiesQuery::channels">channels</dfn>;</td></tr>
<tr><th id="409">409</th><td>    <a class="typedef" href="../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl" id="AVDeviceCapabilitiesQuery::channel_layout" title='AVDeviceCapabilitiesQuery::channel_layout' data-ref="AVDeviceCapabilitiesQuery::channel_layout">channel_layout</dfn>;</td></tr>
<tr><th id="410">410</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::window_width" title='AVDeviceCapabilitiesQuery::window_width' data-ref="AVDeviceCapabilitiesQuery::window_width">window_width</dfn>;</td></tr>
<tr><th id="411">411</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::window_height" title='AVDeviceCapabilitiesQuery::window_height' data-ref="AVDeviceCapabilitiesQuery::window_height">window_height</dfn>;</td></tr>
<tr><th id="412">412</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::frame_width" title='AVDeviceCapabilitiesQuery::frame_width' data-ref="AVDeviceCapabilitiesQuery::frame_width">frame_width</dfn>;</td></tr>
<tr><th id="413">413</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceCapabilitiesQuery::frame_height" title='AVDeviceCapabilitiesQuery::frame_height' data-ref="AVDeviceCapabilitiesQuery::frame_height">frame_height</dfn>;</td></tr>
<tr><th id="414">414</th><td>    <a class="typedef" href="../libavutil/rational.h.html#AVRational" title='AVRational' data-type='struct AVRational' data-ref="AVRational">AVRational</a> <dfn class="decl" id="AVDeviceCapabilitiesQuery::fps" title='AVDeviceCapabilitiesQuery::fps' data-ref="AVDeviceCapabilitiesQuery::fps">fps</dfn>;</td></tr>
<tr><th id="415">415</th><td>} <dfn class="typedef" id="AVDeviceCapabilitiesQuery" title='AVDeviceCapabilitiesQuery' data-type='struct AVDeviceCapabilitiesQuery' data-ref="AVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</dfn>;</td></tr>
<tr><th id="416">416</th><td></td></tr>
<tr><th id="417">417</th><td><i class="doc">/**</i></td></tr>
<tr><th id="418">418</th><td><i class="doc"> * AVOption table used by devices to implement device capabilities API. Should not be used by a user.</i></td></tr>
<tr><th id="419">419</th><td><i class="doc"> */</i></td></tr>
<tr><th id="420">420</th><td><b>extern</b> <em>const</em> <a class="typedef" href="../libavutil/opt.h.html#AVOption" title='AVOption' data-type='struct AVOption' data-ref="AVOption">AVOption</a> <dfn class="decl" id="av_device_capabilities" title='av_device_capabilities' data-ref="av_device_capabilities">av_device_capabilities</dfn>[];</td></tr>
<tr><th id="421">421</th><td></td></tr>
<tr><th id="422">422</th><td><i class="doc">/**</i></td></tr>
<tr><th id="423">423</th><td><i class="doc"> * Initialize capabilities probing API based on AVOption API.</i></td></tr>
<tr><th id="424">424</th><td><i class="doc"> *</i></td></tr>
<tr><th id="425">425</th><td><i class="doc"> * avdevice_capabilities_free() must be called when query capabilities API is</i></td></tr>
<tr><th id="426">426</th><td><i class="doc"> * not used anymore.</i></td></tr>
<tr><th id="427">427</th><td><i class="doc"> *</i></td></tr>
<tr><th id="428">428</th><td><i class="doc"> * <span class="command">@param</span>[out] <span class="arg">caps</span>      Device capabilities data. Pointer to a NULL pointer must be passed.</i></td></tr>
<tr><th id="429">429</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">s</span>              Context of the device.</i></td></tr>
<tr><th id="430">430</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">device_options</span> An AVDictionary filled with device-private options.</i></td></tr>
<tr><th id="431">431</th><td><i class="doc"> *                       On return this parameter will be destroyed and replaced with a dict</i></td></tr>
<tr><th id="432">432</th><td><i class="doc"> *                       containing options that were not found. May be NULL.</i></td></tr>
<tr><th id="433">433</th><td><i class="doc"> *                       The same options must be passed later to avformat_write_header() for output</i></td></tr>
<tr><th id="434">434</th><td><i class="doc"> *                       devices or avformat_open_input() for input devices, or at any other place</i></td></tr>
<tr><th id="435">435</th><td><i class="doc"> *                       that affects device-private options.</i></td></tr>
<tr><th id="436">436</th><td><i class="doc"> *</i></td></tr>
<tr><th id="437">437</th><td><i class="doc"> * <span class="command">@return</span> &gt;= 0 on success, negative otherwise.</i></td></tr>
<tr><th id="438">438</th><td><i class="doc"> */</i></td></tr>
<tr><th id="439">439</th><td><em>int</em> <dfn class="decl" id="avdevice_capabilities_create" title='avdevice_capabilities_create' data-ref="avdevice_capabilities_create">avdevice_capabilities_create</dfn>(<a class="typedef" href="#AVDeviceCapabilitiesQuery" title='AVDeviceCapabilitiesQuery' data-type='struct AVDeviceCapabilitiesQuery' data-ref="AVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> **<dfn class="local col3 decl" id="2353caps" title='caps' data-type='AVDeviceCapabilitiesQuery **' data-ref="2353caps">caps</dfn>, <a class="typedef" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-type='struct AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="local col4 decl" id="2354s" title='s' data-type='AVFormatContext *' data-ref="2354s">s</dfn>,</td></tr>
<tr><th id="440">440</th><td>                                 <a class="typedef" href="../libavutil/dict.h.html#AVDictionary" title='AVDictionary' data-type='struct AVDictionary' data-ref="AVDictionary">AVDictionary</a> **<dfn class="local col5 decl" id="2355device_options" title='device_options' data-type='AVDictionary **' data-ref="2355device_options">device_options</dfn>);</td></tr>
<tr><th id="441">441</th><td></td></tr>
<tr><th id="442">442</th><td><i class="doc">/**</i></td></tr>
<tr><th id="443">443</th><td><i class="doc"> * Free resources created by avdevice_capabilities_create()</i></td></tr>
<tr><th id="444">444</th><td><i class="doc"> *</i></td></tr>
<tr><th id="445">445</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">caps</span> Device capabilities data to be freed.</i></td></tr>
<tr><th id="446">446</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">s</span>    Context of the device.</i></td></tr>
<tr><th id="447">447</th><td><i class="doc"> */</i></td></tr>
<tr><th id="448">448</th><td><em>void</em> <dfn class="decl" id="avdevice_capabilities_free" title='avdevice_capabilities_free' data-ref="avdevice_capabilities_free">avdevice_capabilities_free</dfn>(<a class="typedef" href="#AVDeviceCapabilitiesQuery" title='AVDeviceCapabilitiesQuery' data-type='struct AVDeviceCapabilitiesQuery' data-ref="AVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> **<dfn class="local col6 decl" id="2356caps" title='caps' data-type='AVDeviceCapabilitiesQuery **' data-ref="2356caps">caps</dfn>, <a class="typedef" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-type='struct AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="local col7 decl" id="2357s" title='s' data-type='AVFormatContext *' data-ref="2357s">s</dfn>);</td></tr>
<tr><th id="449">449</th><td></td></tr>
<tr><th id="450">450</th><td><i class="doc">/**</i></td></tr>
<tr><th id="451">451</th><td><i class="doc"> * Structure describes basic parameters of the device.</i></td></tr>
<tr><th id="452">452</th><td><i class="doc"> */</i></td></tr>
<tr><th id="453">453</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="AVDeviceInfo" title='AVDeviceInfo' data-ref="AVDeviceInfo"><a class="type" href="#AVDeviceInfo" title='AVDeviceInfo' data-ref="AVDeviceInfo">AVDeviceInfo</a></dfn> {</td></tr>
<tr><th id="454">454</th><td>    <em>char</em> *<dfn class="decl" id="AVDeviceInfo::device_name" title='AVDeviceInfo::device_name' data-ref="AVDeviceInfo::device_name">device_name</dfn>;                   <i class="doc">/**&lt; device name, format depends on device */</i></td></tr>
<tr><th id="455">455</th><td>    <em>char</em> *<dfn class="decl" id="AVDeviceInfo::device_description" title='AVDeviceInfo::device_description' data-ref="AVDeviceInfo::device_description">device_description</dfn>;            <i class="doc">/**&lt; human friendly name */</i></td></tr>
<tr><th id="456">456</th><td>} <dfn class="typedef" id="AVDeviceInfo" title='AVDeviceInfo' data-type='struct AVDeviceInfo' data-ref="AVDeviceInfo">AVDeviceInfo</dfn>;</td></tr>
<tr><th id="457">457</th><td></td></tr>
<tr><th id="458">458</th><td><i class="doc">/**</i></td></tr>
<tr><th id="459">459</th><td><i class="doc"> * List of devices.</i></td></tr>
<tr><th id="460">460</th><td><i class="doc"> */</i></td></tr>
<tr><th id="461">461</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="AVDeviceInfoList" title='AVDeviceInfoList' data-ref="AVDeviceInfoList"><a class="type" href="#AVDeviceInfoList" title='AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</a></dfn> {</td></tr>
<tr><th id="462">462</th><td>    <a class="typedef" href="#AVDeviceInfo" title='AVDeviceInfo' data-type='struct AVDeviceInfo' data-ref="AVDeviceInfo">AVDeviceInfo</a> **<dfn class="decl" id="AVDeviceInfoList::devices" title='AVDeviceInfoList::devices' data-ref="AVDeviceInfoList::devices">devices</dfn>;              <i class="doc">/**&lt; list of autodetected devices */</i></td></tr>
<tr><th id="463">463</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceInfoList::nb_devices" title='AVDeviceInfoList::nb_devices' data-ref="AVDeviceInfoList::nb_devices">nb_devices</dfn>;                      <i class="doc">/**&lt; number of autodetected devices */</i></td></tr>
<tr><th id="464">464</th><td>    <em>int</em> <dfn class="decl" id="AVDeviceInfoList::default_device" title='AVDeviceInfoList::default_device' data-ref="AVDeviceInfoList::default_device">default_device</dfn>;                  <i class="doc">/**&lt; index of default device or -1 if no default */</i></td></tr>
<tr><th id="465">465</th><td>} <dfn class="typedef" id="AVDeviceInfoList" title='AVDeviceInfoList' data-type='struct AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</dfn>;</td></tr>
<tr><th id="466">466</th><td></td></tr>
<tr><th id="467">467</th><td><i class="doc">/**</i></td></tr>
<tr><th id="468">468</th><td><i class="doc"> * List devices.</i></td></tr>
<tr><th id="469">469</th><td><i class="doc"> *</i></td></tr>
<tr><th id="470">470</th><td><i class="doc"> * Returns available device names and their parameters.</i></td></tr>
<tr><th id="471">471</th><td><i class="doc"> *</i></td></tr>
<tr><th id="472">472</th><td><i class="doc"> * <span class="command">@note</span>: Some devices may accept system-dependent device names that cannot be</i></td></tr>
<tr><th id="473">473</th><td><i class="doc"> *        autodetected. The list returned by this function cannot be assumed to</i></td></tr>
<tr><th id="474">474</th><td><i class="doc"> *        be always completed.</i></td></tr>
<tr><th id="475">475</th><td><i class="doc"> *</i></td></tr>
<tr><th id="476">476</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">s</span>                device context.</i></td></tr>
<tr><th id="477">477</th><td><i class="doc"> * <span class="command">@param</span>[out] <span class="arg">device_list</span> list of autodetected devices.</i></td></tr>
<tr><th id="478">478</th><td><i class="doc"> * <span class="command">@return</span> count of autodetected devices, negative on error.</i></td></tr>
<tr><th id="479">479</th><td><i class="doc"> */</i></td></tr>
<tr><th id="480">480</th><td><em>int</em> <dfn class="decl" id="avdevice_list_devices" title='avdevice_list_devices' data-ref="avdevice_list_devices">avdevice_list_devices</dfn>(<b>struct</b> <a class="type" href="../libavformat/avformat.h.html#AVFormatContext" title='AVFormatContext' data-ref="AVFormatContext">AVFormatContext</a> *<dfn class="local col8 decl" id="2358s" title='s' data-type='struct AVFormatContext *' data-ref="2358s">s</dfn>, <a class="typedef" href="#AVDeviceInfoList" title='AVDeviceInfoList' data-type='struct AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</a> **<dfn class="local col9 decl" id="2359device_list" title='device_list' data-type='AVDeviceInfoList **' data-ref="2359device_list">device_list</dfn>);</td></tr>
<tr><th id="481">481</th><td></td></tr>
<tr><th id="482">482</th><td><i class="doc">/**</i></td></tr>
<tr><th id="483">483</th><td><i class="doc"> * Convenient function to free result of avdevice_list_devices().</i></td></tr>
<tr><th id="484">484</th><td><i class="doc"> *</i></td></tr>
<tr><th id="485">485</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">devices</span> device list to be freed.</i></td></tr>
<tr><th id="486">486</th><td><i class="doc"> */</i></td></tr>
<tr><th id="487">487</th><td><em>void</em> <dfn class="decl" id="avdevice_free_list_devices" title='avdevice_free_list_devices' data-ref="avdevice_free_list_devices">avdevice_free_list_devices</dfn>(<a class="typedef" href="#AVDeviceInfoList" title='AVDeviceInfoList' data-type='struct AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</a> **<dfn class="local col0 decl" id="2360device_list" title='device_list' data-type='AVDeviceInfoList **' data-ref="2360device_list">device_list</dfn>);</td></tr>
<tr><th id="488">488</th><td></td></tr>
<tr><th id="489">489</th><td><i class="doc">/**</i></td></tr>
<tr><th id="490">490</th><td><i class="doc"> * List devices.</i></td></tr>
<tr><th id="491">491</th><td><i class="doc"> *</i></td></tr>
<tr><th id="492">492</th><td><i class="doc"> * Returns available device names and their parameters.</i></td></tr>
<tr><th id="493">493</th><td><i class="doc"> * These are convinient wrappers for avdevice_list_devices().</i></td></tr>
<tr><th id="494">494</th><td><i class="doc"> * Device context is allocated and deallocated internally.</i></td></tr>
<tr><th id="495">495</th><td><i class="doc"> *</i></td></tr>
<tr><th id="496">496</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">device</span>           device format. May be NULL if device name is set.</i></td></tr>
<tr><th id="497">497</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">device_name</span>      device name. May be NULL if device format is set.</i></td></tr>
<tr><th id="498">498</th><td><i class="doc"> * <span class="command">@param</span> <span class="arg">device_options</span>   An AVDictionary filled with device-private options. May be NULL.</i></td></tr>
<tr><th id="499">499</th><td><i class="doc"> *                         The same options must be passed later to avformat_write_header() for output</i></td></tr>
<tr><th id="500">500</th><td><i class="doc"> *                         devices or avformat_open_input() for input devices, or at any other place</i></td></tr>
<tr><th id="501">501</th><td><i class="doc"> *                         that affects device-private options.</i></td></tr>
<tr><th id="502">502</th><td><i class="doc"> * <span class="command">@param</span>[out] <span class="arg">device_list</span> list of autodetected devices</i></td></tr>
<tr><th id="503">503</th><td><i class="doc"> * <span class="command">@return</span> count of autodetected devices, negative on error.</i></td></tr>
<tr><th id="504">504</th><td><i class="doc"> * <span class="command">@note</span> device argument takes precedence over device_name when both are set.</i></td></tr>
<tr><th id="505">505</th><td><i class="doc"> */</i></td></tr>
<tr><th id="506">506</th><td><em>int</em> <dfn class="decl" id="avdevice_list_input_sources" title='avdevice_list_input_sources' data-ref="avdevice_list_input_sources">avdevice_list_input_sources</dfn>(<b>struct</b> <a class="type" href="../libavformat/avformat.h.html#AVInputFormat" title='AVInputFormat' data-ref="AVInputFormat">AVInputFormat</a> *<dfn class="local col1 decl" id="2361device" title='device' data-type='struct AVInputFormat *' data-ref="2361device">device</dfn>, <em>const</em> <em>char</em> *<dfn class="local col2 decl" id="2362device_name" title='device_name' data-type='const char *' data-ref="2362device_name">device_name</dfn>,</td></tr>
<tr><th id="507">507</th><td>                                <a class="typedef" href="../libavutil/dict.h.html#AVDictionary" title='AVDictionary' data-type='struct AVDictionary' data-ref="AVDictionary">AVDictionary</a> *<dfn class="local col3 decl" id="2363device_options" title='device_options' data-type='AVDictionary *' data-ref="2363device_options">device_options</dfn>, <a class="typedef" href="#AVDeviceInfoList" title='AVDeviceInfoList' data-type='struct AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</a> **<dfn class="local col4 decl" id="2364device_list" title='device_list' data-type='AVDeviceInfoList **' data-ref="2364device_list">device_list</dfn>);</td></tr>
<tr><th id="508">508</th><td><em>int</em> <dfn class="decl" id="avdevice_list_output_sinks" title='avdevice_list_output_sinks' data-ref="avdevice_list_output_sinks">avdevice_list_output_sinks</dfn>(<b>struct</b> <a class="type" href="../libavformat/avformat.h.html#AVOutputFormat" title='AVOutputFormat' data-ref="AVOutputFormat">AVOutputFormat</a> *<dfn class="local col5 decl" id="2365device" title='device' data-type='struct AVOutputFormat *' data-ref="2365device">device</dfn>, <em>const</em> <em>char</em> *<dfn class="local col6 decl" id="2366device_name" title='device_name' data-type='const char *' data-ref="2366device_name">device_name</dfn>,</td></tr>
<tr><th id="509">509</th><td>                               <a class="typedef" href="../libavutil/dict.h.html#AVDictionary" title='AVDictionary' data-type='struct AVDictionary' data-ref="AVDictionary">AVDictionary</a> *<dfn class="local col7 decl" id="2367device_options" title='device_options' data-type='AVDictionary *' data-ref="2367device_options">device_options</dfn>, <a class="typedef" href="#AVDeviceInfoList" title='AVDeviceInfoList' data-type='struct AVDeviceInfoList' data-ref="AVDeviceInfoList">AVDeviceInfoList</a> **<dfn class="local col8 decl" id="2368device_list" title='device_list' data-type='AVDeviceInfoList **' data-ref="2368device_list">device_list</dfn>);</td></tr>
<tr><th id="510">510</th><td></td></tr>
<tr><th id="511">511</th><td><i class="doc">/**</i></td></tr>
<tr><th id="512">512</th><td><i class="doc"> * @}</i></td></tr>
<tr><th id="513">513</th><td><i class="doc"> */</i></td></tr>
<tr><th id="514">514</th><td></td></tr>
<tr><th id="515">515</th><td><u>#<span data-ppcond="19">endif</span> /* AVDEVICE_AVDEVICE_H */</u></td></tr>
<tr><th id="516">516</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='alldevices.c.html'>ffmpeg/libavdevice/alldevices.c</a><br/>Generated on <em>2016-Oct-25</em> from project ffmpeg revision <em>3.0.git</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
