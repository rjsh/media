<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>nvEncodeAPI.h source code [ffmpeg/compat/nvenc/nvEncodeAPI.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="_NVENCSTATUS,_NVENC_EXTERNAL_ME_HINT,_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE,_NVENC_RECT,_NV_ENCODE_API_FUNCTION_LIST,_NV_ENC_BUFFER_FORMAT,_NV_ENC_CAPS,_NV_ENC_CAPS_PARAM,_NV_ENC_CODEC_CONFIG,_NV_ENC_CODEC_PIC_PARAMS,_NV_ENC_CONFIG,_NV_ENC_CONFIG_H264,_NV_ENC_CONFIG_H264_VUI_PARAMETERS,_NV_ENC_CONFIG_HEVC,_NV_ENC_CREATE_BITSTREAM_BUFFER,_NV_ENC_CREATE_INPUT_BUFFER,_NV_ENC_CREATE_MV_BUFFER,_NV_ENC_DEVICE_TYPE,_NV_ENC_EVENT_PARAMS,_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,_NV_ENC_H264_BDIRECT_MODE,_NV_ENC_H264_ENTROPY_CODING_MODE,_NV_ENC_H264_FMO_MODE,_NV_ENC_H264_MV_DATA,_NV_ENC_HEVC_CUSIZE,_NV_ENC_HEVC_MV_DATA,_NV_ENC_INITIALIZE_PARAMS,_NV_ENC_INPUT_RESOURCE_TYPE,_NV_ENC_LEVEL,_NV_ENC_LOCK_BITSTREAM,_NV_ENC_LOCK_INPUT_BUFFER,_NV_ENC_MAP_INPUT_RESOURCE,_NV_ENC_MEMORY_HEAP,_NV_ENC_MEONLY_PARAMS,_NV_ENC_MVECTOR,_NV_ENC_MV_PRECISION,_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS,_NV_ENC_PARAMS_FRAME_FIELD_MODE,_NV_ENC_PARAMS_RC_MODE,_NV_ENC_PIC_FLAGS,_NV_ENC_PIC_PARAMS,_NV_ENC_PIC_PARAMS_H264,_NV_ENC_PIC_PARAMS_HEVC,_NV_ENC_PIC_STRUCT,_NV_ENC_PIC_TYPE,_NV_ENC_PRESET_CONFIG,_NV_ENC_QP,_NV_ENC_RC_PARAMS,_NV_ENC_RECONFIGURE_PARAMS,_NV_ENC_REGISTER_RESOURCE,_NV_ENC_SEI_PAYLOAD,_NV_ENC_SEQUENCE_PARAM_PAYLOAD,_NV_ENC_STAT,_NV_ENC_STEREO_PACKING_MODE "/>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'ffmpeg/compat/nvenc/nvEncodeAPI.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>ffmpeg</a>/<a href='..'>compat</a>/<a href='./'>nvenc</a>/<a href='nvEncodeAPI.h.html'>nvEncodeAPI.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * This copyright notice applies to this header file only:</i></td></tr>
<tr><th id="3">3</th><td><i> *</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 2010-2015 NVIDIA Corporation</i></td></tr>
<tr><th id="5">5</th><td><i> *</i></td></tr>
<tr><th id="6">6</th><td><i> * Permission is hereby granted, free of charge, to any person</i></td></tr>
<tr><th id="7">7</th><td><i> * obtaining a copy of this software and associated documentation</i></td></tr>
<tr><th id="8">8</th><td><i> * files (the "Software"), to deal in the Software without</i></td></tr>
<tr><th id="9">9</th><td><i> * restriction, including without limitation the rights to use,</i></td></tr>
<tr><th id="10">10</th><td><i> * copy, modify, merge, publish, distribute, sublicense, and/or sell</i></td></tr>
<tr><th id="11">11</th><td><i> * copies of the software, and to permit persons to whom the</i></td></tr>
<tr><th id="12">12</th><td><i> * software is furnished to do so, subject to the following</i></td></tr>
<tr><th id="13">13</th><td><i> * conditions:</i></td></tr>
<tr><th id="14">14</th><td><i> *</i></td></tr>
<tr><th id="15">15</th><td><i> * The above copyright notice and this permission notice shall be</i></td></tr>
<tr><th id="16">16</th><td><i> * included in all copies or substantial portions of the Software.</i></td></tr>
<tr><th id="17">17</th><td><i> *</i></td></tr>
<tr><th id="18">18</th><td><i> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,</i></td></tr>
<tr><th id="19">19</th><td><i> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</i></td></tr>
<tr><th id="20">20</th><td><i> * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</i></td></tr>
<tr><th id="21">21</th><td><i> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</i></td></tr>
<tr><th id="22">22</th><td><i> * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</i></td></tr>
<tr><th id="23">23</th><td><i> * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</i></td></tr>
<tr><th id="24">24</th><td><i> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</i></td></tr>
<tr><th id="25">25</th><td><i> * OTHER DEALINGS IN THE SOFTWARE.</i></td></tr>
<tr><th id="26">26</th><td><i> */</i></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><i class="doc">/**</i></td></tr>
<tr><th id="29">29</th><td><i class="doc"> *<span class="command"> \file</span> nvEncodeAPI.h</i></td></tr>
<tr><th id="30">30</th><td><i class="doc"> *   NvEncodeAPI provides a NVENC Video Encoding interface to NVIDIA GPU devices based on the Kepler architecture.</i></td></tr>
<tr><th id="31">31</th><td><i class="doc"> * <span class="command">\date</span> 2011-2016</i></td></tr>
<tr><th id="32">32</th><td><i class="doc"> *  This file contains the interface constants, structure definitions and function prototypes.</i></td></tr>
<tr><th id="33">33</th><td><i class="doc"> */</i></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><u>#<span data-ppcond="35">ifndef</span> <span class="macro" data-ref="_M/_NV_ENCODEAPI_H_">_NV_ENCODEAPI_H_</span></u></td></tr>
<tr><th id="36">36</th><td><u>#define <dfn class="macro" id="_M/_NV_ENCODEAPI_H_" data-ref="_M/_NV_ENCODEAPI_H_">_NV_ENCODEAPI_H_</dfn></u></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><u>#include <a href="../../../include/stdlib.h.html">&lt;stdlib.h&gt;</a></u></td></tr>
<tr><th id="39">39</th><td></td></tr>
<tr><th id="40">40</th><td><u>#<span data-ppcond="40">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="41">41</th><td><u>#include &lt;windows.h&gt;</u></td></tr>
<tr><th id="42">42</th><td><u>#<span data-ppcond="40">endif</span></u></td></tr>
<tr><th id="43">43</th><td></td></tr>
<tr><th id="44">44</th><td><u>#<span data-ppcond="44">ifdef</span> <span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span></u></td></tr>
<tr><th id="45">45</th><td><u>#ifndef _STDINT</u></td></tr>
<tr><th id="46">46</th><td><b>typedef</b> __int32 int32_t;</td></tr>
<tr><th id="47">47</th><td><b>typedef</b> <em>unsigned</em> __int32 uint32_t;</td></tr>
<tr><th id="48">48</th><td><b>typedef</b> __int64 int64_t;</td></tr>
<tr><th id="49">49</th><td><b>typedef</b> <em>unsigned</em> __int64 uint64_t;</td></tr>
<tr><th id="50">50</th><td><b>typedef</b> <em>signed</em> <em>char</em> int8_t;</td></tr>
<tr><th id="51">51</th><td><b>typedef</b> <em>unsigned</em> <em>char</em> uint8_t;</td></tr>
<tr><th id="52">52</th><td><b>typedef</b> <em>short</em> int16_t;</td></tr>
<tr><th id="53">53</th><td><b>typedef</b> <em>unsigned</em> <em>short</em> uint16_t;</td></tr>
<tr><th id="54">54</th><td><u>#endif</u></td></tr>
<tr><th id="55">55</th><td><u>#<span data-ppcond="44">else</span></u></td></tr>
<tr><th id="56">56</th><td><u>#include &lt;stdint.h&gt;</u></td></tr>
<tr><th id="57">57</th><td><u>#<span data-ppcond="44">endif</span></u></td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><u>#<span data-ppcond="59">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="60">60</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="61">61</th><td><u>#<span data-ppcond="59">endif</span></u></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i class="doc">/**</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> * <span class="command">\addtogroup</span> <span class="verb">ENCODER_STRUCTURE NvEncodeAPI Data structures</span></i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> * @{</i></td></tr>
<tr><th id="66">66</th><td><i class="doc"> */</i></td></tr>
<tr><th id="67">67</th><td></td></tr>
<tr><th id="68">68</th><td><u>#<span data-ppcond="68">if</span> defined(<span class="macro" data-ref="_M/_WIN32">_WIN32</span>) || defined(<span class="macro" data-ref="_M/__CYGWIN__">__CYGWIN__</span>)</u></td></tr>
<tr><th id="69">69</th><td><u>#define NVENCAPI __stdcall</u></td></tr>
<tr><th id="70">70</th><td><u>#<span data-ppcond="68">else</span></u></td></tr>
<tr><th id="71">71</th><td><u>#define <dfn class="macro" id="_M/NVENCAPI" data-ref="_M/NVENCAPI">NVENCAPI</dfn></u></td></tr>
<tr><th id="72">72</th><td><u>#<span data-ppcond="68">endif</span></u></td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><u>#<span data-ppcond="74">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="75">75</th><td><b>typedef</b> RECT NVENC_RECT;</td></tr>
<tr><th id="76">76</th><td><u>#<span data-ppcond="74">else</span></u></td></tr>
<tr><th id="77">77</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="78">78</th><td><u>#<span data-ppcond="78">ifndef</span> <span class="macro" data-ref="_M/GUID">GUID</span></u></td></tr>
<tr><th id="79">79</th><td><i class="doc">/*!</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb" data-ref="GUID">GUID</span></i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> * Abstracts the GUID structure for non-windows platforms.</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> */</i></td></tr>
<tr><th id="83">83</th><td><i class="doc">// =========================================================================================</i></td></tr>
<tr><th id="84">84</th><td><b>typedef</b> <b>struct</b></td></tr>
<tr><th id="85">85</th><td>{</td></tr>
<tr><th id="86">86</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="{anonymous}::Data1" title='&lt;anonymous struct&gt;::Data1' data-ref="{anonymous}::Data1">Data1</dfn>;                                      <i class="doc">/**&lt; [in]: Specifies the first 8 hexadecimal digits of the GUID.                                */</i></td></tr>
<tr><th id="87">87</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="{anonymous}::Data2" title='&lt;anonymous struct&gt;::Data2' data-ref="{anonymous}::Data2">Data2</dfn>;                                      <i class="doc">/**&lt; [in]: Specifies the first group of 4 hexadecimal digits.                                   */</i></td></tr>
<tr><th id="88">88</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="{anonymous}::Data3" title='&lt;anonymous struct&gt;::Data3' data-ref="{anonymous}::Data3">Data3</dfn>;                                      <i class="doc">/**&lt; [in]: Specifies the second group of 4 hexadecimal digits.                                  */</i></td></tr>
<tr><th id="89">89</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>  <dfn class="decl" id="{anonymous}::Data4" title='&lt;anonymous struct&gt;::Data4' data-ref="{anonymous}::Data4">Data4</dfn>[<var>8</var>];                                   <i class="doc">/**&lt; [in]: Array of 8 bytes. The first 2 bytes contain the third group of 4 hexadecimal digits.</i></td></tr>
<tr><th id="90">90</th><td><i class="doc">                                                                    The remaining 6 bytes contain the final 12 hexadecimal digits.                       */</i></td></tr>
<tr><th id="91">91</th><td>} <dfn class="typedef" id="GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</dfn>;</td></tr>
<tr><th id="92">92</th><td><u>#<span data-ppcond="78">endif</span> // GUID</u></td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td><i class="doc">/**</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NVENC_RECT</span></i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * Defines a Rectangle. Used in ::NV_ENC_PREPROCESS_FRAME.</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> */</i></td></tr>
<tr><th id="98">98</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NVENC_RECT" title='_NVENC_RECT' data-ref="_NVENC_RECT"><a class="type" href="#_NVENC_RECT" title='_NVENC_RECT' data-ref="_NVENC_RECT">_NVENC_RECT</a></dfn></td></tr>
<tr><th id="99">99</th><td>{</td></tr>
<tr><th id="100">100</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NVENC_RECT::left" title='_NVENC_RECT::left' data-ref="_NVENC_RECT::left">left</dfn>;                                        <i class="doc">/**&lt; [in]: X coordinate of the upper left corner of rectangular area to be specified.       */</i></td></tr>
<tr><th id="101">101</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NVENC_RECT::top" title='_NVENC_RECT::top' data-ref="_NVENC_RECT::top">top</dfn>;                                         <i class="doc">/**&lt; [in]: Y coordinate of the upper left corner of the rectangular area to be specified.   */</i></td></tr>
<tr><th id="102">102</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NVENC_RECT::right" title='_NVENC_RECT::right' data-ref="_NVENC_RECT::right">right</dfn>;                                       <i class="doc">/**&lt; [in]: X coordinate of the bottom right corner of the rectangular area to be specified. */</i></td></tr>
<tr><th id="103">103</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NVENC_RECT::bottom" title='_NVENC_RECT::bottom' data-ref="_NVENC_RECT::bottom">bottom</dfn>;                                      <i class="doc">/**&lt; [in]: Y coordinate of the bottom right corner of the rectangular area to be specified. */</i></td></tr>
<tr><th id="104">104</th><td>} <dfn class="typedef" id="NVENC_RECT" title='NVENC_RECT' data-type='struct _NVENC_RECT' data-ref="NVENC_RECT">NVENC_RECT</dfn>;</td></tr>
<tr><th id="105">105</th><td></td></tr>
<tr><th id="106">106</th><td><u>#<span data-ppcond="74">endif</span> // _WIN32</u></td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><i class="doc">/** @} */</i> <i>/* End of GUID and NVENC_RECT structure grouping*/</i></td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><b>typedef</b> <em>void</em>* <dfn class="typedef" id="NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</dfn>;             <i class="doc">/**&lt; NVENCODE API input buffer                              */</i></td></tr>
<tr><th id="111">111</th><td><b>typedef</b> <em>void</em>* <dfn class="typedef" id="NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</dfn>;            <i class="doc">/**&lt; NVENCODE API output buffer*/</i></td></tr>
<tr><th id="112">112</th><td><b>typedef</b> <em>void</em>* <dfn class="typedef" id="NV_ENC_REGISTERED_PTR" title='NV_ENC_REGISTERED_PTR' data-type='void *' data-ref="NV_ENC_REGISTERED_PTR">NV_ENC_REGISTERED_PTR</dfn>;        <i class="doc">/**&lt; A Resource that has been registered with NVENCODE API*/</i></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><u>#define <dfn class="macro" id="_M/NVENCAPI_MAJOR_VERSION" data-ref="_M/NVENCAPI_MAJOR_VERSION">NVENCAPI_MAJOR_VERSION</dfn> 7</u></td></tr>
<tr><th id="115">115</th><td><u>#define <dfn class="macro" id="_M/NVENCAPI_MINOR_VERSION" data-ref="_M/NVENCAPI_MINOR_VERSION">NVENCAPI_MINOR_VERSION</dfn> 0</u></td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><u>#define <dfn class="macro" id="_M/NVENCAPI_VERSION" data-ref="_M/NVENCAPI_VERSION">NVENCAPI_VERSION</dfn> (NVENCAPI_MAJOR_VERSION | (NVENCAPI_MINOR_VERSION &lt;&lt; 24))</u></td></tr>
<tr><th id="118">118</th><td></td></tr>
<tr><th id="119">119</th><td><i class="doc">/**</i></td></tr>
<tr><th id="120">120</th><td><i class="doc"> * Macro to generate per-structure version for use with API.</i></td></tr>
<tr><th id="121">121</th><td><i class="doc"> */</i></td></tr>
<tr><th id="122">122</th><td><u>#define <dfn class="macro" id="_M/NVENCAPI_STRUCT_VERSION" data-ref="_M/NVENCAPI_STRUCT_VERSION">NVENCAPI_STRUCT_VERSION</dfn>(ver) ((uint32_t)NVENCAPI_VERSION | ((ver)&lt;&lt;16) | (0x7 &lt;&lt; 28))</u></td></tr>
<tr><th id="123">123</th><td></td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><u>#define <dfn class="macro" id="_M/NVENC_INFINITE_GOPLENGTH" data-ref="_M/NVENC_INFINITE_GOPLENGTH">NVENC_INFINITE_GOPLENGTH</dfn>  0xffffffff</u></td></tr>
<tr><th id="126">126</th><td></td></tr>
<tr><th id="127">127</th><td><u>#define <dfn class="macro" id="_M/NV_MAX_SEQ_HDR_LEN" data-ref="_M/NV_MAX_SEQ_HDR_LEN">NV_MAX_SEQ_HDR_LEN</dfn>  (512)</u></td></tr>
<tr><th id="128">128</th><td></td></tr>
<tr><th id="129">129</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="130">130</th><td><i>// Encode Codec GUIDS supported by the NvEncodeAPI interface.</i></td></tr>
<tr><th id="131">131</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="132">132</th><td><i></i></td></tr>
<tr><th id="133">133</th><td><i>// {6BC82762-4E63-4ca4-AA85-1E50F321F6BF}</i></td></tr>
<tr><th id="134">134</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_CODEC_H264_GUID" title='NV_ENC_CODEC_H264_GUID' data-ref="NV_ENC_CODEC_H264_GUID">NV_ENC_CODEC_H264_GUID</dfn> =</td></tr>
<tr><th id="135">135</th><td>{ <var>0x6bc82762</var>, <var>0x4e63</var>, <var>0x4ca4</var>, { <var>0xaa</var>, <var>0x85</var>, <var>0x1e</var>, <var>0x50</var>, <var>0xf3</var>, <var>0x21</var>, <var>0xf6</var>, <var>0xbf</var> } };</td></tr>
<tr><th id="136">136</th><td></td></tr>
<tr><th id="137">137</th><td><i>// {790CDC88-4522-4d7b-9425-BDA9975F7603}</i></td></tr>
<tr><th id="138">138</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_CODEC_HEVC_GUID" title='NV_ENC_CODEC_HEVC_GUID' data-ref="NV_ENC_CODEC_HEVC_GUID">NV_ENC_CODEC_HEVC_GUID</dfn> =</td></tr>
<tr><th id="139">139</th><td>{ <var>0x790cdc88</var>, <var>0x4522</var>, <var>0x4d7b</var>, { <var>0x94</var>, <var>0x25</var>, <var>0xbd</var>, <var>0xa9</var>, <var>0x97</var>, <var>0x5f</var>, <var>0x76</var>, <var>0x3</var> } };</td></tr>
<tr><th id="140">140</th><td></td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td></td></tr>
<tr><th id="143">143</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="144">144</th><td><i>// *   Encode Profile GUIDS supported by the NvEncodeAPI interface.</i></td></tr>
<tr><th id="145">145</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="146">146</th><td><i></i></td></tr>
<tr><th id="147">147</th><td><i>// {BFD6F8E7-233C-4341-8B3E-4818523803F4}</i></td></tr>
<tr><th id="148">148</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID" title='NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID' data-ref="NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID">NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID</dfn> =</td></tr>
<tr><th id="149">149</th><td>{ <var>0xbfd6f8e7</var>, <var>0x233c</var>, <var>0x4341</var>, { <var>0x8b</var>, <var>0x3e</var>, <var>0x48</var>, <var>0x18</var>, <var>0x52</var>, <var>0x38</var>, <var>0x3</var>, <var>0xf4</var> } };</td></tr>
<tr><th id="150">150</th><td></td></tr>
<tr><th id="151">151</th><td><i>// {0727BCAA-78C4-4c83-8C2F-EF3DFF267C6A}</i></td></tr>
<tr><th id="152">152</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>  <dfn class="decl def" id="NV_ENC_H264_PROFILE_BASELINE_GUID" title='NV_ENC_H264_PROFILE_BASELINE_GUID' data-ref="NV_ENC_H264_PROFILE_BASELINE_GUID">NV_ENC_H264_PROFILE_BASELINE_GUID</dfn> =</td></tr>
<tr><th id="153">153</th><td>{ <var>0x727bcaa</var>, <var>0x78c4</var>, <var>0x4c83</var>, { <var>0x8c</var>, <var>0x2f</var>, <var>0xef</var>, <var>0x3d</var>, <var>0xff</var>, <var>0x26</var>, <var>0x7c</var>, <var>0x6a</var> } };</td></tr>
<tr><th id="154">154</th><td></td></tr>
<tr><th id="155">155</th><td><i>// {60B5C1D4-67FE-4790-94D5-C4726D7B6E6D}</i></td></tr>
<tr><th id="156">156</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>  <dfn class="decl def" id="NV_ENC_H264_PROFILE_MAIN_GUID" title='NV_ENC_H264_PROFILE_MAIN_GUID' data-ref="NV_ENC_H264_PROFILE_MAIN_GUID">NV_ENC_H264_PROFILE_MAIN_GUID</dfn> =</td></tr>
<tr><th id="157">157</th><td>{ <var>0x60b5c1d4</var>, <var>0x67fe</var>, <var>0x4790</var>, { <var>0x94</var>, <var>0xd5</var>, <var>0xc4</var>, <var>0x72</var>, <var>0x6d</var>, <var>0x7b</var>, <var>0x6e</var>, <var>0x6d</var> } };</td></tr>
<tr><th id="158">158</th><td></td></tr>
<tr><th id="159">159</th><td><i>// {E7CBC309-4F7A-4b89-AF2A-D537C92BE310}</i></td></tr>
<tr><th id="160">160</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_H264_PROFILE_HIGH_GUID" title='NV_ENC_H264_PROFILE_HIGH_GUID' data-ref="NV_ENC_H264_PROFILE_HIGH_GUID">NV_ENC_H264_PROFILE_HIGH_GUID</dfn> =</td></tr>
<tr><th id="161">161</th><td>{ <var>0xe7cbc309</var>, <var>0x4f7a</var>, <var>0x4b89</var>, { <var>0xaf</var>, <var>0x2a</var>, <var>0xd5</var>, <var>0x37</var>, <var>0xc9</var>, <var>0x2b</var>, <var>0xe3</var>, <var>0x10</var> } };</td></tr>
<tr><th id="162">162</th><td></td></tr>
<tr><th id="163">163</th><td><i>// {7AC663CB-A598-4960-B844-339B261A7D52}</i></td></tr>
<tr><th id="164">164</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>  <dfn class="decl def" id="NV_ENC_H264_PROFILE_HIGH_444_GUID" title='NV_ENC_H264_PROFILE_HIGH_444_GUID' data-ref="NV_ENC_H264_PROFILE_HIGH_444_GUID">NV_ENC_H264_PROFILE_HIGH_444_GUID</dfn> =</td></tr>
<tr><th id="165">165</th><td>{ <var>0x7ac663cb</var>, <var>0xa598</var>, <var>0x4960</var>, { <var>0xb8</var>, <var>0x44</var>, <var>0x33</var>, <var>0x9b</var>, <var>0x26</var>, <var>0x1a</var>, <var>0x7d</var>, <var>0x52</var> } };</td></tr>
<tr><th id="166">166</th><td></td></tr>
<tr><th id="167">167</th><td><i>// {40847BF5-33F7-4601-9084-E8FE3C1DB8B7}</i></td></tr>
<tr><th id="168">168</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_H264_PROFILE_STEREO_GUID" title='NV_ENC_H264_PROFILE_STEREO_GUID' data-ref="NV_ENC_H264_PROFILE_STEREO_GUID">NV_ENC_H264_PROFILE_STEREO_GUID</dfn> =</td></tr>
<tr><th id="169">169</th><td>{ <var>0x40847bf5</var>, <var>0x33f7</var>, <var>0x4601</var>, { <var>0x90</var>, <var>0x84</var>, <var>0xe8</var>, <var>0xfe</var>, <var>0x3c</var>, <var>0x1d</var>, <var>0xb8</var>, <var>0xb7</var> } };</td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><i>// {CE788D20-AAA9-4318-92BB-AC7E858C8D36}</i></td></tr>
<tr><th id="172">172</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_H264_PROFILE_SVC_TEMPORAL_SCALABILTY" title='NV_ENC_H264_PROFILE_SVC_TEMPORAL_SCALABILTY' data-ref="NV_ENC_H264_PROFILE_SVC_TEMPORAL_SCALABILTY">NV_ENC_H264_PROFILE_SVC_TEMPORAL_SCALABILTY</dfn> =</td></tr>
<tr><th id="173">173</th><td>{ <var>0xce788d20</var>, <var>0xaaa9</var>, <var>0x4318</var>, { <var>0x92</var>, <var>0xbb</var>, <var>0xac</var>, <var>0x7e</var>, <var>0x85</var>, <var>0x8c</var>, <var>0x8d</var>, <var>0x36</var> } };</td></tr>
<tr><th id="174">174</th><td></td></tr>
<tr><th id="175">175</th><td><i>// {B405AFAC-F32B-417B-89C4-9ABEED3E5978}</i></td></tr>
<tr><th id="176">176</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID" title='NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID' data-ref="NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID">NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID</dfn> =</td></tr>
<tr><th id="177">177</th><td>{ <var>0xb405afac</var>, <var>0xf32b</var>, <var>0x417b</var>, { <var>0x89</var>, <var>0xc4</var>, <var>0x9a</var>, <var>0xbe</var>, <var>0xed</var>, <var>0x3e</var>, <var>0x59</var>, <var>0x78</var> } };</td></tr>
<tr><th id="178">178</th><td></td></tr>
<tr><th id="179">179</th><td><i>// {AEC1BD87-E85B-48f2-84C3-98BCA6285072}</i></td></tr>
<tr><th id="180">180</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID" title='NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID' data-ref="NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID">NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID</dfn> =</td></tr>
<tr><th id="181">181</th><td>{ <var>0xaec1bd87</var>, <var>0xe85b</var>, <var>0x48f2</var>, { <var>0x84</var>, <var>0xc3</var>, <var>0x98</var>, <var>0xbc</var>, <var>0xa6</var>, <var>0x28</var>, <var>0x50</var>, <var>0x72</var> } };</td></tr>
<tr><th id="182">182</th><td></td></tr>
<tr><th id="183">183</th><td><i>// {B514C39A-B55B-40fa-878F-F1253B4DFDEC}</i></td></tr>
<tr><th id="184">184</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_HEVC_PROFILE_MAIN_GUID" title='NV_ENC_HEVC_PROFILE_MAIN_GUID' data-ref="NV_ENC_HEVC_PROFILE_MAIN_GUID">NV_ENC_HEVC_PROFILE_MAIN_GUID</dfn> =</td></tr>
<tr><th id="185">185</th><td>{ <var>0xb514c39a</var>, <var>0xb55b</var>, <var>0x40fa</var>, { <var>0x87</var>, <var>0x8f</var>, <var>0xf1</var>, <var>0x25</var>, <var>0x3b</var>, <var>0x4d</var>, <var>0xfd</var>, <var>0xec</var> } };</td></tr>
<tr><th id="186">186</th><td></td></tr>
<tr><th id="187">187</th><td><i>// {fa4d2b6c-3a5b-411a-8018-0a3f5e3c9be5}</i></td></tr>
<tr><th id="188">188</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_HEVC_PROFILE_MAIN10_GUID" title='NV_ENC_HEVC_PROFILE_MAIN10_GUID' data-ref="NV_ENC_HEVC_PROFILE_MAIN10_GUID">NV_ENC_HEVC_PROFILE_MAIN10_GUID</dfn> =</td></tr>
<tr><th id="189">189</th><td>{ <var>0xfa4d2b6c</var>, <var>0x3a5b</var>, <var>0x411a</var>, { <var>0x80</var>, <var>0x18</var>, <var>0x0a</var>, <var>0x3f</var>, <var>0x5e</var>, <var>0x3c</var>, <var>0x9b</var>, <var>0xe5</var> } };</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><i>// For HEVC Main 444 8 bit and HEVC Main 444 10 bit profiles only</i></td></tr>
<tr><th id="192">192</th><td><i>// {51ec32b5-1b4c-453c-9cbd-b616bd621341}</i></td></tr>
<tr><th id="193">193</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_HEVC_PROFILE_FREXT_GUID" title='NV_ENC_HEVC_PROFILE_FREXT_GUID' data-ref="NV_ENC_HEVC_PROFILE_FREXT_GUID">NV_ENC_HEVC_PROFILE_FREXT_GUID</dfn> =</td></tr>
<tr><th id="194">194</th><td>{ <var>0x51ec32b5</var>, <var>0x1b4c</var>, <var>0x453c</var>, { <var>0x9c</var>, <var>0xbd</var>, <var>0xb6</var>, <var>0x16</var>, <var>0xbd</var>, <var>0x62</var>, <var>0x13</var>, <var>0x41</var> } };</td></tr>
<tr><th id="195">195</th><td></td></tr>
<tr><th id="196">196</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="197">197</th><td><i>// *   Preset GUIDS supported by the NvEncodeAPI interface.</i></td></tr>
<tr><th id="198">198</th><td><i>// =========================================================================================</i></td></tr>
<tr><th id="199">199</th><td><i>// {B2DFB705-4EBD-4C49-9B5F-24A777D3E587}</i></td></tr>
<tr><th id="200">200</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_DEFAULT_GUID" title='NV_ENC_PRESET_DEFAULT_GUID' data-ref="NV_ENC_PRESET_DEFAULT_GUID">NV_ENC_PRESET_DEFAULT_GUID</dfn> =</td></tr>
<tr><th id="201">201</th><td>{ <var>0xb2dfb705</var>, <var>0x4ebd</var>, <var>0x4c49</var>, { <var>0x9b</var>, <var>0x5f</var>, <var>0x24</var>, <var>0xa7</var>, <var>0x77</var>, <var>0xd3</var>, <var>0xe5</var>, <var>0x87</var> } };</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td><i>// {60E4C59F-E846-4484-A56D-CD45BE9FDDF6}</i></td></tr>
<tr><th id="204">204</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_HP_GUID" title='NV_ENC_PRESET_HP_GUID' data-ref="NV_ENC_PRESET_HP_GUID">NV_ENC_PRESET_HP_GUID</dfn> =</td></tr>
<tr><th id="205">205</th><td>{ <var>0x60e4c59f</var>, <var>0xe846</var>, <var>0x4484</var>, { <var>0xa5</var>, <var>0x6d</var>, <var>0xcd</var>, <var>0x45</var>, <var>0xbe</var>, <var>0x9f</var>, <var>0xdd</var>, <var>0xf6</var> } };</td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><i>// {34DBA71D-A77B-4B8F-9C3E-B6D5DA24C012}</i></td></tr>
<tr><th id="208">208</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_HQ_GUID" title='NV_ENC_PRESET_HQ_GUID' data-ref="NV_ENC_PRESET_HQ_GUID">NV_ENC_PRESET_HQ_GUID</dfn> =</td></tr>
<tr><th id="209">209</th><td>{ <var>0x34dba71d</var>, <var>0xa77b</var>, <var>0x4b8f</var>, { <var>0x9c</var>, <var>0x3e</var>, <var>0xb6</var>, <var>0xd5</var>, <var>0xda</var>, <var>0x24</var>, <var>0xc0</var>, <var>0x12</var> } };</td></tr>
<tr><th id="210">210</th><td></td></tr>
<tr><th id="211">211</th><td><i>// {82E3E450-BDBB-4e40-989C-82A90DF9EF32}</i></td></tr>
<tr><th id="212">212</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_BD_GUID" title='NV_ENC_PRESET_BD_GUID' data-ref="NV_ENC_PRESET_BD_GUID">NV_ENC_PRESET_BD_GUID</dfn>  =</td></tr>
<tr><th id="213">213</th><td>{ <var>0x82e3e450</var>, <var>0xbdbb</var>, <var>0x4e40</var>, { <var>0x98</var>, <var>0x9c</var>, <var>0x82</var>, <var>0xa9</var>, <var>0xd</var>, <var>0xf9</var>, <var>0xef</var>, <var>0x32</var> } };</td></tr>
<tr><th id="214">214</th><td></td></tr>
<tr><th id="215">215</th><td><i>// {49DF21C5-6DFA-4feb-9787-6ACC9EFFB726}</i></td></tr>
<tr><th id="216">216</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID" title='NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID' data-ref="NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID">NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID</dfn>  =</td></tr>
<tr><th id="217">217</th><td>{ <var>0x49df21c5</var>, <var>0x6dfa</var>, <var>0x4feb</var>, { <var>0x97</var>, <var>0x87</var>, <var>0x6a</var>, <var>0xcc</var>, <var>0x9e</var>, <var>0xff</var>, <var>0xb7</var>, <var>0x26</var> } };</td></tr>
<tr><th id="218">218</th><td></td></tr>
<tr><th id="219">219</th><td><i>// {C5F733B9-EA97-4cf9-BEC2-BF78A74FD105}</i></td></tr>
<tr><th id="220">220</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_LOW_LATENCY_HQ_GUID" title='NV_ENC_PRESET_LOW_LATENCY_HQ_GUID' data-ref="NV_ENC_PRESET_LOW_LATENCY_HQ_GUID">NV_ENC_PRESET_LOW_LATENCY_HQ_GUID</dfn>  =</td></tr>
<tr><th id="221">221</th><td>{ <var>0xc5f733b9</var>, <var>0xea97</var>, <var>0x4cf9</var>, { <var>0xbe</var>, <var>0xc2</var>, <var>0xbf</var>, <var>0x78</var>, <var>0xa7</var>, <var>0x4f</var>, <var>0xd1</var>, <var>0x5</var> } };</td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td><i>// {67082A44-4BAD-48FA-98EA-93056D150A58}</i></td></tr>
<tr><th id="224">224</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_LOW_LATENCY_HP_GUID" title='NV_ENC_PRESET_LOW_LATENCY_HP_GUID' data-ref="NV_ENC_PRESET_LOW_LATENCY_HP_GUID">NV_ENC_PRESET_LOW_LATENCY_HP_GUID</dfn> =</td></tr>
<tr><th id="225">225</th><td>{ <var>0x67082a44</var>, <var>0x4bad</var>, <var>0x48fa</var>, { <var>0x98</var>, <var>0xea</var>, <var>0x93</var>, <var>0x5</var>, <var>0x6d</var>, <var>0x15</var>, <var>0xa</var>, <var>0x58</var> } };</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td><i>// {D5BFB716-C604-44e7-9BB8-DEA5510FC3AC}</i></td></tr>
<tr><th id="228">228</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID" title='NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID' data-ref="NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID">NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID</dfn> =</td></tr>
<tr><th id="229">229</th><td>{ <var>0xd5bfb716</var>, <var>0xc604</var>, <var>0x44e7</var>, { <var>0x9b</var>, <var>0xb8</var>, <var>0xde</var>, <var>0xa5</var>, <var>0x51</var>, <var>0xf</var>, <var>0xc3</var>, <var>0xac</var> } };</td></tr>
<tr><th id="230">230</th><td></td></tr>
<tr><th id="231">231</th><td><i>// {149998E7-2364-411d-82EF-179888093409}</i></td></tr>
<tr><th id="232">232</th><td><em>static</em> <em>const</em> <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="decl def" id="NV_ENC_PRESET_LOSSLESS_HP_GUID" title='NV_ENC_PRESET_LOSSLESS_HP_GUID' data-ref="NV_ENC_PRESET_LOSSLESS_HP_GUID">NV_ENC_PRESET_LOSSLESS_HP_GUID</dfn> =</td></tr>
<tr><th id="233">233</th><td>{ <var>0x149998e7</var>, <var>0x2364</var>, <var>0x411d</var>, { <var>0x82</var>, <var>0xef</var>, <var>0x17</var>, <var>0x98</var>, <var>0x88</var>, <var>0x9</var>, <var>0x34</var>, <var>0x9</var> } };</td></tr>
<tr><th id="234">234</th><td></td></tr>
<tr><th id="235">235</th><td><i class="doc">/**</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> * <span class="command">\addtogroup</span> <span class="verb">ENCODER_STRUCTURE NvEncodeAPI Data structures</span></i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> * @{</i></td></tr>
<tr><th id="238">238</th><td><i class="doc"> */</i></td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td><i class="doc">/**</i></td></tr>
<tr><th id="241">241</th><td><i class="doc"> * Input frame encode modes</i></td></tr>
<tr><th id="242">242</th><td><i class="doc"> */</i></td></tr>
<tr><th id="243">243</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_PARAMS_FRAME_FIELD_MODE" title='_NV_ENC_PARAMS_FRAME_FIELD_MODE' data-ref="_NV_ENC_PARAMS_FRAME_FIELD_MODE"><a class="type" href="#_NV_ENC_PARAMS_FRAME_FIELD_MODE" title='_NV_ENC_PARAMS_FRAME_FIELD_MODE' data-ref="_NV_ENC_PARAMS_FRAME_FIELD_MODE">_NV_ENC_PARAMS_FRAME_FIELD_MODE</a></dfn></td></tr>
<tr><th id="244">244</th><td>{</td></tr>
<tr><th id="245">245</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME" title='_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME' data-ref="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME">NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME</dfn> = <var>0x01</var>,  <i class="doc">/**&lt; Frame mode */</i></td></tr>
<tr><th id="246">246</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD" title='_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD' data-ref="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD">NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD</dfn> = <var>0x02</var>,  <i class="doc">/**&lt; Field mode */</i></td></tr>
<tr><th id="247">247</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF" title='_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF' data-ref="_NV_ENC_PARAMS_FRAME_FIELD_MODE::NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF">NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF</dfn> = <var>0x03</var>   <i class="doc">/**&lt; MB adaptive frame/field */</i></td></tr>
<tr><th id="248">248</th><td>} <dfn class="typedef" id="NV_ENC_PARAMS_FRAME_FIELD_MODE" title='NV_ENC_PARAMS_FRAME_FIELD_MODE' data-type='enum _NV_ENC_PARAMS_FRAME_FIELD_MODE' data-ref="NV_ENC_PARAMS_FRAME_FIELD_MODE">NV_ENC_PARAMS_FRAME_FIELD_MODE</dfn>;</td></tr>
<tr><th id="249">249</th><td></td></tr>
<tr><th id="250">250</th><td><i class="doc">/**</i></td></tr>
<tr><th id="251">251</th><td><i class="doc"> * Rate Control Modes</i></td></tr>
<tr><th id="252">252</th><td><i class="doc"> */</i></td></tr>
<tr><th id="253">253</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_PARAMS_RC_MODE" title='_NV_ENC_PARAMS_RC_MODE' data-ref="_NV_ENC_PARAMS_RC_MODE"><a class="type" href="#_NV_ENC_PARAMS_RC_MODE" title='_NV_ENC_PARAMS_RC_MODE' data-ref="_NV_ENC_PARAMS_RC_MODE">_NV_ENC_PARAMS_RC_MODE</a></dfn></td></tr>
<tr><th id="254">254</th><td>{</td></tr>
<tr><th id="255">255</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CONSTQP" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CONSTQP' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CONSTQP">NV_ENC_PARAMS_RC_CONSTQP</dfn>                = <var>0x0</var>,       <i class="doc">/**&lt; Constant QP mode */</i></td></tr>
<tr><th id="256">256</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR">NV_ENC_PARAMS_RC_VBR</dfn>                    = <var>0x1</var>,       <i class="doc">/**&lt; Variable bitrate mode */</i></td></tr>
<tr><th id="257">257</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CBR" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CBR' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_CBR">NV_ENC_PARAMS_RC_CBR</dfn>                    = <var>0x2</var>,       <i class="doc">/**&lt; Constant bitrate mode */</i></td></tr>
<tr><th id="258">258</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR_MINQP" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR_MINQP' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_VBR_MINQP">NV_ENC_PARAMS_RC_VBR_MINQP</dfn>              = <var>0x4</var>,       <i class="doc">/**&lt; Variable bitrate mode with MinQP */</i></td></tr>
<tr><th id="259">259</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_QUALITY" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_QUALITY' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_QUALITY">NV_ENC_PARAMS_RC_2_PASS_QUALITY</dfn>         = <var>0x8</var>,       <i class="doc">/**&lt; Multi pass encoding optimized for image quality and works only with low latency mode */</i></td></tr>
<tr><th id="260">260</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP">NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP</dfn>   = <var>0x10</var>,      <i class="doc">/**&lt; Multi pass encoding optimized for maintaining frame size and works only with low latency mode */</i></td></tr>
<tr><th id="261">261</th><td>    <dfn class="enum" id="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_VBR" title='_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_VBR' data-ref="_NV_ENC_PARAMS_RC_MODE::NV_ENC_PARAMS_RC_2_PASS_VBR">NV_ENC_PARAMS_RC_2_PASS_VBR</dfn>             = <var>0x20</var>       <i class="doc">/**&lt; Multi pass VBR */</i></td></tr>
<tr><th id="262">262</th><td>} <dfn class="typedef" id="NV_ENC_PARAMS_RC_MODE" title='NV_ENC_PARAMS_RC_MODE' data-type='enum _NV_ENC_PARAMS_RC_MODE' data-ref="NV_ENC_PARAMS_RC_MODE">NV_ENC_PARAMS_RC_MODE</dfn>;</td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_PARAMS_RC_CBR2" data-ref="_M/NV_ENC_PARAMS_RC_CBR2">NV_ENC_PARAMS_RC_CBR2</dfn>   NV_ENC_PARAMS_RC_CBR    /**&lt; Deprecated */</u></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><i class="doc">/**</i></td></tr>
<tr><th id="267">267</th><td><i class="doc"> * Input picture structure</i></td></tr>
<tr><th id="268">268</th><td><i class="doc"> */</i></td></tr>
<tr><th id="269">269</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_PIC_STRUCT" title='_NV_ENC_PIC_STRUCT' data-ref="_NV_ENC_PIC_STRUCT"><a class="type" href="#_NV_ENC_PIC_STRUCT" title='_NV_ENC_PIC_STRUCT' data-ref="_NV_ENC_PIC_STRUCT">_NV_ENC_PIC_STRUCT</a></dfn></td></tr>
<tr><th id="270">270</th><td>{</td></tr>
<tr><th id="271">271</th><td>    <dfn class="enum" id="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FRAME" title='_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FRAME' data-ref="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FRAME">NV_ENC_PIC_STRUCT_FRAME</dfn>             = <var>0x01</var>,                 <i class="doc">/**&lt; Progressive frame */</i></td></tr>
<tr><th id="272">272</th><td>    <dfn class="enum" id="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM" title='_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM' data-ref="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM">NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM</dfn>  = <var>0x02</var>,                 <i class="doc">/**&lt; Field encoding top field first */</i></td></tr>
<tr><th id="273">273</th><td>    <dfn class="enum" id="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP" title='_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP' data-ref="_NV_ENC_PIC_STRUCT::NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP">NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP</dfn>  = <var>0x03</var>                  <i class="doc">/**&lt; Field encoding bottom field first */</i></td></tr>
<tr><th id="274">274</th><td>} <dfn class="typedef" id="NV_ENC_PIC_STRUCT" title='NV_ENC_PIC_STRUCT' data-type='enum _NV_ENC_PIC_STRUCT' data-ref="NV_ENC_PIC_STRUCT">NV_ENC_PIC_STRUCT</dfn>;</td></tr>
<tr><th id="275">275</th><td></td></tr>
<tr><th id="276">276</th><td><i class="doc">/**</i></td></tr>
<tr><th id="277">277</th><td><i class="doc"> * Input picture type</i></td></tr>
<tr><th id="278">278</th><td><i class="doc"> */</i></td></tr>
<tr><th id="279">279</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_PIC_TYPE" title='_NV_ENC_PIC_TYPE' data-ref="_NV_ENC_PIC_TYPE"><a class="type" href="#_NV_ENC_PIC_TYPE" title='_NV_ENC_PIC_TYPE' data-ref="_NV_ENC_PIC_TYPE">_NV_ENC_PIC_TYPE</a></dfn></td></tr>
<tr><th id="280">280</th><td>{</td></tr>
<tr><th id="281">281</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_P" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_P' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_P">NV_ENC_PIC_TYPE_P</dfn>               = <var>0x0</var>,     <i class="doc">/**&lt; Forward predicted */</i></td></tr>
<tr><th id="282">282</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_B" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_B' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_B">NV_ENC_PIC_TYPE_B</dfn>               = <var>0x01</var>,    <i class="doc">/**&lt; Bi-directionally predicted picture */</i></td></tr>
<tr><th id="283">283</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_I" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_I' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_I">NV_ENC_PIC_TYPE_I</dfn>               = <var>0x02</var>,    <i class="doc">/**&lt; Intra predicted picture */</i></td></tr>
<tr><th id="284">284</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_IDR" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_IDR' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_IDR">NV_ENC_PIC_TYPE_IDR</dfn>             = <var>0x03</var>,    <i class="doc">/**&lt; IDR picture */</i></td></tr>
<tr><th id="285">285</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_BI" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_BI' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_BI">NV_ENC_PIC_TYPE_BI</dfn>              = <var>0x04</var>,    <i class="doc">/**&lt; Bi-directionally predicted with only Intra MBs */</i></td></tr>
<tr><th id="286">286</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_SKIPPED" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_SKIPPED' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_SKIPPED">NV_ENC_PIC_TYPE_SKIPPED</dfn>         = <var>0x05</var>,    <i class="doc">/**&lt; Picture is skipped */</i></td></tr>
<tr><th id="287">287</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_INTRA_REFRESH" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_INTRA_REFRESH' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_INTRA_REFRESH">NV_ENC_PIC_TYPE_INTRA_REFRESH</dfn>   = <var>0x06</var>,    <i class="doc">/**&lt; First picture in intra refresh cycle */</i></td></tr>
<tr><th id="288">288</th><td>    <dfn class="enum" id="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_UNKNOWN" title='_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_UNKNOWN' data-ref="_NV_ENC_PIC_TYPE::NV_ENC_PIC_TYPE_UNKNOWN">NV_ENC_PIC_TYPE_UNKNOWN</dfn>         = <var>0xFF</var>     <i class="doc">/**&lt; Picture type unknown */</i></td></tr>
<tr><th id="289">289</th><td>} <dfn class="typedef" id="NV_ENC_PIC_TYPE" title='NV_ENC_PIC_TYPE' data-type='enum _NV_ENC_PIC_TYPE' data-ref="NV_ENC_PIC_TYPE">NV_ENC_PIC_TYPE</dfn>;</td></tr>
<tr><th id="290">290</th><td></td></tr>
<tr><th id="291">291</th><td><i class="doc">/**</i></td></tr>
<tr><th id="292">292</th><td><i class="doc"> * Motion vector precisions</i></td></tr>
<tr><th id="293">293</th><td><i class="doc"> */</i></td></tr>
<tr><th id="294">294</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_MV_PRECISION" title='_NV_ENC_MV_PRECISION' data-ref="_NV_ENC_MV_PRECISION"><a class="type" href="#_NV_ENC_MV_PRECISION" title='_NV_ENC_MV_PRECISION' data-ref="_NV_ENC_MV_PRECISION">_NV_ENC_MV_PRECISION</a></dfn></td></tr>
<tr><th id="295">295</th><td>{</td></tr>
<tr><th id="296">296</th><td>    <dfn class="enum" id="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_DEFAULT" title='_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_DEFAULT' data-ref="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_DEFAULT">NV_ENC_MV_PRECISION_DEFAULT</dfn>     = <var>0x0</var>,       <i class="doc">/**&lt;Driver selects QuarterPel motion vector precision by default*/</i></td></tr>
<tr><th id="297">297</th><td>    <dfn class="enum" id="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_FULL_PEL" title='_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_FULL_PEL' data-ref="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_FULL_PEL">NV_ENC_MV_PRECISION_FULL_PEL</dfn>    = <var>0x01</var>,    <i class="doc">/**&lt; FullPel  motion vector precision */</i></td></tr>
<tr><th id="298">298</th><td>    <dfn class="enum" id="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_HALF_PEL" title='_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_HALF_PEL' data-ref="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_HALF_PEL">NV_ENC_MV_PRECISION_HALF_PEL</dfn>    = <var>0x02</var>,    <i class="doc">/**&lt; HalfPel motion vector precision */</i></td></tr>
<tr><th id="299">299</th><td>    <dfn class="enum" id="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_QUARTER_PEL" title='_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_QUARTER_PEL' data-ref="_NV_ENC_MV_PRECISION::NV_ENC_MV_PRECISION_QUARTER_PEL">NV_ENC_MV_PRECISION_QUARTER_PEL</dfn> = <var>0x03</var>     <i class="doc">/**&lt; QuarterPel motion vector precision */</i></td></tr>
<tr><th id="300">300</th><td>} <dfn class="typedef" id="NV_ENC_MV_PRECISION" title='NV_ENC_MV_PRECISION' data-type='enum _NV_ENC_MV_PRECISION' data-ref="NV_ENC_MV_PRECISION">NV_ENC_MV_PRECISION</dfn>;</td></tr>
<tr><th id="301">301</th><td></td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><i class="doc">/**</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> * Input buffer formats</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> */</i></td></tr>
<tr><th id="306">306</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_BUFFER_FORMAT" title='_NV_ENC_BUFFER_FORMAT' data-ref="_NV_ENC_BUFFER_FORMAT"><a class="type" href="#_NV_ENC_BUFFER_FORMAT" title='_NV_ENC_BUFFER_FORMAT' data-ref="_NV_ENC_BUFFER_FORMAT">_NV_ENC_BUFFER_FORMAT</a></dfn></td></tr>
<tr><th id="307">307</th><td>{</td></tr>
<tr><th id="308">308</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_UNDEFINED" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_UNDEFINED' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_UNDEFINED">NV_ENC_BUFFER_FORMAT_UNDEFINED</dfn>                       = <var>0x00000000</var>,  <i class="doc">/**&lt; Undefined buffer format */</i></td></tr>
<tr><th id="309">309</th><td></td></tr>
<tr><th id="310">310</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_NV12" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_NV12' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_NV12">NV_ENC_BUFFER_FORMAT_NV12</dfn>                            = <var>0x00000001</var>,  <i class="doc">/**&lt; Semi-Planar YUV [Y plane followed by interleaved UV plane] */</i></td></tr>
<tr><th id="311">311</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YV12" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YV12' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YV12">NV_ENC_BUFFER_FORMAT_YV12</dfn>                            = <var>0x00000010</var>,  <i class="doc">/**&lt; Planar YUV [Y plane followed by V and U planes] */</i></td></tr>
<tr><th id="312">312</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_IYUV" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_IYUV' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_IYUV">NV_ENC_BUFFER_FORMAT_IYUV</dfn>                            = <var>0x00000100</var>,  <i class="doc">/**&lt; Planar YUV [Y plane followed by U and V planes] */</i></td></tr>
<tr><th id="313">313</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444">NV_ENC_BUFFER_FORMAT_YUV444</dfn>                          = <var>0x00001000</var>,  <i class="doc">/**&lt; Planar YUV [Y plane followed by U and V planes] */</i></td></tr>
<tr><th id="314">314</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV420_10BIT" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV420_10BIT' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV420_10BIT">NV_ENC_BUFFER_FORMAT_YUV420_10BIT</dfn>                    = <var>0x00010000</var>,  <i class="doc">/**&lt; 10 bit Semi-Planar YUV [Y plane followed by interleaved UV plane]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data. */</i></td></tr>
<tr><th id="315">315</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444_10BIT" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444_10BIT' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_YUV444_10BIT">NV_ENC_BUFFER_FORMAT_YUV444_10BIT</dfn>                    = <var>0x00100000</var>,  <i class="doc">/**&lt; 10 bit Planar YUV444 [Y plane followed by U and V planes]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data.  */</i></td></tr>
<tr><th id="316">316</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB">NV_ENC_BUFFER_FORMAT_ARGB</dfn>                            = <var>0x01000000</var>,  <i class="doc">/**&lt; 8 bit Packed A8R8G8B8 */</i></td></tr>
<tr><th id="317">317</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB10" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB10' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ARGB10">NV_ENC_BUFFER_FORMAT_ARGB10</dfn>                          = <var>0x02000000</var>,  <i class="doc">/**&lt; 10 bit Packed A2R10G10B10. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data.  */</i></td></tr>
<tr><th id="318">318</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_AYUV" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_AYUV' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_AYUV">NV_ENC_BUFFER_FORMAT_AYUV</dfn>                            = <var>0x04000000</var>,  <i class="doc">/**&lt; 8 bit Packed A8Y8U8V8 */</i></td></tr>
<tr><th id="319">319</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR">NV_ENC_BUFFER_FORMAT_ABGR</dfn>                            = <var>0x10000000</var>,  <i class="doc">/**&lt; 8 bit Packed A8B8G8R8 */</i></td></tr>
<tr><th id="320">320</th><td>    <dfn class="enum" id="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR10" title='_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR10' data-ref="_NV_ENC_BUFFER_FORMAT::NV_ENC_BUFFER_FORMAT_ABGR10">NV_ENC_BUFFER_FORMAT_ABGR10</dfn>                          = <var>0x20000000</var>,  <i class="doc">/**&lt; 10 bit Packed A2B10G10R10. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data.  */</i></td></tr>
<tr><th id="321">321</th><td>} <dfn class="typedef" id="NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</dfn>;</td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_BUFFER_FORMAT_NV12_PL" data-ref="_M/NV_ENC_BUFFER_FORMAT_NV12_PL">NV_ENC_BUFFER_FORMAT_NV12_PL</dfn> NV_ENC_BUFFER_FORMAT_NV12</u></td></tr>
<tr><th id="324">324</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_BUFFER_FORMAT_YV12_PL" data-ref="_M/NV_ENC_BUFFER_FORMAT_YV12_PL">NV_ENC_BUFFER_FORMAT_YV12_PL</dfn> NV_ENC_BUFFER_FORMAT_YV12</u></td></tr>
<tr><th id="325">325</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_BUFFER_FORMAT_IYUV_PL" data-ref="_M/NV_ENC_BUFFER_FORMAT_IYUV_PL">NV_ENC_BUFFER_FORMAT_IYUV_PL</dfn> NV_ENC_BUFFER_FORMAT_IYUV</u></td></tr>
<tr><th id="326">326</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_BUFFER_FORMAT_YUV444_PL" data-ref="_M/NV_ENC_BUFFER_FORMAT_YUV444_PL">NV_ENC_BUFFER_FORMAT_YUV444_PL</dfn> NV_ENC_BUFFER_FORMAT_YUV444</u></td></tr>
<tr><th id="327">327</th><td></td></tr>
<tr><th id="328">328</th><td><i class="doc">/**</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> * Encoding levels</i></td></tr>
<tr><th id="330">330</th><td><i class="doc"> */</i></td></tr>
<tr><th id="331">331</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_LEVEL" title='_NV_ENC_LEVEL' data-ref="_NV_ENC_LEVEL"><a class="type" href="#_NV_ENC_LEVEL" title='_NV_ENC_LEVEL' data-ref="_NV_ENC_LEVEL">_NV_ENC_LEVEL</a></dfn></td></tr>
<tr><th id="332">332</th><td>{</td></tr>
<tr><th id="333">333</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT">NV_ENC_LEVEL_AUTOSELECT</dfn>         = <var>0</var>,</td></tr>
<tr><th id="334">334</th><td></td></tr>
<tr><th id="335">335</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1">NV_ENC_LEVEL_H264_1</dfn>             = <var>10</var>,</td></tr>
<tr><th id="336">336</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b">NV_ENC_LEVEL_H264_1b</dfn>            = <var>9</var>,</td></tr>
<tr><th id="337">337</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11">NV_ENC_LEVEL_H264_11</dfn>            = <var>11</var>,</td></tr>
<tr><th id="338">338</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12">NV_ENC_LEVEL_H264_12</dfn>            = <var>12</var>,</td></tr>
<tr><th id="339">339</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13">NV_ENC_LEVEL_H264_13</dfn>            = <var>13</var>,</td></tr>
<tr><th id="340">340</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2">NV_ENC_LEVEL_H264_2</dfn>             = <var>20</var>,</td></tr>
<tr><th id="341">341</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21">NV_ENC_LEVEL_H264_21</dfn>            = <var>21</var>,</td></tr>
<tr><th id="342">342</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22">NV_ENC_LEVEL_H264_22</dfn>            = <var>22</var>,</td></tr>
<tr><th id="343">343</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3">NV_ENC_LEVEL_H264_3</dfn>             = <var>30</var>,</td></tr>
<tr><th id="344">344</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_31" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_31' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_31">NV_ENC_LEVEL_H264_31</dfn>            = <var>31</var>,</td></tr>
<tr><th id="345">345</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_32" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_32' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_32">NV_ENC_LEVEL_H264_32</dfn>            = <var>32</var>,</td></tr>
<tr><th id="346">346</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_4" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_4' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_4">NV_ENC_LEVEL_H264_4</dfn>             = <var>40</var>,</td></tr>
<tr><th id="347">347</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_41" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_41' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_41">NV_ENC_LEVEL_H264_41</dfn>            = <var>41</var>,</td></tr>
<tr><th id="348">348</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_42" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_42' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_42">NV_ENC_LEVEL_H264_42</dfn>            = <var>42</var>,</td></tr>
<tr><th id="349">349</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_5" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_5' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_5">NV_ENC_LEVEL_H264_5</dfn>             = <var>50</var>,</td></tr>
<tr><th id="350">350</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_51" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_51' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_51">NV_ENC_LEVEL_H264_51</dfn>            = <var>51</var>,</td></tr>
<tr><th id="351">351</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_52" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_52' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_H264_52">NV_ENC_LEVEL_H264_52</dfn>            = <var>52</var>,</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td></td></tr>
<tr><th id="354">354</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_1" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_1' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_1">NV_ENC_LEVEL_HEVC_1</dfn>             = <var>30</var>,</td></tr>
<tr><th id="355">355</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_2" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_2' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_2">NV_ENC_LEVEL_HEVC_2</dfn>             = <var>60</var>,</td></tr>
<tr><th id="356">356</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_21" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_21' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_21">NV_ENC_LEVEL_HEVC_21</dfn>            = <var>63</var>,</td></tr>
<tr><th id="357">357</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_3" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_3' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_3">NV_ENC_LEVEL_HEVC_3</dfn>             = <var>90</var>,</td></tr>
<tr><th id="358">358</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_31" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_31' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_31">NV_ENC_LEVEL_HEVC_31</dfn>            = <var>93</var>,</td></tr>
<tr><th id="359">359</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_4" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_4' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_4">NV_ENC_LEVEL_HEVC_4</dfn>             = <var>120</var>,</td></tr>
<tr><th id="360">360</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_41" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_41' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_41">NV_ENC_LEVEL_HEVC_41</dfn>            = <var>123</var>,</td></tr>
<tr><th id="361">361</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_5" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_5' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_5">NV_ENC_LEVEL_HEVC_5</dfn>             = <var>150</var>,</td></tr>
<tr><th id="362">362</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_51" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_51' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_51">NV_ENC_LEVEL_HEVC_51</dfn>            = <var>153</var>,</td></tr>
<tr><th id="363">363</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_52" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_52' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_52">NV_ENC_LEVEL_HEVC_52</dfn>            = <var>156</var>,</td></tr>
<tr><th id="364">364</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_6" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_6' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_6">NV_ENC_LEVEL_HEVC_6</dfn>             = <var>180</var>,</td></tr>
<tr><th id="365">365</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_61" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_61' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_61">NV_ENC_LEVEL_HEVC_61</dfn>            = <var>183</var>,</td></tr>
<tr><th id="366">366</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_62" title='_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_62' data-ref="_NV_ENC_LEVEL::NV_ENC_LEVEL_HEVC_62">NV_ENC_LEVEL_HEVC_62</dfn>            = <var>186</var>,</td></tr>
<tr><th id="367">367</th><td></td></tr>
<tr><th id="368">368</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_MAIN" title='_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_MAIN' data-ref="_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_MAIN">NV_ENC_TIER_HEVC_MAIN</dfn>           = <var>0</var>,</td></tr>
<tr><th id="369">369</th><td>    <dfn class="enum" id="_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH" title='_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH' data-ref="_NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH">NV_ENC_TIER_HEVC_HIGH</dfn>           = <var>1</var></td></tr>
<tr><th id="370">370</th><td>} <dfn class="typedef" id="NV_ENC_LEVEL" title='NV_ENC_LEVEL' data-type='enum _NV_ENC_LEVEL' data-ref="NV_ENC_LEVEL">NV_ENC_LEVEL</dfn>;</td></tr>
<tr><th id="371">371</th><td></td></tr>
<tr><th id="372">372</th><td><i class="doc">/**</i></td></tr>
<tr><th id="373">373</th><td><i class="doc"> * Error Codes</i></td></tr>
<tr><th id="374">374</th><td><i class="doc"> */</i></td></tr>
<tr><th id="375">375</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NVENCSTATUS" title='_NVENCSTATUS' data-ref="_NVENCSTATUS"><a class="type" href="#_NVENCSTATUS" title='_NVENCSTATUS' data-ref="_NVENCSTATUS">_NVENCSTATUS</a></dfn></td></tr>
<tr><th id="376">376</th><td>{</td></tr>
<tr><th id="377">377</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="378">378</th><td><i class="doc">     * This indicates that API call returned with no errors.</i></td></tr>
<tr><th id="379">379</th><td><i class="doc">     */</i></td></tr>
<tr><th id="380">380</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_SUCCESS" title='_NVENCSTATUS::NV_ENC_SUCCESS' data-ref="_NVENCSTATUS::NV_ENC_SUCCESS">NV_ENC_SUCCESS</dfn>,</td></tr>
<tr><th id="381">381</th><td></td></tr>
<tr><th id="382">382</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="383">383</th><td><i class="doc">     * This indicates that no encode capable devices were detected.</i></td></tr>
<tr><th id="384">384</th><td><i class="doc">     */</i></td></tr>
<tr><th id="385">385</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_NO_ENCODE_DEVICE" title='_NVENCSTATUS::NV_ENC_ERR_NO_ENCODE_DEVICE' data-ref="_NVENCSTATUS::NV_ENC_ERR_NO_ENCODE_DEVICE">NV_ENC_ERR_NO_ENCODE_DEVICE</dfn>,</td></tr>
<tr><th id="386">386</th><td></td></tr>
<tr><th id="387">387</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="388">388</th><td><i class="doc">     * This indicates that devices pass by the client is not supported.</i></td></tr>
<tr><th id="389">389</th><td><i class="doc">     */</i></td></tr>
<tr><th id="390">390</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_DEVICE" title='_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_DEVICE' data-ref="_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_DEVICE">NV_ENC_ERR_UNSUPPORTED_DEVICE</dfn>,</td></tr>
<tr><th id="391">391</th><td></td></tr>
<tr><th id="392">392</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="393">393</th><td><i class="doc">     * This indicates that the encoder device supplied by the client is not</i></td></tr>
<tr><th id="394">394</th><td><i class="doc">     * valid.</i></td></tr>
<tr><th id="395">395</th><td><i class="doc">     */</i></td></tr>
<tr><th id="396">396</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_ENCODERDEVICE" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_ENCODERDEVICE' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_ENCODERDEVICE">NV_ENC_ERR_INVALID_ENCODERDEVICE</dfn>,</td></tr>
<tr><th id="397">397</th><td></td></tr>
<tr><th id="398">398</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="399">399</th><td><i class="doc">     * This indicates that device passed to the API call is invalid.</i></td></tr>
<tr><th id="400">400</th><td><i class="doc">     */</i></td></tr>
<tr><th id="401">401</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_DEVICE" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_DEVICE' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_DEVICE">NV_ENC_ERR_INVALID_DEVICE</dfn>,</td></tr>
<tr><th id="402">402</th><td></td></tr>
<tr><th id="403">403</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="404">404</th><td><i class="doc">     * This indicates that device passed to the API call is no longer available and</i></td></tr>
<tr><th id="405">405</th><td><i class="doc">     * needs to be reinitialized. The clients need to destroy the current encoder</i></td></tr>
<tr><th id="406">406</th><td><i class="doc">     * session by freeing the allocated input output buffers and destroying the device</i></td></tr>
<tr><th id="407">407</th><td><i class="doc">     * and create a new encoding session.</i></td></tr>
<tr><th id="408">408</th><td><i class="doc">     */</i></td></tr>
<tr><th id="409">409</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_DEVICE_NOT_EXIST" title='_NVENCSTATUS::NV_ENC_ERR_DEVICE_NOT_EXIST' data-ref="_NVENCSTATUS::NV_ENC_ERR_DEVICE_NOT_EXIST">NV_ENC_ERR_DEVICE_NOT_EXIST</dfn>,</td></tr>
<tr><th id="410">410</th><td></td></tr>
<tr><th id="411">411</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="412">412</th><td><i class="doc">     * This indicates that one or more of the pointers passed to the API call</i></td></tr>
<tr><th id="413">413</th><td><i class="doc">     * is invalid.</i></td></tr>
<tr><th id="414">414</th><td><i class="doc">     */</i></td></tr>
<tr><th id="415">415</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_PTR" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_PTR' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_PTR">NV_ENC_ERR_INVALID_PTR</dfn>,</td></tr>
<tr><th id="416">416</th><td></td></tr>
<tr><th id="417">417</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="418">418</th><td><i class="doc">     * This indicates that completion event passed in ::NvEncEncodePicture() call</i></td></tr>
<tr><th id="419">419</th><td><i class="doc">     * is invalid.</i></td></tr>
<tr><th id="420">420</th><td><i class="doc">     */</i></td></tr>
<tr><th id="421">421</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_EVENT" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_EVENT' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_EVENT">NV_ENC_ERR_INVALID_EVENT</dfn>,</td></tr>
<tr><th id="422">422</th><td></td></tr>
<tr><th id="423">423</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="424">424</th><td><i class="doc">     * This indicates that one or more of the parameter passed to the API call</i></td></tr>
<tr><th id="425">425</th><td><i class="doc">     * is invalid.</i></td></tr>
<tr><th id="426">426</th><td><i class="doc">     */</i></td></tr>
<tr><th id="427">427</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_PARAM" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_PARAM' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_PARAM">NV_ENC_ERR_INVALID_PARAM</dfn>,</td></tr>
<tr><th id="428">428</th><td></td></tr>
<tr><th id="429">429</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="430">430</th><td><i class="doc">     * This indicates that an API call was made in wrong sequence/order.</i></td></tr>
<tr><th id="431">431</th><td><i class="doc">     */</i></td></tr>
<tr><th id="432">432</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_CALL" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_CALL' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_CALL">NV_ENC_ERR_INVALID_CALL</dfn>,</td></tr>
<tr><th id="433">433</th><td></td></tr>
<tr><th id="434">434</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="435">435</th><td><i class="doc">     * This indicates that the API call failed because it was unable to allocate</i></td></tr>
<tr><th id="436">436</th><td><i class="doc">     * enough memory to perform the requested operation.</i></td></tr>
<tr><th id="437">437</th><td><i class="doc">     */</i></td></tr>
<tr><th id="438">438</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_OUT_OF_MEMORY" title='_NVENCSTATUS::NV_ENC_ERR_OUT_OF_MEMORY' data-ref="_NVENCSTATUS::NV_ENC_ERR_OUT_OF_MEMORY">NV_ENC_ERR_OUT_OF_MEMORY</dfn>,</td></tr>
<tr><th id="439">439</th><td></td></tr>
<tr><th id="440">440</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="441">441</th><td><i class="doc">     * This indicates that the encoder has not been initialized with</i></td></tr>
<tr><th id="442">442</th><td><i class="doc">     * ::NvEncInitializeEncoder() or that initialization has failed.</i></td></tr>
<tr><th id="443">443</th><td><i class="doc">     * The client cannot allocate input or output buffers or do any encoding</i></td></tr>
<tr><th id="444">444</th><td><i class="doc">     * related operation before successfully initializing the encoder.</i></td></tr>
<tr><th id="445">445</th><td><i class="doc">     */</i></td></tr>
<tr><th id="446">446</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_ENCODER_NOT_INITIALIZED" title='_NVENCSTATUS::NV_ENC_ERR_ENCODER_NOT_INITIALIZED' data-ref="_NVENCSTATUS::NV_ENC_ERR_ENCODER_NOT_INITIALIZED">NV_ENC_ERR_ENCODER_NOT_INITIALIZED</dfn>,</td></tr>
<tr><th id="447">447</th><td></td></tr>
<tr><th id="448">448</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="449">449</th><td><i class="doc">     * This indicates that an unsupported parameter was passed by the client.</i></td></tr>
<tr><th id="450">450</th><td><i class="doc">     */</i></td></tr>
<tr><th id="451">451</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_PARAM" title='_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_PARAM' data-ref="_NVENCSTATUS::NV_ENC_ERR_UNSUPPORTED_PARAM">NV_ENC_ERR_UNSUPPORTED_PARAM</dfn>,</td></tr>
<tr><th id="452">452</th><td></td></tr>
<tr><th id="453">453</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="454">454</th><td><i class="doc">     * This indicates that the ::NvEncLockBitstream() failed to lock the output</i></td></tr>
<tr><th id="455">455</th><td><i class="doc">     * buffer. This happens when the client makes a non blocking lock call to</i></td></tr>
<tr><th id="456">456</th><td><i class="doc">     * access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag.</i></td></tr>
<tr><th id="457">457</th><td><i class="doc">     * This is not a fatal error and client should retry the same operation after</i></td></tr>
<tr><th id="458">458</th><td><i class="doc">     * few milliseconds.</i></td></tr>
<tr><th id="459">459</th><td><i class="doc">     */</i></td></tr>
<tr><th id="460">460</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_LOCK_BUSY" title='_NVENCSTATUS::NV_ENC_ERR_LOCK_BUSY' data-ref="_NVENCSTATUS::NV_ENC_ERR_LOCK_BUSY">NV_ENC_ERR_LOCK_BUSY</dfn>,</td></tr>
<tr><th id="461">461</th><td></td></tr>
<tr><th id="462">462</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="463">463</th><td><i class="doc">     * This indicates that the size of the user buffer passed by the client is</i></td></tr>
<tr><th id="464">464</th><td><i class="doc">     * insufficient for the requested operation.</i></td></tr>
<tr><th id="465">465</th><td><i class="doc">     */</i></td></tr>
<tr><th id="466">466</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_NOT_ENOUGH_BUFFER" title='_NVENCSTATUS::NV_ENC_ERR_NOT_ENOUGH_BUFFER' data-ref="_NVENCSTATUS::NV_ENC_ERR_NOT_ENOUGH_BUFFER">NV_ENC_ERR_NOT_ENOUGH_BUFFER</dfn>,</td></tr>
<tr><th id="467">467</th><td></td></tr>
<tr><th id="468">468</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="469">469</th><td><i class="doc">     * This indicates that an invalid struct version was used by the client.</i></td></tr>
<tr><th id="470">470</th><td><i class="doc">     */</i></td></tr>
<tr><th id="471">471</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INVALID_VERSION" title='_NVENCSTATUS::NV_ENC_ERR_INVALID_VERSION' data-ref="_NVENCSTATUS::NV_ENC_ERR_INVALID_VERSION">NV_ENC_ERR_INVALID_VERSION</dfn>,</td></tr>
<tr><th id="472">472</th><td></td></tr>
<tr><th id="473">473</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="474">474</th><td><i class="doc">     * This indicates that ::NvEncMapInputResource() API failed to map the client</i></td></tr>
<tr><th id="475">475</th><td><i class="doc">     * provided input resource.</i></td></tr>
<tr><th id="476">476</th><td><i class="doc">     */</i></td></tr>
<tr><th id="477">477</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_MAP_FAILED" title='_NVENCSTATUS::NV_ENC_ERR_MAP_FAILED' data-ref="_NVENCSTATUS::NV_ENC_ERR_MAP_FAILED">NV_ENC_ERR_MAP_FAILED</dfn>,</td></tr>
<tr><th id="478">478</th><td></td></tr>
<tr><th id="479">479</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="480">480</th><td><i class="doc">     * This indicates encode driver requires more input buffers to produce an output</i></td></tr>
<tr><th id="481">481</th><td><i class="doc">     * bitstream. If this error is returned from ::NvEncEncodePicture() API, this</i></td></tr>
<tr><th id="482">482</th><td><i class="doc">     * is not a fatal error. If the client is encoding with B frames then,</i></td></tr>
<tr><th id="483">483</th><td><i class="doc">     * ::NvEncEncodePicture() API might be buffering the input frame for re-ordering.</i></td></tr>
<tr><th id="484">484</th><td><i class="doc">     *</i></td></tr>
<tr><th id="485">485</th><td><i class="doc">     * A client operating in synchronous mode cannot call ::NvEncLockBitstream()</i></td></tr>
<tr><th id="486">486</th><td><i class="doc">     * API on the output bitstream buffer if ::NvEncEncodePicture() returned the</i></td></tr>
<tr><th id="487">487</th><td><i class="doc">     * ::NV_ENC_ERR_NEED_MORE_INPUT error code.</i></td></tr>
<tr><th id="488">488</th><td><i class="doc">     * The client must continue providing input frames until encode driver returns</i></td></tr>
<tr><th id="489">489</th><td><i class="doc">     * ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call</i></td></tr>
<tr><th id="490">490</th><td><i class="doc">     * ::NvEncLockBitstream() API on the output buffers in the same order in which</i></td></tr>
<tr><th id="491">491</th><td><i class="doc">     * it has called ::NvEncEncodePicture().</i></td></tr>
<tr><th id="492">492</th><td><i class="doc">     */</i></td></tr>
<tr><th id="493">493</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_NEED_MORE_INPUT" title='_NVENCSTATUS::NV_ENC_ERR_NEED_MORE_INPUT' data-ref="_NVENCSTATUS::NV_ENC_ERR_NEED_MORE_INPUT">NV_ENC_ERR_NEED_MORE_INPUT</dfn>,</td></tr>
<tr><th id="494">494</th><td></td></tr>
<tr><th id="495">495</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="496">496</th><td><i class="doc">     * This indicates that the HW encoder is busy encoding and is unable to encode</i></td></tr>
<tr><th id="497">497</th><td><i class="doc">     * the input. The client should call ::NvEncEncodePicture() again after few</i></td></tr>
<tr><th id="498">498</th><td><i class="doc">     * milliseconds.</i></td></tr>
<tr><th id="499">499</th><td><i class="doc">     */</i></td></tr>
<tr><th id="500">500</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_ENCODER_BUSY" title='_NVENCSTATUS::NV_ENC_ERR_ENCODER_BUSY' data-ref="_NVENCSTATUS::NV_ENC_ERR_ENCODER_BUSY">NV_ENC_ERR_ENCODER_BUSY</dfn>,</td></tr>
<tr><th id="501">501</th><td></td></tr>
<tr><th id="502">502</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="503">503</th><td><i class="doc">     * This indicates that the completion event passed in ::NvEncEncodePicture()</i></td></tr>
<tr><th id="504">504</th><td><i class="doc">     * API has not been registered with encoder driver using ::NvEncRegisterAsyncEvent().</i></td></tr>
<tr><th id="505">505</th><td><i class="doc">     */</i></td></tr>
<tr><th id="506">506</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_EVENT_NOT_REGISTERD" title='_NVENCSTATUS::NV_ENC_ERR_EVENT_NOT_REGISTERD' data-ref="_NVENCSTATUS::NV_ENC_ERR_EVENT_NOT_REGISTERD">NV_ENC_ERR_EVENT_NOT_REGISTERD</dfn>,</td></tr>
<tr><th id="507">507</th><td></td></tr>
<tr><th id="508">508</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="509">509</th><td><i class="doc">     * This indicates that an unknown internal error has occurred.</i></td></tr>
<tr><th id="510">510</th><td><i class="doc">     */</i></td></tr>
<tr><th id="511">511</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_GENERIC" title='_NVENCSTATUS::NV_ENC_ERR_GENERIC' data-ref="_NVENCSTATUS::NV_ENC_ERR_GENERIC">NV_ENC_ERR_GENERIC</dfn>,</td></tr>
<tr><th id="512">512</th><td></td></tr>
<tr><th id="513">513</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="514">514</th><td><i class="doc">     * This indicates that the client is attempting to use a feature</i></td></tr>
<tr><th id="515">515</th><td><i class="doc">     * that is not available for the license type for the current system.</i></td></tr>
<tr><th id="516">516</th><td><i class="doc">     */</i></td></tr>
<tr><th id="517">517</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY" title='_NVENCSTATUS::NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY' data-ref="_NVENCSTATUS::NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY">NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY</dfn>,</td></tr>
<tr><th id="518">518</th><td></td></tr>
<tr><th id="519">519</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="520">520</th><td><i class="doc">     * This indicates that the client is attempting to use a feature</i></td></tr>
<tr><th id="521">521</th><td><i class="doc">     * that is not implemented for the current version.</i></td></tr>
<tr><th id="522">522</th><td><i class="doc">     */</i></td></tr>
<tr><th id="523">523</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_UNIMPLEMENTED" title='_NVENCSTATUS::NV_ENC_ERR_UNIMPLEMENTED' data-ref="_NVENCSTATUS::NV_ENC_ERR_UNIMPLEMENTED">NV_ENC_ERR_UNIMPLEMENTED</dfn>,</td></tr>
<tr><th id="524">524</th><td></td></tr>
<tr><th id="525">525</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="526">526</th><td><i class="doc">     * This indicates that the ::NvEncRegisterResource API failed to register the resource.</i></td></tr>
<tr><th id="527">527</th><td><i class="doc">     */</i></td></tr>
<tr><th id="528">528</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_REGISTER_FAILED" title='_NVENCSTATUS::NV_ENC_ERR_RESOURCE_REGISTER_FAILED' data-ref="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_REGISTER_FAILED">NV_ENC_ERR_RESOURCE_REGISTER_FAILED</dfn>,</td></tr>
<tr><th id="529">529</th><td></td></tr>
<tr><th id="530">530</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="531">531</th><td><i class="doc">     * This indicates that the client is attempting to unregister a resource</i></td></tr>
<tr><th id="532">532</th><td><i class="doc">     * that has not been successfully registered.</i></td></tr>
<tr><th id="533">533</th><td><i class="doc">     */</i></td></tr>
<tr><th id="534">534</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_REGISTERED" title='_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_REGISTERED' data-ref="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_REGISTERED">NV_ENC_ERR_RESOURCE_NOT_REGISTERED</dfn>,</td></tr>
<tr><th id="535">535</th><td></td></tr>
<tr><th id="536">536</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="537">537</th><td><i class="doc">     * This indicates that the client is attempting to unmap a resource</i></td></tr>
<tr><th id="538">538</th><td><i class="doc">     * that has not been successfully mapped.</i></td></tr>
<tr><th id="539">539</th><td><i class="doc">     */</i></td></tr>
<tr><th id="540">540</th><td>    <dfn class="enum" id="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_MAPPED" title='_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_MAPPED' data-ref="_NVENCSTATUS::NV_ENC_ERR_RESOURCE_NOT_MAPPED">NV_ENC_ERR_RESOURCE_NOT_MAPPED</dfn>,</td></tr>
<tr><th id="541">541</th><td></td></tr>
<tr><th id="542">542</th><td>} <dfn class="typedef" id="NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</dfn>;</td></tr>
<tr><th id="543">543</th><td></td></tr>
<tr><th id="544">544</th><td><i class="doc">/**</i></td></tr>
<tr><th id="545">545</th><td><i class="doc"> * Encode Picture encode flags.</i></td></tr>
<tr><th id="546">546</th><td><i class="doc"> */</i></td></tr>
<tr><th id="547">547</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_PIC_FLAGS" title='_NV_ENC_PIC_FLAGS' data-ref="_NV_ENC_PIC_FLAGS"><a class="type" href="#_NV_ENC_PIC_FLAGS" title='_NV_ENC_PIC_FLAGS' data-ref="_NV_ENC_PIC_FLAGS">_NV_ENC_PIC_FLAGS</a></dfn></td></tr>
<tr><th id="548">548</th><td>{</td></tr>
<tr><th id="549">549</th><td>    <dfn class="enum" id="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEINTRA" title='_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEINTRA' data-ref="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEINTRA">NV_ENC_PIC_FLAG_FORCEINTRA</dfn>         = <var>0x1</var>,   <i class="doc">/**&lt; Encode the current picture as an Intra picture */</i></td></tr>
<tr><th id="550">550</th><td>    <dfn class="enum" id="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEIDR" title='_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEIDR' data-ref="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_FORCEIDR">NV_ENC_PIC_FLAG_FORCEIDR</dfn>           = <var>0x2</var>,   <i class="doc">/**&lt; Encode the current picture as an IDR picture.</i></td></tr>
<tr><th id="551">551</th><td><i class="doc">                                                     This flag is only valid when Picture type decision is taken by the Encoder</i></td></tr>
<tr><th id="552">552</th><td><i class="doc">                                                     [_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]. */</i></td></tr>
<tr><th id="553">553</th><td>    <dfn class="enum" id="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_OUTPUT_SPSPPS" title='_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_OUTPUT_SPSPPS' data-ref="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_OUTPUT_SPSPPS">NV_ENC_PIC_FLAG_OUTPUT_SPSPPS</dfn>      = <var>0x4</var>,   <i class="doc">/**&lt; Write the sequence and picture header in encoded bitstream of the current picture */</i></td></tr>
<tr><th id="554">554</th><td>    <dfn class="enum" id="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_EOS" title='_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_EOS' data-ref="_NV_ENC_PIC_FLAGS::NV_ENC_PIC_FLAG_EOS">NV_ENC_PIC_FLAG_EOS</dfn>                = <var>0x8</var>,   <i class="doc">/**&lt; Indicates end of the input stream */</i></td></tr>
<tr><th id="555">555</th><td>} <dfn class="typedef" id="NV_ENC_PIC_FLAGS" title='NV_ENC_PIC_FLAGS' data-type='enum _NV_ENC_PIC_FLAGS' data-ref="NV_ENC_PIC_FLAGS">NV_ENC_PIC_FLAGS</dfn>;</td></tr>
<tr><th id="556">556</th><td></td></tr>
<tr><th id="557">557</th><td><i class="doc">/**</i></td></tr>
<tr><th id="558">558</th><td><i class="doc"> * Memory heap to allocate input and output buffers.</i></td></tr>
<tr><th id="559">559</th><td><i class="doc"> */</i></td></tr>
<tr><th id="560">560</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_MEMORY_HEAP" title='_NV_ENC_MEMORY_HEAP' data-ref="_NV_ENC_MEMORY_HEAP"><a class="type" href="#_NV_ENC_MEMORY_HEAP" title='_NV_ENC_MEMORY_HEAP' data-ref="_NV_ENC_MEMORY_HEAP">_NV_ENC_MEMORY_HEAP</a></dfn></td></tr>
<tr><th id="561">561</th><td>{</td></tr>
<tr><th id="562">562</th><td>    <dfn class="enum" id="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_AUTOSELECT" title='_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_AUTOSELECT' data-ref="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_AUTOSELECT">NV_ENC_MEMORY_HEAP_AUTOSELECT</dfn>      = <var>0</var>, <i class="doc">/**&lt; Memory heap to be decided by the encoder driver based on the usage */</i></td></tr>
<tr><th id="563">563</th><td>    <dfn class="enum" id="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_VID" title='_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_VID' data-ref="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_VID">NV_ENC_MEMORY_HEAP_VID</dfn>             = <var>1</var>, <i class="doc">/**&lt; Memory heap is in local video memory */</i></td></tr>
<tr><th id="564">564</th><td>    <dfn class="enum" id="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_CACHED" title='_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_CACHED' data-ref="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_CACHED">NV_ENC_MEMORY_HEAP_SYSMEM_CACHED</dfn>   = <var>2</var>, <i class="doc">/**&lt; Memory heap is in cached system memory */</i></td></tr>
<tr><th id="565">565</th><td>    <dfn class="enum" id="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED" title='_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED' data-ref="_NV_ENC_MEMORY_HEAP::NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED">NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED</dfn> = <var>3</var>  <i class="doc">/**&lt; Memory heap is in uncached system memory */</i></td></tr>
<tr><th id="566">566</th><td>} <dfn class="typedef" id="NV_ENC_MEMORY_HEAP" title='NV_ENC_MEMORY_HEAP' data-type='enum _NV_ENC_MEMORY_HEAP' data-ref="NV_ENC_MEMORY_HEAP">NV_ENC_MEMORY_HEAP</dfn>;</td></tr>
<tr><th id="567">567</th><td></td></tr>
<tr><th id="568">568</th><td></td></tr>
<tr><th id="569">569</th><td><i class="doc">/**</i></td></tr>
<tr><th id="570">570</th><td><i class="doc"> * H.264 entropy coding modes.</i></td></tr>
<tr><th id="571">571</th><td><i class="doc"> */</i></td></tr>
<tr><th id="572">572</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_H264_ENTROPY_CODING_MODE" title='_NV_ENC_H264_ENTROPY_CODING_MODE' data-ref="_NV_ENC_H264_ENTROPY_CODING_MODE"><a class="type" href="#_NV_ENC_H264_ENTROPY_CODING_MODE" title='_NV_ENC_H264_ENTROPY_CODING_MODE' data-ref="_NV_ENC_H264_ENTROPY_CODING_MODE">_NV_ENC_H264_ENTROPY_CODING_MODE</a></dfn></td></tr>
<tr><th id="573">573</th><td>{</td></tr>
<tr><th id="574">574</th><td>    <dfn class="enum" id="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT" title='_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT' data-ref="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT">NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT</dfn> = <var>0x0</var>,   <i class="doc">/**&lt; Entropy coding mode is auto selected by the encoder driver */</i></td></tr>
<tr><th id="575">575</th><td>    <dfn class="enum" id="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CABAC" title='_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CABAC' data-ref="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CABAC">NV_ENC_H264_ENTROPY_CODING_MODE_CABAC</dfn>      = <var>0x1</var>,   <i class="doc">/**&lt; Entropy coding mode is CABAC */</i></td></tr>
<tr><th id="576">576</th><td>    <dfn class="enum" id="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC" title='_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC' data-ref="_NV_ENC_H264_ENTROPY_CODING_MODE::NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC">NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC</dfn>      = <var>0x2</var>    <i class="doc">/**&lt; Entropy coding mode is CAVLC */</i></td></tr>
<tr><th id="577">577</th><td>} <dfn class="typedef" id="NV_ENC_H264_ENTROPY_CODING_MODE" title='NV_ENC_H264_ENTROPY_CODING_MODE' data-type='enum _NV_ENC_H264_ENTROPY_CODING_MODE' data-ref="NV_ENC_H264_ENTROPY_CODING_MODE">NV_ENC_H264_ENTROPY_CODING_MODE</dfn>;</td></tr>
<tr><th id="578">578</th><td></td></tr>
<tr><th id="579">579</th><td><i class="doc">/**</i></td></tr>
<tr><th id="580">580</th><td><i class="doc"> * H.264 specific Bdirect modes</i></td></tr>
<tr><th id="581">581</th><td><i class="doc"> */</i></td></tr>
<tr><th id="582">582</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_H264_BDIRECT_MODE" title='_NV_ENC_H264_BDIRECT_MODE' data-ref="_NV_ENC_H264_BDIRECT_MODE"><a class="type" href="#_NV_ENC_H264_BDIRECT_MODE" title='_NV_ENC_H264_BDIRECT_MODE' data-ref="_NV_ENC_H264_BDIRECT_MODE">_NV_ENC_H264_BDIRECT_MODE</a></dfn></td></tr>
<tr><th id="583">583</th><td>{</td></tr>
<tr><th id="584">584</th><td>    <dfn class="enum" id="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_AUTOSELECT" title='_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_AUTOSELECT' data-ref="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_AUTOSELECT">NV_ENC_H264_BDIRECT_MODE_AUTOSELECT</dfn> = <var>0x0</var>,          <i class="doc">/**&lt; BDirect mode is auto selected by the encoder driver */</i></td></tr>
<tr><th id="585">585</th><td>    <dfn class="enum" id="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_DISABLE" title='_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_DISABLE' data-ref="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_DISABLE">NV_ENC_H264_BDIRECT_MODE_DISABLE</dfn>    = <var>0x1</var>,          <i class="doc">/**&lt; Disable BDirect mode */</i></td></tr>
<tr><th id="586">586</th><td>    <dfn class="enum" id="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_TEMPORAL" title='_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_TEMPORAL' data-ref="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_TEMPORAL">NV_ENC_H264_BDIRECT_MODE_TEMPORAL</dfn>   = <var>0x2</var>,          <i class="doc">/**&lt; Temporal BDirect mode */</i></td></tr>
<tr><th id="587">587</th><td>    <dfn class="enum" id="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_SPATIAL" title='_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_SPATIAL' data-ref="_NV_ENC_H264_BDIRECT_MODE::NV_ENC_H264_BDIRECT_MODE_SPATIAL">NV_ENC_H264_BDIRECT_MODE_SPATIAL</dfn>    = <var>0x3</var>           <i class="doc">/**&lt; Spatial BDirect mode */</i></td></tr>
<tr><th id="588">588</th><td>} <dfn class="typedef" id="NV_ENC_H264_BDIRECT_MODE" title='NV_ENC_H264_BDIRECT_MODE' data-type='enum _NV_ENC_H264_BDIRECT_MODE' data-ref="NV_ENC_H264_BDIRECT_MODE">NV_ENC_H264_BDIRECT_MODE</dfn>;</td></tr>
<tr><th id="589">589</th><td></td></tr>
<tr><th id="590">590</th><td><i class="doc">/**</i></td></tr>
<tr><th id="591">591</th><td><i class="doc"> * H.264 specific FMO usage</i></td></tr>
<tr><th id="592">592</th><td><i class="doc"> */</i></td></tr>
<tr><th id="593">593</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_H264_FMO_MODE" title='_NV_ENC_H264_FMO_MODE' data-ref="_NV_ENC_H264_FMO_MODE"><a class="type" href="#_NV_ENC_H264_FMO_MODE" title='_NV_ENC_H264_FMO_MODE' data-ref="_NV_ENC_H264_FMO_MODE">_NV_ENC_H264_FMO_MODE</a></dfn></td></tr>
<tr><th id="594">594</th><td>{</td></tr>
<tr><th id="595">595</th><td>    <dfn class="enum" id="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_AUTOSELECT" title='_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_AUTOSELECT' data-ref="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_AUTOSELECT">NV_ENC_H264_FMO_AUTOSELECT</dfn>          = <var>0x0</var>,          <i class="doc">/**&lt; FMO usage is auto selected by the encoder driver */</i></td></tr>
<tr><th id="596">596</th><td>    <dfn class="enum" id="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_ENABLE" title='_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_ENABLE' data-ref="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_ENABLE">NV_ENC_H264_FMO_ENABLE</dfn>              = <var>0x1</var>,          <i class="doc">/**&lt; Enable FMO */</i></td></tr>
<tr><th id="597">597</th><td>    <dfn class="enum" id="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_DISABLE" title='_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_DISABLE' data-ref="_NV_ENC_H264_FMO_MODE::NV_ENC_H264_FMO_DISABLE">NV_ENC_H264_FMO_DISABLE</dfn>             = <var>0x2</var>,          <i class="doc">/**&lt; Disble FMO */</i></td></tr>
<tr><th id="598">598</th><td>} <dfn class="typedef" id="NV_ENC_H264_FMO_MODE" title='NV_ENC_H264_FMO_MODE' data-type='enum _NV_ENC_H264_FMO_MODE' data-ref="NV_ENC_H264_FMO_MODE">NV_ENC_H264_FMO_MODE</dfn>;</td></tr>
<tr><th id="599">599</th><td></td></tr>
<tr><th id="600">600</th><td><i class="doc">/**</i></td></tr>
<tr><th id="601">601</th><td><i class="doc"> * H.264 specific Adaptive Transform modes</i></td></tr>
<tr><th id="602">602</th><td><i class="doc"> */</i></td></tr>
<tr><th id="603">603</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE" title='_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-ref="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE"><a class="type" href="#_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE" title='_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-ref="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE">_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE</a></dfn></td></tr>
<tr><th id="604">604</th><td>{</td></tr>
<tr><th id="605">605</th><td>    <dfn class="enum" id="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT" title='_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT' data-ref="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT">NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT</dfn> = <var>0x0</var>,   <i class="doc">/**&lt; Adaptive Transform 8x8 mode is auto selected by the encoder driver*/</i></td></tr>
<tr><th id="606">606</th><td>    <dfn class="enum" id="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE" title='_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE' data-ref="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE">NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE</dfn>    = <var>0x1</var>,   <i class="doc">/**&lt; Adaptive Transform 8x8 mode disabled */</i></td></tr>
<tr><th id="607">607</th><td>    <dfn class="enum" id="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE" title='_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE' data-ref="_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE::NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE">NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE</dfn>     = <var>0x2</var>,   <i class="doc">/**&lt; Adaptive Transform 8x8 mode should be used */</i></td></tr>
<tr><th id="608">608</th><td>} <dfn class="typedef" id="NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE" title='NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-type='enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-ref="NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE">NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE</dfn>;</td></tr>
<tr><th id="609">609</th><td></td></tr>
<tr><th id="610">610</th><td><i class="doc">/**</i></td></tr>
<tr><th id="611">611</th><td><i class="doc"> * Stereo frame packing modes.</i></td></tr>
<tr><th id="612">612</th><td><i class="doc"> */</i></td></tr>
<tr><th id="613">613</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_STEREO_PACKING_MODE" title='_NV_ENC_STEREO_PACKING_MODE' data-ref="_NV_ENC_STEREO_PACKING_MODE"><a class="type" href="#_NV_ENC_STEREO_PACKING_MODE" title='_NV_ENC_STEREO_PACKING_MODE' data-ref="_NV_ENC_STEREO_PACKING_MODE">_NV_ENC_STEREO_PACKING_MODE</a></dfn></td></tr>
<tr><th id="614">614</th><td>{</td></tr>
<tr><th id="615">615</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_NONE" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_NONE' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_NONE">NV_ENC_STEREO_PACKING_MODE_NONE</dfn>             = <var>0x0</var>,  <i class="doc">/**&lt; No Stereo packing required */</i></td></tr>
<tr><th id="616">616</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD">NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD</dfn>     = <var>0x1</var>,  <i class="doc">/**&lt; Checkerboard mode for packing stereo frames */</i></td></tr>
<tr><th id="617">617</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE">NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE</dfn>    = <var>0x2</var>,  <i class="doc">/**&lt; Column Interleave mode for packing stereo frames */</i></td></tr>
<tr><th id="618">618</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE">NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE</dfn>    = <var>0x3</var>,  <i class="doc">/**&lt; Row Interleave mode for packing stereo frames */</i></td></tr>
<tr><th id="619">619</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE">NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE</dfn>       = <var>0x4</var>,  <i class="doc">/**&lt; Side-by-side mode for packing stereo frames */</i></td></tr>
<tr><th id="620">620</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM">NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM</dfn>        = <var>0x5</var>,  <i class="doc">/**&lt; Top-Bottom mode for packing stereo frames */</i></td></tr>
<tr><th id="621">621</th><td>    <dfn class="enum" id="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_FRAMESEQ" title='_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_FRAMESEQ' data-ref="_NV_ENC_STEREO_PACKING_MODE::NV_ENC_STEREO_PACKING_MODE_FRAMESEQ">NV_ENC_STEREO_PACKING_MODE_FRAMESEQ</dfn>         = <var>0x6</var>   <i class="doc">/**&lt; Frame Sequential mode for packing stereo frames */</i></td></tr>
<tr><th id="622">622</th><td>} <dfn class="typedef" id="NV_ENC_STEREO_PACKING_MODE" title='NV_ENC_STEREO_PACKING_MODE' data-type='enum _NV_ENC_STEREO_PACKING_MODE' data-ref="NV_ENC_STEREO_PACKING_MODE">NV_ENC_STEREO_PACKING_MODE</dfn>;</td></tr>
<tr><th id="623">623</th><td></td></tr>
<tr><th id="624">624</th><td><i class="doc">/**</i></td></tr>
<tr><th id="625">625</th><td><i class="doc"> *  Input Resource type</i></td></tr>
<tr><th id="626">626</th><td><i class="doc"> */</i></td></tr>
<tr><th id="627">627</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_INPUT_RESOURCE_TYPE" title='_NV_ENC_INPUT_RESOURCE_TYPE' data-ref="_NV_ENC_INPUT_RESOURCE_TYPE"><a class="type" href="#_NV_ENC_INPUT_RESOURCE_TYPE" title='_NV_ENC_INPUT_RESOURCE_TYPE' data-ref="_NV_ENC_INPUT_RESOURCE_TYPE">_NV_ENC_INPUT_RESOURCE_TYPE</a></dfn></td></tr>
<tr><th id="628">628</th><td>{</td></tr>
<tr><th id="629">629</th><td>    <dfn class="enum" id="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX" title='_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX' data-ref="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX">NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX</dfn>          = <var>0x0</var>,   <i class="doc">/**&lt; input resource type is a directx9 surface*/</i></td></tr>
<tr><th id="630">630</th><td>    <dfn class="enum" id="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR" title='_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR' data-ref="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR">NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR</dfn>    = <var>0x1</var>,   <i class="doc">/**&lt; input resource type is a cuda device pointer surface*/</i></td></tr>
<tr><th id="631">631</th><td>    <dfn class="enum" id="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY" title='_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY' data-ref="_NV_ENC_INPUT_RESOURCE_TYPE::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY">NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY</dfn>        = <var>0x2</var>,   <i class="doc">/**&lt; input resource type is a cuda array surface */</i></td></tr>
<tr><th id="632">632</th><td>} <dfn class="typedef" id="NV_ENC_INPUT_RESOURCE_TYPE" title='NV_ENC_INPUT_RESOURCE_TYPE' data-type='enum _NV_ENC_INPUT_RESOURCE_TYPE' data-ref="NV_ENC_INPUT_RESOURCE_TYPE">NV_ENC_INPUT_RESOURCE_TYPE</dfn>;</td></tr>
<tr><th id="633">633</th><td></td></tr>
<tr><th id="634">634</th><td><i class="doc">/**</i></td></tr>
<tr><th id="635">635</th><td><i class="doc"> *  Encoder Device type</i></td></tr>
<tr><th id="636">636</th><td><i class="doc"> */</i></td></tr>
<tr><th id="637">637</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_DEVICE_TYPE" title='_NV_ENC_DEVICE_TYPE' data-ref="_NV_ENC_DEVICE_TYPE"><a class="type" href="#_NV_ENC_DEVICE_TYPE" title='_NV_ENC_DEVICE_TYPE' data-ref="_NV_ENC_DEVICE_TYPE">_NV_ENC_DEVICE_TYPE</a></dfn></td></tr>
<tr><th id="638">638</th><td>{</td></tr>
<tr><th id="639">639</th><td>    <dfn class="enum" id="_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_DIRECTX" title='_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_DIRECTX' data-ref="_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_DIRECTX">NV_ENC_DEVICE_TYPE_DIRECTX</dfn>          = <var>0x0</var>,   <i class="doc">/**&lt; encode device type is a directx9 device */</i></td></tr>
<tr><th id="640">640</th><td>    <dfn class="enum" id="_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_CUDA" title='_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_CUDA' data-ref="_NV_ENC_DEVICE_TYPE::NV_ENC_DEVICE_TYPE_CUDA">NV_ENC_DEVICE_TYPE_CUDA</dfn>             = <var>0x1</var>,   <i class="doc">/**&lt; encode device type is a cuda device */</i></td></tr>
<tr><th id="641">641</th><td>} <dfn class="typedef" id="NV_ENC_DEVICE_TYPE" title='NV_ENC_DEVICE_TYPE' data-type='enum _NV_ENC_DEVICE_TYPE' data-ref="NV_ENC_DEVICE_TYPE">NV_ENC_DEVICE_TYPE</dfn>;</td></tr>
<tr><th id="642">642</th><td></td></tr>
<tr><th id="643">643</th><td><i class="doc">/**</i></td></tr>
<tr><th id="644">644</th><td><i class="doc"> * Encoder capabilities enumeration.</i></td></tr>
<tr><th id="645">645</th><td><i class="doc"> */</i></td></tr>
<tr><th id="646">646</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_CAPS" title='_NV_ENC_CAPS' data-ref="_NV_ENC_CAPS"><a class="type" href="#_NV_ENC_CAPS" title='_NV_ENC_CAPS' data-ref="_NV_ENC_CAPS">_NV_ENC_CAPS</a></dfn></td></tr>
<tr><th id="647">647</th><td>{</td></tr>
<tr><th id="648">648</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="649">649</th><td><i class="doc">     * Maximum number of B-Frames supported.</i></td></tr>
<tr><th id="650">650</th><td><i class="doc">     */</i></td></tr>
<tr><th id="651">651</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_BFRAMES" title='_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_BFRAMES' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_BFRAMES">NV_ENC_CAPS_NUM_MAX_BFRAMES</dfn>,</td></tr>
<tr><th id="652">652</th><td></td></tr>
<tr><th id="653">653</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="654">654</th><td><i class="doc">     * Rate control modes supported.</i></td></tr>
<tr><th id="655">655</th><td><i class="doc">     *<span class="command"> \n</span> The API return value is a bitmask of the values in NV_ENC_PARAMS_RC_MODE.</i></td></tr>
<tr><th id="656">656</th><td><i class="doc">     */</i></td></tr>
<tr><th id="657">657</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES">NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES</dfn>,</td></tr>
<tr><th id="658">658</th><td></td></tr>
<tr><th id="659">659</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="660">660</th><td><i class="doc">     * Indicates HW support for field mode encoding.</i></td></tr>
<tr><th id="661">661</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Interlaced mode encoding is not supported.</i></td></tr>
<tr><th id="662">662</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Interlaced field mode encoding is supported.</i></td></tr>
<tr><th id="663">663</th><td><i class="doc">     *<span class="command"> \n</span> 2 : Interlaced frame encoding and field mode encoding are both supported.</i></td></tr>
<tr><th id="664">664</th><td><i class="doc">     */</i></td></tr>
<tr><th id="665">665</th><td>     <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING">NV_ENC_CAPS_SUPPORT_FIELD_ENCODING</dfn>,</td></tr>
<tr><th id="666">666</th><td></td></tr>
<tr><th id="667">667</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="668">668</th><td><i class="doc">     * Indicates HW support for monochrome mode encoding.</i></td></tr>
<tr><th id="669">669</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Monochrome mode not supported.</i></td></tr>
<tr><th id="670">670</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Monochrome mode supported.</i></td></tr>
<tr><th id="671">671</th><td><i class="doc">     */</i></td></tr>
<tr><th id="672">672</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MONOCHROME" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MONOCHROME' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MONOCHROME">NV_ENC_CAPS_SUPPORT_MONOCHROME</dfn>,</td></tr>
<tr><th id="673">673</th><td></td></tr>
<tr><th id="674">674</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="675">675</th><td><i class="doc">     * Indicates HW support for FMO.</i></td></tr>
<tr><th id="676">676</th><td><i class="doc">     *<span class="command"> \n</span> 0 : FMO not supported.</i></td></tr>
<tr><th id="677">677</th><td><i class="doc">     *<span class="command"> \n</span> 1 : FMO supported.</i></td></tr>
<tr><th id="678">678</th><td><i class="doc">     */</i></td></tr>
<tr><th id="679">679</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FMO" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FMO' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_FMO">NV_ENC_CAPS_SUPPORT_FMO</dfn>,</td></tr>
<tr><th id="680">680</th><td></td></tr>
<tr><th id="681">681</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="682">682</th><td><i class="doc">     * Indicates HW capability for Quarter pel motion estimation.</i></td></tr>
<tr><th id="683">683</th><td><i class="doc">     *<span class="command"> \n</span> 0 : QuarterPel Motion Estimation not supported.</i></td></tr>
<tr><th id="684">684</th><td><i class="doc">     *<span class="command"> \n</span> 1 : QuarterPel Motion Estimation supported.</i></td></tr>
<tr><th id="685">685</th><td><i class="doc">     */</i></td></tr>
<tr><th id="686">686</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_QPELMV" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_QPELMV' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_QPELMV">NV_ENC_CAPS_SUPPORT_QPELMV</dfn>,</td></tr>
<tr><th id="687">687</th><td></td></tr>
<tr><th id="688">688</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="689">689</th><td><i class="doc">     * H.264 specific. Indicates HW support for BDirect modes.</i></td></tr>
<tr><th id="690">690</th><td><i class="doc">     *<span class="command"> \n</span> 0 : BDirect mode encoding not supported.</i></td></tr>
<tr><th id="691">691</th><td><i class="doc">     *<span class="command"> \n</span> 1 : BDirect mode encoding supported.</i></td></tr>
<tr><th id="692">692</th><td><i class="doc">     */</i></td></tr>
<tr><th id="693">693</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE">NV_ENC_CAPS_SUPPORT_BDIRECT_MODE</dfn>,</td></tr>
<tr><th id="694">694</th><td></td></tr>
<tr><th id="695">695</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="696">696</th><td><i class="doc">     * H264 specific. Indicates HW support for CABAC entropy coding mode.</i></td></tr>
<tr><th id="697">697</th><td><i class="doc">     *<span class="command"> \n</span> 0 : CABAC entropy coding not supported.</i></td></tr>
<tr><th id="698">698</th><td><i class="doc">     *<span class="command"> \n</span> 1 : CABAC entropy coding supported.</i></td></tr>
<tr><th id="699">699</th><td><i class="doc">     */</i></td></tr>
<tr><th id="700">700</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CABAC" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CABAC' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CABAC">NV_ENC_CAPS_SUPPORT_CABAC</dfn>,</td></tr>
<tr><th id="701">701</th><td></td></tr>
<tr><th id="702">702</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="703">703</th><td><i class="doc">     * Indicates HW support for Adaptive Transform.</i></td></tr>
<tr><th id="704">704</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Adaptive Transform not supported.</i></td></tr>
<tr><th id="705">705</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Adaptive Transform supported.</i></td></tr>
<tr><th id="706">706</th><td><i class="doc">     */</i></td></tr>
<tr><th id="707">707</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM">NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM</dfn>,</td></tr>
<tr><th id="708">708</th><td></td></tr>
<tr><th id="709">709</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="710">710</th><td><i class="doc">     * Reserved enum field.</i></td></tr>
<tr><th id="711">711</th><td><i class="doc">     */</i></td></tr>
<tr><th id="712">712</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_RESERVED" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_RESERVED' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_RESERVED">NV_ENC_CAPS_SUPPORT_RESERVED</dfn>,</td></tr>
<tr><th id="713">713</th><td></td></tr>
<tr><th id="714">714</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="715">715</th><td><i class="doc">     * Indicates HW support for encoding Temporal layers.</i></td></tr>
<tr><th id="716">716</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Encoding Temporal layers not supported.</i></td></tr>
<tr><th id="717">717</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Encoding Temporal layers supported.</i></td></tr>
<tr><th id="718">718</th><td><i class="doc">     */</i></td></tr>
<tr><th id="719">719</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS" title='_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS">NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS</dfn>,</td></tr>
<tr><th id="720">720</th><td></td></tr>
<tr><th id="721">721</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="722">722</th><td><i class="doc">     * Indicates HW support for Hierarchical P frames.</i></td></tr>
<tr><th id="723">723</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Hierarchical P frames not supported.</i></td></tr>
<tr><th id="724">724</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Hierarchical P frames supported.</i></td></tr>
<tr><th id="725">725</th><td><i class="doc">     */</i></td></tr>
<tr><th id="726">726</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES">NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES</dfn>,</td></tr>
<tr><th id="727">727</th><td></td></tr>
<tr><th id="728">728</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="729">729</th><td><i class="doc">     * Indicates HW support for Hierarchical B frames.</i></td></tr>
<tr><th id="730">730</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Hierarchical B frames not supported.</i></td></tr>
<tr><th id="731">731</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Hierarchical B frames supported.</i></td></tr>
<tr><th id="732">732</th><td><i class="doc">     */</i></td></tr>
<tr><th id="733">733</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES">NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES</dfn>,</td></tr>
<tr><th id="734">734</th><td></td></tr>
<tr><th id="735">735</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="736">736</th><td><i class="doc">     * Maximum Encoding level supported (See ::NV_ENC_LEVEL for details).</i></td></tr>
<tr><th id="737">737</th><td><i class="doc">     */</i></td></tr>
<tr><th id="738">738</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MAX" title='_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MAX' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MAX">NV_ENC_CAPS_LEVEL_MAX</dfn>,</td></tr>
<tr><th id="739">739</th><td></td></tr>
<tr><th id="740">740</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="741">741</th><td><i class="doc">     * Minimum Encoding level supported (See ::NV_ENC_LEVEL for details).</i></td></tr>
<tr><th id="742">742</th><td><i class="doc">     */</i></td></tr>
<tr><th id="743">743</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MIN" title='_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MIN' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_LEVEL_MIN">NV_ENC_CAPS_LEVEL_MIN</dfn>,</td></tr>
<tr><th id="744">744</th><td></td></tr>
<tr><th id="745">745</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="746">746</th><td><i class="doc">     * Indicates HW support for separate colour plane encoding.</i></td></tr>
<tr><th id="747">747</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Separate colour plane encoding not supported.</i></td></tr>
<tr><th id="748">748</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Separate colour plane encoding supported.</i></td></tr>
<tr><th id="749">749</th><td><i class="doc">     */</i></td></tr>
<tr><th id="750">750</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SEPARATE_COLOUR_PLANE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SEPARATE_COLOUR_PLANE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SEPARATE_COLOUR_PLANE">NV_ENC_CAPS_SEPARATE_COLOUR_PLANE</dfn>,</td></tr>
<tr><th id="751">751</th><td></td></tr>
<tr><th id="752">752</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="753">753</th><td><i class="doc">     * Maximum output width supported.</i></td></tr>
<tr><th id="754">754</th><td><i class="doc">     */</i></td></tr>
<tr><th id="755">755</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_WIDTH_MAX" title='_NV_ENC_CAPS::NV_ENC_CAPS_WIDTH_MAX' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_WIDTH_MAX">NV_ENC_CAPS_WIDTH_MAX</dfn>,</td></tr>
<tr><th id="756">756</th><td></td></tr>
<tr><th id="757">757</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="758">758</th><td><i class="doc">     * Maximum output height supported.</i></td></tr>
<tr><th id="759">759</th><td><i class="doc">     */</i></td></tr>
<tr><th id="760">760</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_HEIGHT_MAX" title='_NV_ENC_CAPS::NV_ENC_CAPS_HEIGHT_MAX' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_HEIGHT_MAX">NV_ENC_CAPS_HEIGHT_MAX</dfn>,</td></tr>
<tr><th id="761">761</th><td></td></tr>
<tr><th id="762">762</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="763">763</th><td><i class="doc">     * Indicates Temporal Scalability Support.</i></td></tr>
<tr><th id="764">764</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Temporal SVC encoding not supported.</i></td></tr>
<tr><th id="765">765</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Temporal SVC encoding supported.</i></td></tr>
<tr><th id="766">766</th><td><i class="doc">     */</i></td></tr>
<tr><th id="767">767</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC">NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC</dfn>,</td></tr>
<tr><th id="768">768</th><td></td></tr>
<tr><th id="769">769</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="770">770</th><td><i class="doc">     * Indicates Dynamic Encode Resolution Change Support.</i></td></tr>
<tr><th id="771">771</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="772">772</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Dynamic Encode Resolution Change not supported.</i></td></tr>
<tr><th id="773">773</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Dynamic Encode Resolution Change supported.</i></td></tr>
<tr><th id="774">774</th><td><i class="doc">     */</i></td></tr>
<tr><th id="775">775</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE">NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE</dfn>,</td></tr>
<tr><th id="776">776</th><td></td></tr>
<tr><th id="777">777</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="778">778</th><td><i class="doc">     * Indicates Dynamic Encode Bitrate Change Support.</i></td></tr>
<tr><th id="779">779</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="780">780</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Dynamic Encode bitrate change not supported.</i></td></tr>
<tr><th id="781">781</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Dynamic Encode bitrate change supported.</i></td></tr>
<tr><th id="782">782</th><td><i class="doc">     */</i></td></tr>
<tr><th id="783">783</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE">NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE</dfn>,</td></tr>
<tr><th id="784">784</th><td></td></tr>
<tr><th id="785">785</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="786">786</th><td><i class="doc">     * Indicates Forcing Constant QP On The Fly Support.</i></td></tr>
<tr><th id="787">787</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="788">788</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Forcing constant QP on the fly not supported.</i></td></tr>
<tr><th id="789">789</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Forcing constant QP on the fly supported.</i></td></tr>
<tr><th id="790">790</th><td><i class="doc">     */</i></td></tr>
<tr><th id="791">791</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP">NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP</dfn>,</td></tr>
<tr><th id="792">792</th><td></td></tr>
<tr><th id="793">793</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="794">794</th><td><i class="doc">     * Indicates Dynamic rate control mode Change Support.</i></td></tr>
<tr><th id="795">795</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Dynamic rate control mode change not supported.</i></td></tr>
<tr><th id="796">796</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Dynamic rate control mode change supported.</i></td></tr>
<tr><th id="797">797</th><td><i class="doc">     */</i></td></tr>
<tr><th id="798">798</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE">NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE</dfn>,</td></tr>
<tr><th id="799">799</th><td></td></tr>
<tr><th id="800">800</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="801">801</th><td><i class="doc">     * Indicates Subframe readback support for slice-based encoding.</i></td></tr>
<tr><th id="802">802</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Subframe readback not supported.</i></td></tr>
<tr><th id="803">803</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Subframe readback supported.</i></td></tr>
<tr><th id="804">804</th><td><i class="doc">     */</i></td></tr>
<tr><th id="805">805</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK">NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK</dfn>,</td></tr>
<tr><th id="806">806</th><td></td></tr>
<tr><th id="807">807</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="808">808</th><td><i class="doc">     * Indicates Constrained Encoding mode support.</i></td></tr>
<tr><th id="809">809</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="810">810</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Constrained encoding mode not supported.</i></td></tr>
<tr><th id="811">811</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Constarined encoding mode supported.</i></td></tr>
<tr><th id="812">812</th><td><i class="doc">     * If this mode is supported client can enable this during initialisation.</i></td></tr>
<tr><th id="813">813</th><td><i class="doc">     * Client can then force a picture to be coded as constrained picture where</i></td></tr>
<tr><th id="814">814</th><td><i class="doc">     * each slice in a constrained picture will have constrained_intra_pred_flag set to 1</i></td></tr>
<tr><th id="815">815</th><td><i class="doc">     * and disable_deblocking_filter_idc will be set to 2 and prediction vectors for inter</i></td></tr>
<tr><th id="816">816</th><td><i class="doc">     * macroblocks in each slice will be restricted to the slice region.</i></td></tr>
<tr><th id="817">817</th><td><i class="doc">     */</i></td></tr>
<tr><th id="818">818</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING">NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING</dfn>,</td></tr>
<tr><th id="819">819</th><td></td></tr>
<tr><th id="820">820</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="821">821</th><td><i class="doc">     * Indicates Intra Refresh Mode Support.</i></td></tr>
<tr><th id="822">822</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="823">823</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Intra Refresh Mode not supported.</i></td></tr>
<tr><th id="824">824</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Intra Refresh Mode supported.</i></td></tr>
<tr><th id="825">825</th><td><i class="doc">     */</i></td></tr>
<tr><th id="826">826</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_INTRA_REFRESH" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_INTRA_REFRESH' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_INTRA_REFRESH">NV_ENC_CAPS_SUPPORT_INTRA_REFRESH</dfn>,</td></tr>
<tr><th id="827">827</th><td></td></tr>
<tr><th id="828">828</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="829">829</th><td><i class="doc">     * Indicates Custom VBV Bufer Size support. It can be used for capping frame size.</i></td></tr>
<tr><th id="830">830</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="831">831</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Custom VBV buffer size specification from client, not supported.</i></td></tr>
<tr><th id="832">832</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Custom VBV buffer size specification from client, supported.</i></td></tr>
<tr><th id="833">833</th><td><i class="doc">     */</i></td></tr>
<tr><th id="834">834</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE">NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE</dfn>,</td></tr>
<tr><th id="835">835</th><td></td></tr>
<tr><th id="836">836</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="837">837</th><td><i class="doc">     * Indicates Dynamic Slice Mode Support.</i></td></tr>
<tr><th id="838">838</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="839">839</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Dynamic Slice Mode not supported.</i></td></tr>
<tr><th id="840">840</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Dynamic Slice Mode supported.</i></td></tr>
<tr><th id="841">841</th><td><i class="doc">     */</i></td></tr>
<tr><th id="842">842</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE">NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE</dfn>,</td></tr>
<tr><th id="843">843</th><td></td></tr>
<tr><th id="844">844</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="845">845</th><td><i class="doc">     * Indicates Reference Picture Invalidation Support.</i></td></tr>
<tr><th id="846">846</th><td><i class="doc">     * Support added from NvEncodeAPI version 2.0.</i></td></tr>
<tr><th id="847">847</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Reference Picture Invalidation not supported.</i></td></tr>
<tr><th id="848">848</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Reference Picture Invalidation supported.</i></td></tr>
<tr><th id="849">849</th><td><i class="doc">     */</i></td></tr>
<tr><th id="850">850</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION">NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION</dfn>,</td></tr>
<tr><th id="851">851</th><td></td></tr>
<tr><th id="852">852</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="853">853</th><td><i class="doc">     * Indicates support for PreProcessing.</i></td></tr>
<tr><th id="854">854</th><td><i class="doc">     * The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS</i></td></tr>
<tr><th id="855">855</th><td><i class="doc">     */</i></td></tr>
<tr><th id="856">856</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_PREPROC_SUPPORT" title='_NV_ENC_CAPS::NV_ENC_CAPS_PREPROC_SUPPORT' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_PREPROC_SUPPORT">NV_ENC_CAPS_PREPROC_SUPPORT</dfn>,</td></tr>
<tr><th id="857">857</th><td></td></tr>
<tr><th id="858">858</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="859">859</th><td><i class="doc">    * Indicates support Async mode.</i></td></tr>
<tr><th id="860">860</th><td><i class="doc">    *<span class="command"> \n</span> 0 : Async Encode mode not supported.</i></td></tr>
<tr><th id="861">861</th><td><i class="doc">    *<span class="command"> \n</span> 1 : Async Encode mode supported.</i></td></tr>
<tr><th id="862">862</th><td><i class="doc">    */</i></td></tr>
<tr><th id="863">863</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT" title='_NV_ENC_CAPS::NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT">NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT</dfn>,</td></tr>
<tr><th id="864">864</th><td></td></tr>
<tr><th id="865">865</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="866">866</th><td><i class="doc">     * Maximum MBs per frame supported.</i></td></tr>
<tr><th id="867">867</th><td><i class="doc">     */</i></td></tr>
<tr><th id="868">868</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_MB_NUM_MAX" title='_NV_ENC_CAPS::NV_ENC_CAPS_MB_NUM_MAX' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_MB_NUM_MAX">NV_ENC_CAPS_MB_NUM_MAX</dfn>,</td></tr>
<tr><th id="869">869</th><td></td></tr>
<tr><th id="870">870</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="871">871</th><td><i class="doc">     * Maximum aggregate throughput in MBs per sec.</i></td></tr>
<tr><th id="872">872</th><td><i class="doc">     */</i></td></tr>
<tr><th id="873">873</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_MB_PER_SEC_MAX" title='_NV_ENC_CAPS::NV_ENC_CAPS_MB_PER_SEC_MAX' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_MB_PER_SEC_MAX">NV_ENC_CAPS_MB_PER_SEC_MAX</dfn>,</td></tr>
<tr><th id="874">874</th><td></td></tr>
<tr><th id="875">875</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="876">876</th><td><i class="doc">     * Indicates HW support for YUV444 mode encoding.</i></td></tr>
<tr><th id="877">877</th><td><i class="doc">     *<span class="command"> \n</span> 0 : YUV444 mode encoding not supported.</i></td></tr>
<tr><th id="878">878</th><td><i class="doc">     *<span class="command"> \n</span> 1 : YUV444 mode encoding supported.</i></td></tr>
<tr><th id="879">879</th><td><i class="doc">     */</i></td></tr>
<tr><th id="880">880</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE">NV_ENC_CAPS_SUPPORT_YUV444_ENCODE</dfn>,</td></tr>
<tr><th id="881">881</th><td></td></tr>
<tr><th id="882">882</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="883">883</th><td><i class="doc">     * Indicates HW support for lossless encoding.</i></td></tr>
<tr><th id="884">884</th><td><i class="doc">     *<span class="command"> \n</span> 0 : lossless encoding not supported.</i></td></tr>
<tr><th id="885">885</th><td><i class="doc">     *<span class="command"> \n</span> 1 : lossless encoding supported.</i></td></tr>
<tr><th id="886">886</th><td><i class="doc">     */</i></td></tr>
<tr><th id="887">887</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE">NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE</dfn>,</td></tr>
<tr><th id="888">888</th><td></td></tr>
<tr><th id="889">889</th><td>     <i class="doc">/**</i></td></tr>
<tr><th id="890">890</th><td><i class="doc">     * Indicates HW support for Sample Adaptive Offset.</i></td></tr>
<tr><th id="891">891</th><td><i class="doc">     *<span class="command"> \n</span> 0 : SAO not supported.</i></td></tr>
<tr><th id="892">892</th><td><i class="doc">     *<span class="command"> \n</span> 1 : SAO encoding supported.</i></td></tr>
<tr><th id="893">893</th><td><i class="doc">     */</i></td></tr>
<tr><th id="894">894</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SAO" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SAO' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_SAO">NV_ENC_CAPS_SUPPORT_SAO</dfn>,</td></tr>
<tr><th id="895">895</th><td></td></tr>
<tr><th id="896">896</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="897">897</th><td><i class="doc">     * Indicates HW support for MEOnly Mode.</i></td></tr>
<tr><th id="898">898</th><td><i class="doc">     *<span class="command"> \n</span> 0 : MEOnly Mode not supported.</i></td></tr>
<tr><th id="899">899</th><td><i class="doc">     *<span class="command"> \n</span> 1 : MEOnly Mode supported.</i></td></tr>
<tr><th id="900">900</th><td><i class="doc">     */</i></td></tr>
<tr><th id="901">901</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MEONLY_MODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MEONLY_MODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_MEONLY_MODE">NV_ENC_CAPS_SUPPORT_MEONLY_MODE</dfn>,</td></tr>
<tr><th id="902">902</th><td></td></tr>
<tr><th id="903">903</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="904">904</th><td><i class="doc">     * Indicates HW support for lookahead encoding (enableLookahead=1).</i></td></tr>
<tr><th id="905">905</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Lookahead not supported.</i></td></tr>
<tr><th id="906">906</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Lookahead supported.</i></td></tr>
<tr><th id="907">907</th><td><i class="doc">     */</i></td></tr>
<tr><th id="908">908</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOOKAHEAD" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOOKAHEAD' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_LOOKAHEAD">NV_ENC_CAPS_SUPPORT_LOOKAHEAD</dfn>,</td></tr>
<tr><th id="909">909</th><td></td></tr>
<tr><th id="910">910</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="911">911</th><td><i class="doc">     * Indicates HW support for temporal AQ encoding (enableTemporalAQ=1).</i></td></tr>
<tr><th id="912">912</th><td><i class="doc">     *<span class="command"> \n</span> 0 : Temporal AQ not supported.</i></td></tr>
<tr><th id="913">913</th><td><i class="doc">     *<span class="command"> \n</span> 1 : Temporal AQ supported.</i></td></tr>
<tr><th id="914">914</th><td><i class="doc">     */</i></td></tr>
<tr><th id="915">915</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ">NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ</dfn>,</td></tr>
<tr><th id="916">916</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="917">917</th><td><i class="doc">     * Indicates HW support for 10 bit encoding.</i></td></tr>
<tr><th id="918">918</th><td><i class="doc">     *<span class="command"> \n</span> 0 : 10 bit encoding not supported.</i></td></tr>
<tr><th id="919">919</th><td><i class="doc">     *<span class="command"> \n</span> 1 : 10 bit encoding supported.</i></td></tr>
<tr><th id="920">920</th><td><i class="doc">     */</i></td></tr>
<tr><th id="921">921</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_10BIT_ENCODE" title='_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_10BIT_ENCODE' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_SUPPORT_10BIT_ENCODE">NV_ENC_CAPS_SUPPORT_10BIT_ENCODE</dfn>,</td></tr>
<tr><th id="922">922</th><td></td></tr>
<tr><th id="923">923</th><td>    <i class="doc">/**</i></td></tr>
<tr><th id="924">924</th><td><i class="doc">     * Reserved - Not to be used by clients.</i></td></tr>
<tr><th id="925">925</th><td><i class="doc">     */</i></td></tr>
<tr><th id="926">926</th><td>    <dfn class="enum" id="_NV_ENC_CAPS::NV_ENC_CAPS_EXPOSED_COUNT" title='_NV_ENC_CAPS::NV_ENC_CAPS_EXPOSED_COUNT' data-ref="_NV_ENC_CAPS::NV_ENC_CAPS_EXPOSED_COUNT">NV_ENC_CAPS_EXPOSED_COUNT</dfn></td></tr>
<tr><th id="927">927</th><td>} <dfn class="typedef" id="NV_ENC_CAPS" title='NV_ENC_CAPS' data-type='enum _NV_ENC_CAPS' data-ref="NV_ENC_CAPS">NV_ENC_CAPS</dfn>;</td></tr>
<tr><th id="928">928</th><td></td></tr>
<tr><th id="929">929</th><td><i class="doc">/**</i></td></tr>
<tr><th id="930">930</th><td><i class="doc"> *  HEVC CU SIZE</i></td></tr>
<tr><th id="931">931</th><td><i class="doc"> */</i></td></tr>
<tr><th id="932">932</th><td><b>typedef</b> <b>enum</b> <dfn class="type def" id="_NV_ENC_HEVC_CUSIZE" title='_NV_ENC_HEVC_CUSIZE' data-ref="_NV_ENC_HEVC_CUSIZE"><a class="type" href="#_NV_ENC_HEVC_CUSIZE" title='_NV_ENC_HEVC_CUSIZE' data-ref="_NV_ENC_HEVC_CUSIZE">_NV_ENC_HEVC_CUSIZE</a></dfn></td></tr>
<tr><th id="933">933</th><td>{</td></tr>
<tr><th id="934">934</th><td>    <dfn class="enum" id="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_AUTOSELECT" title='_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_AUTOSELECT' data-ref="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_AUTOSELECT">NV_ENC_HEVC_CUSIZE_AUTOSELECT</dfn> = <var>0</var>,</td></tr>
<tr><th id="935">935</th><td>    <dfn class="enum" id="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_8x8" title='_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_8x8' data-ref="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_8x8">NV_ENC_HEVC_CUSIZE_8x8</dfn>        = <var>1</var>,</td></tr>
<tr><th id="936">936</th><td>    <dfn class="enum" id="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_16x16" title='_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_16x16' data-ref="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_16x16">NV_ENC_HEVC_CUSIZE_16x16</dfn>      = <var>2</var>,</td></tr>
<tr><th id="937">937</th><td>    <dfn class="enum" id="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_32x32" title='_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_32x32' data-ref="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_32x32">NV_ENC_HEVC_CUSIZE_32x32</dfn>      = <var>3</var>,</td></tr>
<tr><th id="938">938</th><td>    <dfn class="enum" id="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_64x64" title='_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_64x64' data-ref="_NV_ENC_HEVC_CUSIZE::NV_ENC_HEVC_CUSIZE_64x64">NV_ENC_HEVC_CUSIZE_64x64</dfn>      = <var>4</var>,</td></tr>
<tr><th id="939">939</th><td>}<dfn class="typedef" id="NV_ENC_HEVC_CUSIZE" title='NV_ENC_HEVC_CUSIZE' data-type='enum _NV_ENC_HEVC_CUSIZE' data-ref="NV_ENC_HEVC_CUSIZE">NV_ENC_HEVC_CUSIZE</dfn>;</td></tr>
<tr><th id="940">940</th><td></td></tr>
<tr><th id="941">941</th><td><i class="doc">/**</i></td></tr>
<tr><th id="942">942</th><td><i class="doc"> * Input struct for querying Encoding capabilities.</i></td></tr>
<tr><th id="943">943</th><td><i class="doc"> */</i></td></tr>
<tr><th id="944">944</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CAPS_PARAM" title='_NV_ENC_CAPS_PARAM' data-ref="_NV_ENC_CAPS_PARAM"><a class="type" href="#_NV_ENC_CAPS_PARAM" title='_NV_ENC_CAPS_PARAM' data-ref="_NV_ENC_CAPS_PARAM">_NV_ENC_CAPS_PARAM</a></dfn></td></tr>
<tr><th id="945">945</th><td>{</td></tr>
<tr><th id="946">946</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CAPS_PARAM::version" title='_NV_ENC_CAPS_PARAM::version' data-ref="_NV_ENC_CAPS_PARAM::version">version</dfn>;                                  <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_CAPS_PARAM_VER */</i></td></tr>
<tr><th id="947">947</th><td>    <a class="typedef" href="#NV_ENC_CAPS" title='NV_ENC_CAPS' data-type='enum _NV_ENC_CAPS' data-ref="NV_ENC_CAPS">NV_ENC_CAPS</a>  <dfn class="decl" id="_NV_ENC_CAPS_PARAM::capsToQuery" title='_NV_ENC_CAPS_PARAM::capsToQuery' data-ref="_NV_ENC_CAPS_PARAM::capsToQuery">capsToQuery</dfn>;                          <i class="doc">/**&lt; [in]: Specifies the encode capability to be queried. Client should pass a member for ::NV_ENC_CAPS enum. */</i></td></tr>
<tr><th id="948">948</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CAPS_PARAM::reserved" title='_NV_ENC_CAPS_PARAM::reserved' data-ref="_NV_ENC_CAPS_PARAM::reserved">reserved</dfn>[<var>62</var>];                             <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="949">949</th><td>} <dfn class="typedef" id="NV_ENC_CAPS_PARAM" title='NV_ENC_CAPS_PARAM' data-type='struct _NV_ENC_CAPS_PARAM' data-ref="NV_ENC_CAPS_PARAM">NV_ENC_CAPS_PARAM</dfn>;</td></tr>
<tr><th id="950">950</th><td></td></tr>
<tr><th id="951">951</th><td><i class="doc">/** NV_ENC_CAPS_PARAM struct version. */</i></td></tr>
<tr><th id="952">952</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_CAPS_PARAM_VER" data-ref="_M/NV_ENC_CAPS_PARAM_VER">NV_ENC_CAPS_PARAM_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="953">953</th><td></td></tr>
<tr><th id="954">954</th><td></td></tr>
<tr><th id="955">955</th><td><i class="doc">/**</i></td></tr>
<tr><th id="956">956</th><td><i class="doc"> * Creation parameters for input buffer.</i></td></tr>
<tr><th id="957">957</th><td><i class="doc"> */</i></td></tr>
<tr><th id="958">958</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CREATE_INPUT_BUFFER" title='_NV_ENC_CREATE_INPUT_BUFFER' data-ref="_NV_ENC_CREATE_INPUT_BUFFER"><a class="type" href="#_NV_ENC_CREATE_INPUT_BUFFER" title='_NV_ENC_CREATE_INPUT_BUFFER' data-ref="_NV_ENC_CREATE_INPUT_BUFFER">_NV_ENC_CREATE_INPUT_BUFFER</a></dfn></td></tr>
<tr><th id="959">959</th><td>{</td></tr>
<tr><th id="960">960</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::version" title='_NV_ENC_CREATE_INPUT_BUFFER::version' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::version">version</dfn>;                 <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_CREATE_INPUT_BUFFER_VER */</i></td></tr>
<tr><th id="961">961</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::width" title='_NV_ENC_CREATE_INPUT_BUFFER::width' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::width">width</dfn>;                   <i class="doc">/**&lt; [in]: Input buffer width */</i></td></tr>
<tr><th id="962">962</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::height" title='_NV_ENC_CREATE_INPUT_BUFFER::height' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::height">height</dfn>;                  <i class="doc">/**&lt; [in]: Input buffer width */</i></td></tr>
<tr><th id="963">963</th><td>    <a class="typedef" href="#NV_ENC_MEMORY_HEAP" title='NV_ENC_MEMORY_HEAP' data-type='enum _NV_ENC_MEMORY_HEAP' data-ref="NV_ENC_MEMORY_HEAP">NV_ENC_MEMORY_HEAP</a>        <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::memoryHeap" title='_NV_ENC_CREATE_INPUT_BUFFER::memoryHeap' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::memoryHeap">memoryHeap</dfn>;              <i class="doc">/**&lt; [in]: Deprecated. Will be removed in sdk 8.0 */</i></td></tr>
<tr><th id="964">964</th><td>    <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>      <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::bufferFmt" title='_NV_ENC_CREATE_INPUT_BUFFER::bufferFmt' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::bufferFmt">bufferFmt</dfn>;               <i class="doc">/**&lt; [in]: Input buffer format */</i></td></tr>
<tr><th id="965">965</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::reserved" title='_NV_ENC_CREATE_INPUT_BUFFER::reserved' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::reserved">reserved</dfn>;                <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="966">966</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>          <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::inputBuffer" title='_NV_ENC_CREATE_INPUT_BUFFER::inputBuffer' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::inputBuffer">inputBuffer</dfn>;             <i class="doc">/**&lt; [out]: Pointer to input buffer */</i></td></tr>
<tr><th id="967">967</th><td>    <em>void</em>*                     <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::pSysMemBuffer" title='_NV_ENC_CREATE_INPUT_BUFFER::pSysMemBuffer' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::pSysMemBuffer">pSysMemBuffer</dfn>;           <i class="doc">/**&lt; [in]: Pointer to existing sysmem buffer */</i></td></tr>
<tr><th id="968">968</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::reserved1" title='_NV_ENC_CREATE_INPUT_BUFFER::reserved1' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::reserved1">reserved1</dfn>[<var>57</var>];           <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="969">969</th><td>    <em>void</em>*                     <dfn class="decl" id="_NV_ENC_CREATE_INPUT_BUFFER::reserved2" title='_NV_ENC_CREATE_INPUT_BUFFER::reserved2' data-ref="_NV_ENC_CREATE_INPUT_BUFFER::reserved2">reserved2</dfn>[<var>63</var>];           <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="970">970</th><td>} <dfn class="typedef" id="NV_ENC_CREATE_INPUT_BUFFER" title='NV_ENC_CREATE_INPUT_BUFFER' data-type='struct _NV_ENC_CREATE_INPUT_BUFFER' data-ref="NV_ENC_CREATE_INPUT_BUFFER">NV_ENC_CREATE_INPUT_BUFFER</dfn>;</td></tr>
<tr><th id="971">971</th><td></td></tr>
<tr><th id="972">972</th><td><i class="doc">/** NV_ENC_CREATE_INPUT_BUFFER struct version. */</i></td></tr>
<tr><th id="973">973</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_CREATE_INPUT_BUFFER_VER" data-ref="_M/NV_ENC_CREATE_INPUT_BUFFER_VER">NV_ENC_CREATE_INPUT_BUFFER_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="974">974</th><td></td></tr>
<tr><th id="975">975</th><td><i class="doc">/**</i></td></tr>
<tr><th id="976">976</th><td><i class="doc"> * Creation parameters for output bitstream buffer.</i></td></tr>
<tr><th id="977">977</th><td><i class="doc"> */</i></td></tr>
<tr><th id="978">978</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CREATE_BITSTREAM_BUFFER" title='_NV_ENC_CREATE_BITSTREAM_BUFFER' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER"><a class="type" href="#_NV_ENC_CREATE_BITSTREAM_BUFFER" title='_NV_ENC_CREATE_BITSTREAM_BUFFER' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER">_NV_ENC_CREATE_BITSTREAM_BUFFER</a></dfn></td></tr>
<tr><th id="979">979</th><td>{</td></tr>
<tr><th id="980">980</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>              <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::version" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::version' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::version">version</dfn>;                     <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_CREATE_BITSTREAM_BUFFER_VER */</i></td></tr>
<tr><th id="981">981</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>              <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::size" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::size' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::size">size</dfn>;                        <i class="doc">/**&lt; [in]: Size of the bitstream buffer to be created */</i></td></tr>
<tr><th id="982">982</th><td>    <a class="typedef" href="#NV_ENC_MEMORY_HEAP" title='NV_ENC_MEMORY_HEAP' data-type='enum _NV_ENC_MEMORY_HEAP' data-ref="NV_ENC_MEMORY_HEAP">NV_ENC_MEMORY_HEAP</a>    <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::memoryHeap" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::memoryHeap' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::memoryHeap">memoryHeap</dfn>;                  <i class="doc">/**&lt; [in]: Deprecated. Will be removed in sdk 8.0 */</i></td></tr>
<tr><th id="983">983</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>              <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved">reserved</dfn>;                    <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="984">984</th><td>    <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a>     <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer">bitstreamBuffer</dfn>;             <i class="doc">/**&lt; [out]: Pointer to the output bitstream buffer */</i></td></tr>
<tr><th id="985">985</th><td>    <em>void</em>*                 <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBufferPtr" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBufferPtr' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBufferPtr">bitstreamBufferPtr</dfn>;          <i class="doc">/**&lt; [out]: Reserved and should not be used */</i></td></tr>
<tr><th id="986">986</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>              <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved1" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved1' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved1">reserved1</dfn>[<var>58</var>];               <i class="doc">/**&lt; [in]: Reserved and should be set to 0 */</i></td></tr>
<tr><th id="987">987</th><td>    <em>void</em>*                 <dfn class="decl" id="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved2" title='_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved2' data-ref="_NV_ENC_CREATE_BITSTREAM_BUFFER::reserved2">reserved2</dfn>[<var>64</var>];               <i class="doc">/**&lt; [in]: Reserved and should be set to NULL */</i></td></tr>
<tr><th id="988">988</th><td>} <dfn class="typedef" id="NV_ENC_CREATE_BITSTREAM_BUFFER" title='NV_ENC_CREATE_BITSTREAM_BUFFER' data-type='struct _NV_ENC_CREATE_BITSTREAM_BUFFER' data-ref="NV_ENC_CREATE_BITSTREAM_BUFFER">NV_ENC_CREATE_BITSTREAM_BUFFER</dfn>;</td></tr>
<tr><th id="989">989</th><td></td></tr>
<tr><th id="990">990</th><td><i class="doc">/** NV_ENC_CREATE_BITSTREAM_BUFFER struct version. */</i></td></tr>
<tr><th id="991">991</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_CREATE_BITSTREAM_BUFFER_VER" data-ref="_M/NV_ENC_CREATE_BITSTREAM_BUFFER_VER">NV_ENC_CREATE_BITSTREAM_BUFFER_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="992">992</th><td></td></tr>
<tr><th id="993">993</th><td><i class="doc">/**</i></td></tr>
<tr><th id="994">994</th><td><i class="doc"> * Structs needed for ME only mode.</i></td></tr>
<tr><th id="995">995</th><td><i class="doc"> */</i></td></tr>
<tr><th id="996">996</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_MVECTOR" title='_NV_ENC_MVECTOR' data-ref="_NV_ENC_MVECTOR"><a class="type" href="#_NV_ENC_MVECTOR" title='_NV_ENC_MVECTOR' data-ref="_NV_ENC_MVECTOR">_NV_ENC_MVECTOR</a></dfn></td></tr>
<tr><th id="997">997</th><td>{</td></tr>
<tr><th id="998">998</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int16_t" title='int16_t' data-type='short' data-ref="int16_t">int16_t</a>             <dfn class="decl" id="_NV_ENC_MVECTOR::mvx" title='_NV_ENC_MVECTOR::mvx' data-ref="_NV_ENC_MVECTOR::mvx">mvx</dfn>;               <i class="doc">/**&lt; the x component of MV in qpel units */</i></td></tr>
<tr><th id="999">999</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int16_t" title='int16_t' data-type='short' data-ref="int16_t">int16_t</a>             <dfn class="decl" id="_NV_ENC_MVECTOR::mvy" title='_NV_ENC_MVECTOR::mvy' data-ref="_NV_ENC_MVECTOR::mvy">mvy</dfn>;               <i class="doc">/**&lt; the y component of MV in qpel units */</i></td></tr>
<tr><th id="1000">1000</th><td>} <dfn class="typedef" id="NV_ENC_MVECTOR" title='NV_ENC_MVECTOR' data-type='struct _NV_ENC_MVECTOR' data-ref="NV_ENC_MVECTOR">NV_ENC_MVECTOR</dfn>;</td></tr>
<tr><th id="1001">1001</th><td></td></tr>
<tr><th id="1002">1002</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1003">1003</th><td><i class="doc"> * Motion vector structure per macroblock for H264 motion estimation.</i></td></tr>
<tr><th id="1004">1004</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1005">1005</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_H264_MV_DATA" title='_NV_ENC_H264_MV_DATA' data-ref="_NV_ENC_H264_MV_DATA"><a class="type" href="#_NV_ENC_H264_MV_DATA" title='_NV_ENC_H264_MV_DATA' data-ref="_NV_ENC_H264_MV_DATA">_NV_ENC_H264_MV_DATA</a></dfn></td></tr>
<tr><th id="1006">1006</th><td>{</td></tr>
<tr><th id="1007">1007</th><td>    <a class="typedef" href="#NV_ENC_MVECTOR" title='NV_ENC_MVECTOR' data-type='struct _NV_ENC_MVECTOR' data-ref="NV_ENC_MVECTOR">NV_ENC_MVECTOR</a>      <dfn class="decl" id="_NV_ENC_H264_MV_DATA::mv" title='_NV_ENC_H264_MV_DATA::mv' data-ref="_NV_ENC_H264_MV_DATA::mv">mv</dfn>[<var>4</var>];             <i class="doc">/**&lt; up to 4 vectors for 8x8 partition */</i></td></tr>
<tr><th id="1008">1008</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>             <dfn class="decl" id="_NV_ENC_H264_MV_DATA::mbType" title='_NV_ENC_H264_MV_DATA::mbType' data-ref="_NV_ENC_H264_MV_DATA::mbType">mbType</dfn>;            <i class="doc">/**&lt; 0 (I), 1 (P), 2 (IPCM), 3 (B) */</i></td></tr>
<tr><th id="1009">1009</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>             <dfn class="decl" id="_NV_ENC_H264_MV_DATA::partitionType" title='_NV_ENC_H264_MV_DATA::partitionType' data-ref="_NV_ENC_H264_MV_DATA::partitionType">partitionType</dfn>;     <i class="doc">/**&lt; Specifies the block partition type. 0:16x16, 1:8x8, 2:16x8, 3:8x16 */</i></td></tr>
<tr><th id="1010">1010</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a>            <dfn class="decl" id="_NV_ENC_H264_MV_DATA::reserved" title='_NV_ENC_H264_MV_DATA::reserved' data-ref="_NV_ENC_H264_MV_DATA::reserved">reserved</dfn>;          <i class="doc">/**&lt; reserved padding for alignment */</i></td></tr>
<tr><th id="1011">1011</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_H264_MV_DATA::mbCost" title='_NV_ENC_H264_MV_DATA::mbCost' data-ref="_NV_ENC_H264_MV_DATA::mbCost">mbCost</dfn>;</td></tr>
<tr><th id="1012">1012</th><td>} <dfn class="typedef" id="NV_ENC_H264_MV_DATA" title='NV_ENC_H264_MV_DATA' data-type='struct _NV_ENC_H264_MV_DATA' data-ref="NV_ENC_H264_MV_DATA">NV_ENC_H264_MV_DATA</dfn>;</td></tr>
<tr><th id="1013">1013</th><td></td></tr>
<tr><th id="1014">1014</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1015">1015</th><td><i class="doc"> * Motion vector structure per CU for HEVC motion estimation.</i></td></tr>
<tr><th id="1016">1016</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1017">1017</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_HEVC_MV_DATA" title='_NV_ENC_HEVC_MV_DATA' data-ref="_NV_ENC_HEVC_MV_DATA"><a class="type" href="#_NV_ENC_HEVC_MV_DATA" title='_NV_ENC_HEVC_MV_DATA' data-ref="_NV_ENC_HEVC_MV_DATA">_NV_ENC_HEVC_MV_DATA</a></dfn></td></tr>
<tr><th id="1018">1018</th><td>{</td></tr>
<tr><th id="1019">1019</th><td>    <a class="typedef" href="#NV_ENC_MVECTOR" title='NV_ENC_MVECTOR' data-type='struct _NV_ENC_MVECTOR' data-ref="NV_ENC_MVECTOR">NV_ENC_MVECTOR</a>    <dfn class="decl" id="_NV_ENC_HEVC_MV_DATA::mv" title='_NV_ENC_HEVC_MV_DATA::mv' data-ref="_NV_ENC_HEVC_MV_DATA::mv">mv</dfn>[<var>4</var>];               <i class="doc">/**&lt; up to 4 vectors within a CU */</i></td></tr>
<tr><th id="1020">1020</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>           <dfn class="decl" id="_NV_ENC_HEVC_MV_DATA::cuType" title='_NV_ENC_HEVC_MV_DATA::cuType' data-ref="_NV_ENC_HEVC_MV_DATA::cuType">cuType</dfn>;              <i class="doc">/**&lt; 0 (I), 1(P), 2 (Skip) */</i></td></tr>
<tr><th id="1021">1021</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>           <dfn class="decl" id="_NV_ENC_HEVC_MV_DATA::cuSize" title='_NV_ENC_HEVC_MV_DATA::cuSize' data-ref="_NV_ENC_HEVC_MV_DATA::cuSize">cuSize</dfn>;              <i class="doc">/**&lt; 0: 8x8, 1: 16x16, 2: 32x32, 3: 64x64 */</i></td></tr>
<tr><th id="1022">1022</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>           <dfn class="decl" id="_NV_ENC_HEVC_MV_DATA::partitionMode" title='_NV_ENC_HEVC_MV_DATA::partitionMode' data-ref="_NV_ENC_HEVC_MV_DATA::partitionMode">partitionMode</dfn>;       <i class="doc">/**&lt; The CU partition mode</i></td></tr>
<tr><th id="1023">1023</th><td><i class="doc">                                                0 (2Nx2N), 1 (2NxN), 2(Nx2N), 3 (NxN),</i></td></tr>
<tr><th id="1024">1024</th><td><i class="doc">                                                4 (2NxnU), 5 (2NxnD), 6(nLx2N), 7 (nRx2N) */</i></td></tr>
<tr><th id="1025">1025</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>           <dfn class="decl" id="_NV_ENC_HEVC_MV_DATA::lastCUInCTB" title='_NV_ENC_HEVC_MV_DATA::lastCUInCTB' data-ref="_NV_ENC_HEVC_MV_DATA::lastCUInCTB">lastCUInCTB</dfn>;         <i class="doc">/**&lt; Marker to separate CUs in the current CTB from CUs in the next CTB */</i></td></tr>
<tr><th id="1026">1026</th><td>} <dfn class="typedef" id="NV_ENC_HEVC_MV_DATA" title='NV_ENC_HEVC_MV_DATA' data-type='struct _NV_ENC_HEVC_MV_DATA' data-ref="NV_ENC_HEVC_MV_DATA">NV_ENC_HEVC_MV_DATA</dfn>;</td></tr>
<tr><th id="1027">1027</th><td></td></tr>
<tr><th id="1028">1028</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1029">1029</th><td><i class="doc"> * Creation parameters for output motion vector buffer for ME only mode.</i></td></tr>
<tr><th id="1030">1030</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1031">1031</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CREATE_MV_BUFFER" title='_NV_ENC_CREATE_MV_BUFFER' data-ref="_NV_ENC_CREATE_MV_BUFFER"><a class="type" href="#_NV_ENC_CREATE_MV_BUFFER" title='_NV_ENC_CREATE_MV_BUFFER' data-ref="_NV_ENC_CREATE_MV_BUFFER">_NV_ENC_CREATE_MV_BUFFER</a></dfn></td></tr>
<tr><th id="1032">1032</th><td>{</td></tr>
<tr><th id="1033">1033</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_CREATE_MV_BUFFER::version" title='_NV_ENC_CREATE_MV_BUFFER::version' data-ref="_NV_ENC_CREATE_MV_BUFFER::version">version</dfn>;           <i class="doc">/**&lt; [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER */</i></td></tr>
<tr><th id="1034">1034</th><td>    <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a>   <dfn class="decl" id="_NV_ENC_CREATE_MV_BUFFER::mvBuffer" title='_NV_ENC_CREATE_MV_BUFFER::mvBuffer' data-ref="_NV_ENC_CREATE_MV_BUFFER::mvBuffer">mvBuffer</dfn>;          <i class="doc">/**&lt; [out]: Pointer to the output motion vector buffer */</i></td></tr>
<tr><th id="1035">1035</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_CREATE_MV_BUFFER::reserved1" title='_NV_ENC_CREATE_MV_BUFFER::reserved1' data-ref="_NV_ENC_CREATE_MV_BUFFER::reserved1">reserved1</dfn>[<var>255</var>];    <i class="doc">/**&lt; [in]: Reserved and should be set to 0 */</i></td></tr>
<tr><th id="1036">1036</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_CREATE_MV_BUFFER::reserved2" title='_NV_ENC_CREATE_MV_BUFFER::reserved2' data-ref="_NV_ENC_CREATE_MV_BUFFER::reserved2">reserved2</dfn>[<var>63</var>];     <i class="doc">/**&lt; [in]: Reserved and should be set to NULL */</i></td></tr>
<tr><th id="1037">1037</th><td>} <dfn class="typedef" id="NV_ENC_CREATE_MV_BUFFER" title='NV_ENC_CREATE_MV_BUFFER' data-type='struct _NV_ENC_CREATE_MV_BUFFER' data-ref="NV_ENC_CREATE_MV_BUFFER">NV_ENC_CREATE_MV_BUFFER</dfn>;</td></tr>
<tr><th id="1038">1038</th><td></td></tr>
<tr><th id="1039">1039</th><td><i class="doc">/** NV_ENC_CREATE_MV_BUFFER struct version*/</i></td></tr>
<tr><th id="1040">1040</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_CREATE_MV_BUFFER_VER" data-ref="_M/NV_ENC_CREATE_MV_BUFFER_VER">NV_ENC_CREATE_MV_BUFFER_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1041">1041</th><td></td></tr>
<tr><th id="1042">1042</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1043">1043</th><td><i class="doc"> * QP value for frames</i></td></tr>
<tr><th id="1044">1044</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1045">1045</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_QP" title='_NV_ENC_QP' data-ref="_NV_ENC_QP"><a class="type" href="#_NV_ENC_QP" title='_NV_ENC_QP' data-ref="_NV_ENC_QP">_NV_ENC_QP</a></dfn></td></tr>
<tr><th id="1046">1046</th><td>{</td></tr>
<tr><th id="1047">1047</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>        <dfn class="decl" id="_NV_ENC_QP::qpInterP" title='_NV_ENC_QP::qpInterP' data-ref="_NV_ENC_QP::qpInterP">qpInterP</dfn>;</td></tr>
<tr><th id="1048">1048</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>        <dfn class="decl" id="_NV_ENC_QP::qpInterB" title='_NV_ENC_QP::qpInterB' data-ref="_NV_ENC_QP::qpInterB">qpInterB</dfn>;</td></tr>
<tr><th id="1049">1049</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>        <dfn class="decl" id="_NV_ENC_QP::qpIntra" title='_NV_ENC_QP::qpIntra' data-ref="_NV_ENC_QP::qpIntra">qpIntra</dfn>;</td></tr>
<tr><th id="1050">1050</th><td>} <dfn class="typedef" id="NV_ENC_QP" title='NV_ENC_QP' data-type='struct _NV_ENC_QP' data-ref="NV_ENC_QP">NV_ENC_QP</dfn>;</td></tr>
<tr><th id="1051">1051</th><td></td></tr>
<tr><th id="1052">1052</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1053">1053</th><td><i class="doc"> * Rate Control Configuration Paramters</i></td></tr>
<tr><th id="1054">1054</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1055">1055</th><td> <b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_RC_PARAMS" title='_NV_ENC_RC_PARAMS' data-ref="_NV_ENC_RC_PARAMS"><a class="type" href="#_NV_ENC_RC_PARAMS" title='_NV_ENC_RC_PARAMS' data-ref="_NV_ENC_RC_PARAMS">_NV_ENC_RC_PARAMS</a></dfn></td></tr>
<tr><th id="1056">1056</th><td> {</td></tr>
<tr><th id="1057">1057</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::version" title='_NV_ENC_RC_PARAMS::version' data-ref="_NV_ENC_RC_PARAMS::version">version</dfn>;</td></tr>
<tr><th id="1058">1058</th><td>    <a class="typedef" href="#NV_ENC_PARAMS_RC_MODE" title='NV_ENC_PARAMS_RC_MODE' data-type='enum _NV_ENC_PARAMS_RC_MODE' data-ref="NV_ENC_PARAMS_RC_MODE">NV_ENC_PARAMS_RC_MODE</a>           <dfn class="decl" id="_NV_ENC_RC_PARAMS::rateControlMode" title='_NV_ENC_RC_PARAMS::rateControlMode' data-ref="_NV_ENC_RC_PARAMS::rateControlMode">rateControlMode</dfn>;                             <i class="doc">/**&lt; [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps. */</i></td></tr>
<tr><th id="1059">1059</th><td>    <a class="typedef" href="#NV_ENC_QP" title='NV_ENC_QP' data-type='struct _NV_ENC_QP' data-ref="NV_ENC_QP">NV_ENC_QP</a>                       <dfn class="decl" id="_NV_ENC_RC_PARAMS::constQP" title='_NV_ENC_RC_PARAMS::constQP' data-ref="_NV_ENC_RC_PARAMS::constQP">constQP</dfn>;                                     <i class="doc">/**&lt; [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode. */</i></td></tr>
<tr><th id="1060">1060</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::averageBitRate" title='_NV_ENC_RC_PARAMS::averageBitRate' data-ref="_NV_ENC_RC_PARAMS::averageBitRate">averageBitRate</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the average bitrate(in bits/sec) used for encoding. */</i></td></tr>
<tr><th id="1061">1061</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::maxBitRate" title='_NV_ENC_RC_PARAMS::maxBitRate' data-ref="_NV_ENC_RC_PARAMS::maxBitRate">maxBitRate</dfn>;                                  <i class="doc">/**&lt; [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode. */</i></td></tr>
<tr><th id="1062">1062</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::vbvBufferSize" title='_NV_ENC_RC_PARAMS::vbvBufferSize' data-ref="_NV_ENC_RC_PARAMS::vbvBufferSize">vbvBufferSize</dfn>;                               <i class="doc">/**&lt; [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size. */</i></td></tr>
<tr><th id="1063">1063</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::vbvInitialDelay" title='_NV_ENC_RC_PARAMS::vbvInitialDelay' data-ref="_NV_ENC_RC_PARAMS::vbvInitialDelay">vbvInitialDelay</dfn>;                             <i class="doc">/**&lt; [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay .*/</i></td></tr>
<tr><th id="1064">1064</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableMinQP" title='_NV_ENC_RC_PARAMS::enableMinQP' data-ref="_NV_ENC_RC_PARAMS::enableMinQP">enableMinQP</dfn>          :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 if minimum QP used for rate control. */</i></td></tr>
<tr><th id="1065">1065</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableMaxQP" title='_NV_ENC_RC_PARAMS::enableMaxQP' data-ref="_NV_ENC_RC_PARAMS::enableMaxQP">enableMaxQP</dfn>          :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 if maximum QP used for rate control. */</i></td></tr>
<tr><th id="1066">1066</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableInitialRCQP" title='_NV_ENC_RC_PARAMS::enableInitialRCQP' data-ref="_NV_ENC_RC_PARAMS::enableInitialRCQP">enableInitialRCQP</dfn>    :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 if user suppplied initial QP is used for rate control. */</i></td></tr>
<tr><th id="1067">1067</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableAQ" title='_NV_ENC_RC_PARAMS::enableAQ' data-ref="_NV_ENC_RC_PARAMS::enableAQ">enableAQ</dfn>             :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to enable adaptive quantization (Spatial). */</i></td></tr>
<tr><th id="1068">1068</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableExtQPDeltaMap" title='_NV_ENC_RC_PARAMS::enableExtQPDeltaMap' data-ref="_NV_ENC_RC_PARAMS::enableExtQPDeltaMap">enableExtQPDeltaMap</dfn>  :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to enable additional QP modifier for each MB supplied by client though signed byte array pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap (Not Supported when AQ(Spatial/Temporal) is enabled) */</i></td></tr>
<tr><th id="1069">1069</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableLookahead" title='_NV_ENC_RC_PARAMS::enableLookahead' data-ref="_NV_ENC_RC_PARAMS::enableLookahead">enableLookahead</dfn>      :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to enable lookahead with depth &lt;lookaheadDepth&gt; (if lookahead is enabled, input frames must remain available to the encoder until encode completion) */</i></td></tr>
<tr><th id="1070">1070</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::disableIadapt" title='_NV_ENC_RC_PARAMS::disableIadapt' data-ref="_NV_ENC_RC_PARAMS::disableIadapt">disableIadapt</dfn>        :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to disable adaptive I-frame insertion at scene cuts (only has an effect when lookahead is enabled) */</i></td></tr>
<tr><th id="1071">1071</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::disableBadapt" title='_NV_ENC_RC_PARAMS::disableBadapt' data-ref="_NV_ENC_RC_PARAMS::disableBadapt">disableBadapt</dfn>        :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to disable adaptive B-frame decision (only has an effect when lookahead is enabled) */</i></td></tr>
<tr><th id="1072">1072</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableTemporalAQ" title='_NV_ENC_RC_PARAMS::enableTemporalAQ' data-ref="_NV_ENC_RC_PARAMS::enableTemporalAQ">enableTemporalAQ</dfn>     :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to enable temporal AQ for H.264 */</i></td></tr>
<tr><th id="1073">1073</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::zeroReorderDelay" title='_NV_ENC_RC_PARAMS::zeroReorderDelay' data-ref="_NV_ENC_RC_PARAMS::zeroReorderDelay">zeroReorderDelay</dfn>     :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to indicate zero latency operation (no reordering delay, num_reorder_frames=0) */</i></td></tr>
<tr><th id="1074">1074</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::enableNonRefP" title='_NV_ENC_RC_PARAMS::enableNonRefP' data-ref="_NV_ENC_RC_PARAMS::enableNonRefP">enableNonRefP</dfn>        :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to enable automatic insertion of non-reference P-frames (no effect if enablePTD=0) */</i></td></tr>
<tr><th id="1075">1075</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::strictGOPTarget" title='_NV_ENC_RC_PARAMS::strictGOPTarget' data-ref="_NV_ENC_RC_PARAMS::strictGOPTarget">strictGOPTarget</dfn>      :<var>1</var>;                     <i class="doc">/**&lt; [in]: Set this to 1 to minimize GOP-to-GOP rate fluctuations */</i></td></tr>
<tr><th id="1076">1076</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::aqStrength" title='_NV_ENC_RC_PARAMS::aqStrength' data-ref="_NV_ENC_RC_PARAMS::aqStrength">aqStrength</dfn>           :<var>4</var>;                     <i class="doc">/**&lt; [in]: When AQ (Spatial) is enabled (i.e. NV_ENC_RC_PARAMS::enableAQ is set), this field is used to specify AQ strength. AQ strength scale is from 1 (low) - 15 (aggressive). If not set, strength is autoselected by driver. Currently supported only with h264 */</i></td></tr>
<tr><th id="1077">1077</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::reservedBitFields" title='_NV_ENC_RC_PARAMS::reservedBitFields' data-ref="_NV_ENC_RC_PARAMS::reservedBitFields">reservedBitFields</dfn>    :<var>16</var>;                    <i class="doc">/**&lt; [in]: Reserved bitfields and must be set to 0 */</i></td></tr>
<tr><th id="1078">1078</th><td>    <a class="typedef" href="#NV_ENC_QP" title='NV_ENC_QP' data-type='struct _NV_ENC_QP' data-ref="NV_ENC_QP">NV_ENC_QP</a>                       <dfn class="decl" id="_NV_ENC_RC_PARAMS::minQP" title='_NV_ENC_RC_PARAMS::minQP' data-ref="_NV_ENC_RC_PARAMS::minQP">minQP</dfn>;                                       <i class="doc">/**&lt; [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1. */</i></td></tr>
<tr><th id="1079">1079</th><td>    <a class="typedef" href="#NV_ENC_QP" title='NV_ENC_QP' data-type='struct _NV_ENC_QP' data-ref="NV_ENC_QP">NV_ENC_QP</a>                       <dfn class="decl" id="_NV_ENC_RC_PARAMS::maxQP" title='_NV_ENC_RC_PARAMS::maxQP' data-ref="_NV_ENC_RC_PARAMS::maxQP">maxQP</dfn>;                                       <i class="doc">/**&lt; [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1. */</i></td></tr>
<tr><th id="1080">1080</th><td>    <a class="typedef" href="#NV_ENC_QP" title='NV_ENC_QP' data-type='struct _NV_ENC_QP' data-ref="NV_ENC_QP">NV_ENC_QP</a>                       <dfn class="decl" id="_NV_ENC_RC_PARAMS::initialRCQP" title='_NV_ENC_RC_PARAMS::initialRCQP' data-ref="_NV_ENC_RC_PARAMS::initialRCQP">initialRCQP</dfn>;                                 <i class="doc">/**&lt; [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1. */</i></td></tr>
<tr><th id="1081">1081</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::temporallayerIdxMask" title='_NV_ENC_RC_PARAMS::temporallayerIdxMask' data-ref="_NV_ENC_RC_PARAMS::temporallayerIdxMask">temporallayerIdxMask</dfn>;                        <i class="doc">/**&lt; [in]: Specifies the temporal layers (as a bitmask) whose QPs have changed. Valid max bitmask is [2^NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS - 1] */</i></td></tr>
<tr><th id="1082">1082</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>                         <dfn class="decl" id="_NV_ENC_RC_PARAMS::temporalLayerQP" title='_NV_ENC_RC_PARAMS::temporalLayerQP' data-ref="_NV_ENC_RC_PARAMS::temporalLayerQP">temporalLayerQP</dfn>[<var>8</var>];                          <i class="doc">/**&lt; [in]: Specifies the temporal layer QPs used for rate control. Temporal layer index is used as as the array index */</i></td></tr>
<tr><th id="1083">1083</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::targetQuality" title='_NV_ENC_RC_PARAMS::targetQuality' data-ref="_NV_ENC_RC_PARAMS::targetQuality">targetQuality</dfn>;                               <i class="doc">/**&lt; [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)  */</i></td></tr>
<tr><th id="1084">1084</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::lookaheadDepth" title='_NV_ENC_RC_PARAMS::lookaheadDepth' data-ref="_NV_ENC_RC_PARAMS::lookaheadDepth">lookaheadDepth</dfn>;                              <i class="doc">/**&lt; [in]: Maximum depth of lookahead with range 0-32 (only used if enableLookahead=1) */</i></td></tr>
<tr><th id="1085">1085</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_RC_PARAMS::reserved" title='_NV_ENC_RC_PARAMS::reserved' data-ref="_NV_ENC_RC_PARAMS::reserved">reserved</dfn>[<var>9</var>];</td></tr>
<tr><th id="1086">1086</th><td> } <dfn class="typedef" id="NV_ENC_RC_PARAMS" title='NV_ENC_RC_PARAMS' data-type='struct _NV_ENC_RC_PARAMS' data-ref="NV_ENC_RC_PARAMS">NV_ENC_RC_PARAMS</dfn>;</td></tr>
<tr><th id="1087">1087</th><td></td></tr>
<tr><th id="1088">1088</th><td><i class="doc">/** macro for constructing the version field of ::_NV_ENC_RC_PARAMS */</i></td></tr>
<tr><th id="1089">1089</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_RC_PARAMS_VER" data-ref="_M/NV_ENC_RC_PARAMS_VER">NV_ENC_RC_PARAMS_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1090">1090</th><td></td></tr>
<tr><th id="1091">1091</th><td></td></tr>
<tr><th id="1092">1092</th><td></td></tr>
<tr><th id="1093">1093</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1094">1094</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_CONFIG_H264_VUI_PARAMETERS</span></i></td></tr>
<tr><th id="1095">1095</th><td><i class="doc"> * H264 Video Usability Info parameters</i></td></tr>
<tr><th id="1096">1096</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1097">1097</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS"><a class="type" href="#_NV_ENC_CONFIG_H264_VUI_PARAMETERS" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS">_NV_ENC_CONFIG_H264_VUI_PARAMETERS</a></dfn></td></tr>
<tr><th id="1098">1098</th><td>{</td></tr>
<tr><th id="1099">1099</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfoPresentFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfoPresentFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfoPresentFlag">overscanInfoPresentFlag</dfn>;              <i class="doc">/**&lt; [in]: if set to 1 , it specifies that the overscanInfo is present */</i></td></tr>
<tr><th id="1100">1100</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfo" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfo' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::overscanInfo">overscanInfo</dfn>;                         <i class="doc">/**&lt; [in]: Specifies the overscan info(as defined in Annex E of the ITU-T Specification). */</i></td></tr>
<tr><th id="1101">1101</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoSignalTypePresentFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoSignalTypePresentFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoSignalTypePresentFlag">videoSignalTypePresentFlag</dfn>;           <i class="doc">/**&lt; [in]: If set to 1, it specifies  that the videoFormat, videoFullRangeFlag and colourDescriptionPresentFlag are present. */</i></td></tr>
<tr><th id="1102">1102</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFormat" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFormat' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFormat">videoFormat</dfn>;                          <i class="doc">/**&lt; [in]: Specifies the source video format(as defined in Annex E of the ITU-T Specification).*/</i></td></tr>
<tr><th id="1103">1103</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFullRangeFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFullRangeFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::videoFullRangeFlag">videoFullRangeFlag</dfn>;                   <i class="doc">/**&lt; [in]: Specifies the output range of the luma and chroma samples(as defined in Annex E of the ITU-T Specification). */</i></td></tr>
<tr><th id="1104">1104</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourDescriptionPresentFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourDescriptionPresentFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourDescriptionPresentFlag">colourDescriptionPresentFlag</dfn>;         <i class="doc">/**&lt; [in]: If set to 1, it specifies that the colourPrimaries, transferCharacteristics and colourMatrix are present. */</i></td></tr>
<tr><th id="1105">1105</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourPrimaries" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourPrimaries' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourPrimaries">colourPrimaries</dfn>;                      <i class="doc">/**&lt; [in]: Specifies color primaries for converting to RGB(as defined in Annex E of the ITU-T Specification) */</i></td></tr>
<tr><th id="1106">1106</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::transferCharacteristics" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::transferCharacteristics' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::transferCharacteristics">transferCharacteristics</dfn>;              <i class="doc">/**&lt; [in]: Specifies the opto-electronic transfer characteristics to use (as defined in Annex E of the ITU-T Specification) */</i></td></tr>
<tr><th id="1107">1107</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourMatrix" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourMatrix' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::colourMatrix">colourMatrix</dfn>;                         <i class="doc">/**&lt; [in]: Specifies the matrix coefficients used in deriving the luma and chroma from the RGB primaries (as defined in Annex E of the ITU-T Specification). */</i></td></tr>
<tr><th id="1108">1108</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationFlag">chromaSampleLocationFlag</dfn>;             <i class="doc">/**&lt; [in]: if set to 1 , it specifies that the chromaSampleLocationTop and chromaSampleLocationBot are present.*/</i></td></tr>
<tr><th id="1109">1109</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationTop" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationTop' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationTop">chromaSampleLocationTop</dfn>;              <i class="doc">/**&lt; [in]: Specifies the chroma sample location for top field(as defined in Annex E of the ITU-T Specification) */</i></td></tr>
<tr><th id="1110">1110</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationBot" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationBot' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::chromaSampleLocationBot">chromaSampleLocationBot</dfn>;              <i class="doc">/**&lt; [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification) */</i></td></tr>
<tr><th id="1111">1111</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::bitstreamRestrictionFlag" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::bitstreamRestrictionFlag' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::bitstreamRestrictionFlag">bitstreamRestrictionFlag</dfn>;             <i class="doc">/**&lt; [in]: if set to 1, it specifies the bitstream restriction parameters are present in the bitstream.*/</i></td></tr>
<tr><th id="1112">1112</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>    <dfn class="decl" id="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::reserved" title='_NV_ENC_CONFIG_H264_VUI_PARAMETERS::reserved' data-ref="_NV_ENC_CONFIG_H264_VUI_PARAMETERS::reserved">reserved</dfn>[<var>15</var>];</td></tr>
<tr><th id="1113">1113</th><td>}<dfn class="typedef" id="NV_ENC_CONFIG_H264_VUI_PARAMETERS" title='NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-type='struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="NV_ENC_CONFIG_H264_VUI_PARAMETERS">NV_ENC_CONFIG_H264_VUI_PARAMETERS</dfn>;</td></tr>
<tr><th id="1114">1114</th><td></td></tr>
<tr><th id="1115">1115</th><td><b>typedef</b> <a class="typedef" href="#NV_ENC_CONFIG_H264_VUI_PARAMETERS" title='NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-type='struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="NV_ENC_CONFIG_H264_VUI_PARAMETERS">NV_ENC_CONFIG_H264_VUI_PARAMETERS</a> <dfn class="typedef" id="NV_ENC_CONFIG_HEVC_VUI_PARAMETERS" title='NV_ENC_CONFIG_HEVC_VUI_PARAMETERS' data-type='NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="NV_ENC_CONFIG_HEVC_VUI_PARAMETERS">NV_ENC_CONFIG_HEVC_VUI_PARAMETERS</dfn>;</td></tr>
<tr><th id="1116">1116</th><td></td></tr>
<tr><th id="1117">1117</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1118">1118</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE</span></i></td></tr>
<tr><th id="1119">1119</th><td><i class="doc"> * External motion vector hint counts per block type.</i></td></tr>
<tr><th id="1120">1120</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1121">1121</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE"><a class="type" href="#_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE">_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE</a></dfn></td></tr>
<tr><th id="1122">1122</th><td>{</td></tr>
<tr><th id="1123">1123</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x16" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x16' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x16">numCandsPerBlk16x16</dfn>                   : <var>4</var>;   <i class="doc">/**&lt; [in]: Specifies the number of candidates per 16x16 block. */</i></td></tr>
<tr><th id="1124">1124</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x8" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x8' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk16x8">numCandsPerBlk16x8</dfn>                    : <var>4</var>;   <i class="doc">/**&lt; [in]: Specifies the number of candidates per 16x8 block. */</i></td></tr>
<tr><th id="1125">1125</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x16" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x16' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x16">numCandsPerBlk8x16</dfn>                    : <var>4</var>;   <i class="doc">/**&lt; [in]: Specifies the number of candidates per 8x16 block. */</i></td></tr>
<tr><th id="1126">1126</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x8" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x8' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::numCandsPerBlk8x8">numCandsPerBlk8x8</dfn>                     : <var>4</var>;   <i class="doc">/**&lt; [in]: Specifies the number of candidates per 8x8 block. */</i></td></tr>
<tr><th id="1127">1127</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved">reserved</dfn>                              : <var>16</var>;  <i class="doc">/**&lt; [in]: Reserved for padding. */</i></td></tr>
<tr><th id="1128">1128</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>   <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved1" title='_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved1' data-ref="_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE::reserved1">reserved1</dfn>[<var>3</var>];                                <i class="doc">/**&lt; [in]: Reserved for future use. */</i></td></tr>
<tr><th id="1129">1129</th><td>} <dfn class="typedef" id="NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE" title='NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-type='struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-ref="NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE">NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE</dfn>;</td></tr>
<tr><th id="1130">1130</th><td></td></tr>
<tr><th id="1131">1131</th><td></td></tr>
<tr><th id="1132">1132</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1133">1133</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NVENC_EXTERNAL_ME_HINT</span></i></td></tr>
<tr><th id="1134">1134</th><td><i class="doc"> * External Motion Vector hint structure.</i></td></tr>
<tr><th id="1135">1135</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1136">1136</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NVENC_EXTERNAL_ME_HINT" title='_NVENC_EXTERNAL_ME_HINT' data-ref="_NVENC_EXTERNAL_ME_HINT"><a class="type" href="#_NVENC_EXTERNAL_ME_HINT" title='_NVENC_EXTERNAL_ME_HINT' data-ref="_NVENC_EXTERNAL_ME_HINT">_NVENC_EXTERNAL_ME_HINT</a></dfn></td></tr>
<tr><th id="1137">1137</th><td>{</td></tr>
<tr><th id="1138">1138</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::mvx" title='_NVENC_EXTERNAL_ME_HINT::mvx' data-ref="_NVENC_EXTERNAL_ME_HINT::mvx">mvx</dfn>         : <var>12</var>;                        <i class="doc">/**&lt; [in]: Specifies the x component of integer pixel MV (relative to current MB) S12.0. */</i></td></tr>
<tr><th id="1139">1139</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::mvy" title='_NVENC_EXTERNAL_ME_HINT::mvy' data-ref="_NVENC_EXTERNAL_ME_HINT::mvy">mvy</dfn>         : <var>10</var>;                        <i class="doc">/**&lt; [in]: Specifies the y component of integer pixel MV (relative to current MB) S10.0 .*/</i></td></tr>
<tr><th id="1140">1140</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::refidx" title='_NVENC_EXTERNAL_ME_HINT::refidx' data-ref="_NVENC_EXTERNAL_ME_HINT::refidx">refidx</dfn>      : <var>5</var>;                         <i class="doc">/**&lt; [in]: Specifies the reference index (31=invalid). Current we support only 1 reference frame per direction for external hints, so<span class="command"> \p</span> <span class="arg">refidx</span> must be 0. */</i></td></tr>
<tr><th id="1141">1141</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::dir" title='_NVENC_EXTERNAL_ME_HINT::dir' data-ref="_NVENC_EXTERNAL_ME_HINT::dir">dir</dfn>         : <var>1</var>;                         <i class="doc">/**&lt; [in]: Specifies the direction of motion estimation . 0=L0 1=L1.*/</i></td></tr>
<tr><th id="1142">1142</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::partType" title='_NVENC_EXTERNAL_ME_HINT::partType' data-ref="_NVENC_EXTERNAL_ME_HINT::partType">partType</dfn>    : <var>2</var>;                         <i class="doc">/**&lt; [in]: Specifies the block partition type.0=16x16 1=16x8 2=8x16 3=8x8 (blocks in partition must be consecutive).*/</i></td></tr>
<tr><th id="1143">1143</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::lastofPart" title='_NVENC_EXTERNAL_ME_HINT::lastofPart' data-ref="_NVENC_EXTERNAL_ME_HINT::lastofPart">lastofPart</dfn>  : <var>1</var>;                         <i class="doc">/**&lt; [in]: Set to 1 for the last MV of (sub) partition  */</i></td></tr>
<tr><th id="1144">1144</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>    <dfn class="decl" id="_NVENC_EXTERNAL_ME_HINT::lastOfMB" title='_NVENC_EXTERNAL_ME_HINT::lastOfMB' data-ref="_NVENC_EXTERNAL_ME_HINT::lastOfMB">lastOfMB</dfn>    : <var>1</var>;                         <i class="doc">/**&lt; [in]: Set to 1 for the last MV of macroblock. */</i></td></tr>
<tr><th id="1145">1145</th><td>} <dfn class="typedef" id="NVENC_EXTERNAL_ME_HINT" title='NVENC_EXTERNAL_ME_HINT' data-type='struct _NVENC_EXTERNAL_ME_HINT' data-ref="NVENC_EXTERNAL_ME_HINT">NVENC_EXTERNAL_ME_HINT</dfn>;</td></tr>
<tr><th id="1146">1146</th><td></td></tr>
<tr><th id="1147">1147</th><td></td></tr>
<tr><th id="1148">1148</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1149">1149</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_CONFIG_H264</span></i></td></tr>
<tr><th id="1150">1150</th><td><i class="doc"> * H264 encoder configuration parameters</i></td></tr>
<tr><th id="1151">1151</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1152">1152</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CONFIG_H264" title='_NV_ENC_CONFIG_H264' data-ref="_NV_ENC_CONFIG_H264"><a class="type" href="#_NV_ENC_CONFIG_H264" title='_NV_ENC_CONFIG_H264' data-ref="_NV_ENC_CONFIG_H264">_NV_ENC_CONFIG_H264</a></dfn></td></tr>
<tr><th id="1153">1153</th><td>{</td></tr>
<tr><th id="1154">1154</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableTemporalSVC" title='_NV_ENC_CONFIG_H264::enableTemporalSVC' data-ref="_NV_ENC_CONFIG_H264::enableTemporalSVC">enableTemporalSVC</dfn>         :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable SVC temporal*/</i></td></tr>
<tr><th id="1155">1155</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableStereoMVC" title='_NV_ENC_CONFIG_H264::enableStereoMVC' data-ref="_NV_ENC_CONFIG_H264::enableStereoMVC">enableStereoMVC</dfn>           :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable stereo MVC*/</i></td></tr>
<tr><th id="1156">1156</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::hierarchicalPFrames" title='_NV_ENC_CONFIG_H264::hierarchicalPFrames' data-ref="_NV_ENC_CONFIG_H264::hierarchicalPFrames">hierarchicalPFrames</dfn>       :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable hierarchical PFrames */</i></td></tr>
<tr><th id="1157">1157</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::hierarchicalBFrames" title='_NV_ENC_CONFIG_H264::hierarchicalBFrames' data-ref="_NV_ENC_CONFIG_H264::hierarchicalBFrames">hierarchicalBFrames</dfn>       :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable hierarchical BFrames */</i></td></tr>
<tr><th id="1158">1158</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::outputBufferingPeriodSEI" title='_NV_ENC_CONFIG_H264::outputBufferingPeriodSEI' data-ref="_NV_ENC_CONFIG_H264::outputBufferingPeriodSEI">outputBufferingPeriodSEI</dfn>  :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to write SEI buffering period syntax in the bitstream */</i></td></tr>
<tr><th id="1159">1159</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::outputPictureTimingSEI" title='_NV_ENC_CONFIG_H264::outputPictureTimingSEI' data-ref="_NV_ENC_CONFIG_H264::outputPictureTimingSEI">outputPictureTimingSEI</dfn>    :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to write SEI picture timing syntax in the bitstream */</i></td></tr>
<tr><th id="1160">1160</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::outputAUD" title='_NV_ENC_CONFIG_H264::outputAUD' data-ref="_NV_ENC_CONFIG_H264::outputAUD">outputAUD</dfn>                 :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to write access unit delimiter syntax in bitstream */</i></td></tr>
<tr><th id="1161">1161</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::disableSPSPPS" title='_NV_ENC_CONFIG_H264::disableSPSPPS' data-ref="_NV_ENC_CONFIG_H264::disableSPSPPS">disableSPSPPS</dfn>             :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to disable writing of Sequence and Picture parameter info in bitstream */</i></td></tr>
<tr><th id="1162">1162</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::outputFramePackingSEI" title='_NV_ENC_CONFIG_H264::outputFramePackingSEI' data-ref="_NV_ENC_CONFIG_H264::outputFramePackingSEI">outputFramePackingSEI</dfn>     :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable writing of frame packing arrangement SEI messages to bitstream */</i></td></tr>
<tr><th id="1163">1163</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::outputRecoveryPointSEI" title='_NV_ENC_CONFIG_H264::outputRecoveryPointSEI' data-ref="_NV_ENC_CONFIG_H264::outputRecoveryPointSEI">outputRecoveryPointSEI</dfn>    :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable writing of recovery point SEI message */</i></td></tr>
<tr><th id="1164">1164</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableIntraRefresh" title='_NV_ENC_CONFIG_H264::enableIntraRefresh' data-ref="_NV_ENC_CONFIG_H264::enableIntraRefresh">enableIntraRefresh</dfn>        :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */</i></td></tr>
<tr><th id="1165">1165</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableConstrainedEncoding" title='_NV_ENC_CONFIG_H264::enableConstrainedEncoding' data-ref="_NV_ENC_CONFIG_H264::enableConstrainedEncoding">enableConstrainedEncoding</dfn> :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set this to 1 to enable constrainedFrame encoding where each slice in the constarined picture is independent of other slices</i></td></tr>
<tr><th id="1166">1166</th><td><i class="doc">                                                                               Check support for constrained encoding using ::NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING caps. */</i></td></tr>
<tr><th id="1167">1167</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::repeatSPSPPS" title='_NV_ENC_CONFIG_H264::repeatSPSPPS' data-ref="_NV_ENC_CONFIG_H264::repeatSPSPPS">repeatSPSPPS</dfn>              :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable writing of Sequence and Picture parameter for every IDR frame */</i></td></tr>
<tr><th id="1168">1168</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableVFR" title='_NV_ENC_CONFIG_H264::enableVFR' data-ref="_NV_ENC_CONFIG_H264::enableVFR">enableVFR</dfn>                 :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set to 1 to enable variable frame rate. */</i></td></tr>
<tr><th id="1169">1169</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::enableLTR" title='_NV_ENC_CONFIG_H264::enableLTR' data-ref="_NV_ENC_CONFIG_H264::enableLTR">enableLTR</dfn>                 :<var>1</var>;                          <i class="doc">/**&lt; [in]: Currently this feature is not available and must be set to 0. Set to 1 to enable LTR support and auto-mark the first */</i></td></tr>
<tr><th id="1170">1170</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::qpPrimeYZeroTransformBypassFlag" title='_NV_ENC_CONFIG_H264::qpPrimeYZeroTransformBypassFlag' data-ref="_NV_ENC_CONFIG_H264::qpPrimeYZeroTransformBypassFlag">qpPrimeYZeroTransformBypassFlag</dfn> :<var>1</var>;                    <i class="doc">/**&lt; [in]: To enable lossless encode set this to 1, set QP to 0 and RC_mode to NV_ENC_PARAMS_RC_CONSTQP and profile to HIGH_444_PREDICTIVE_PROFILE.</i></td></tr>
<tr><th id="1171">1171</th><td><i class="doc">                                                                               Check support for lossless encoding using ::NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE caps.  */</i></td></tr>
<tr><th id="1172">1172</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::useConstrainedIntraPred" title='_NV_ENC_CONFIG_H264::useConstrainedIntraPred' data-ref="_NV_ENC_CONFIG_H264::useConstrainedIntraPred">useConstrainedIntraPred</dfn>   :<var>1</var>;                          <i class="doc">/**&lt; [in]: Set 1 to enable constrained intra prediction. */</i></td></tr>
<tr><th id="1173">1173</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::reservedBitFields" title='_NV_ENC_CONFIG_H264::reservedBitFields' data-ref="_NV_ENC_CONFIG_H264::reservedBitFields">reservedBitFields</dfn>         :<var>15</var>;                         <i class="doc">/**&lt; [in]: Reserved bitfields and must be set to 0 */</i></td></tr>
<tr><th id="1174">1174</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::level" title='_NV_ENC_CONFIG_H264::level' data-ref="_NV_ENC_CONFIG_H264::level">level</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level. */</i></td></tr>
<tr><th id="1175">1175</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::idrPeriod" title='_NV_ENC_CONFIG_H264::idrPeriod' data-ref="_NV_ENC_CONFIG_H264::idrPeriod">idrPeriod</dfn>;                                             <i class="doc">/**&lt; [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically. */</i></td></tr>
<tr><th id="1176">1176</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::separateColourPlaneFlag" title='_NV_ENC_CONFIG_H264::separateColourPlaneFlag' data-ref="_NV_ENC_CONFIG_H264::separateColourPlaneFlag">separateColourPlaneFlag</dfn>;                               <i class="doc">/**&lt; [in]: Set to 1 to enable 4:4:4 separate colour planes */</i></td></tr>
<tr><th id="1177">1177</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::disableDeblockingFilterIDC" title='_NV_ENC_CONFIG_H264::disableDeblockingFilterIDC' data-ref="_NV_ENC_CONFIG_H264::disableDeblockingFilterIDC">disableDeblockingFilterIDC</dfn>;                            <i class="doc">/**&lt; [in]: Specifies the deblocking filter mode. Permissible value range: [0,2] */</i></td></tr>
<tr><th id="1178">1178</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::numTemporalLayers" title='_NV_ENC_CONFIG_H264::numTemporalLayers' data-ref="_NV_ENC_CONFIG_H264::numTemporalLayers">numTemporalLayers</dfn>;                                     <i class="doc">/**&lt; [in]: Specifies max temporal layers to be used for hierarchical coding. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS] */</i></td></tr>
<tr><th id="1179">1179</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::spsId" title='_NV_ENC_CONFIG_H264::spsId' data-ref="_NV_ENC_CONFIG_H264::spsId">spsId</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the SPS id of the sequence header. Currently reserved and must be set to 0. */</i></td></tr>
<tr><th id="1180">1180</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::ppsId" title='_NV_ENC_CONFIG_H264::ppsId' data-ref="_NV_ENC_CONFIG_H264::ppsId">ppsId</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the PPS id of the picture header. Currently reserved and must be set to 0. */</i></td></tr>
<tr><th id="1181">1181</th><td>    <a class="typedef" href="#NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE" title='NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-type='enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE' data-ref="NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE">NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE</a> <dfn class="decl" id="_NV_ENC_CONFIG_H264::adaptiveTransformMode" title='_NV_ENC_CONFIG_H264::adaptiveTransformMode' data-ref="_NV_ENC_CONFIG_H264::adaptiveTransformMode">adaptiveTransformMode</dfn>;      <i class="doc">/**&lt; [in]: Specifies the AdaptiveTransform Mode. Check support for AdaptiveTransform mode using ::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM caps. */</i></td></tr>
<tr><th id="1182">1182</th><td>    <a class="typedef" href="#NV_ENC_H264_FMO_MODE" title='NV_ENC_H264_FMO_MODE' data-type='enum _NV_ENC_H264_FMO_MODE' data-ref="NV_ENC_H264_FMO_MODE">NV_ENC_H264_FMO_MODE</a>                <dfn class="decl" id="_NV_ENC_CONFIG_H264::fmoMode" title='_NV_ENC_CONFIG_H264::fmoMode' data-ref="_NV_ENC_CONFIG_H264::fmoMode">fmoMode</dfn>;                    <i class="doc">/**&lt; [in]: Specified the FMO Mode. Check support for FMO using ::NV_ENC_CAPS_SUPPORT_FMO caps. */</i></td></tr>
<tr><th id="1183">1183</th><td>    <a class="typedef" href="#NV_ENC_H264_BDIRECT_MODE" title='NV_ENC_H264_BDIRECT_MODE' data-type='enum _NV_ENC_H264_BDIRECT_MODE' data-ref="NV_ENC_H264_BDIRECT_MODE">NV_ENC_H264_BDIRECT_MODE</a>            <dfn class="decl" id="_NV_ENC_CONFIG_H264::bdirectMode" title='_NV_ENC_CONFIG_H264::bdirectMode' data-ref="_NV_ENC_CONFIG_H264::bdirectMode">bdirectMode</dfn>;                <i class="doc">/**&lt; [in]: Specifies the BDirect mode. Check support for BDirect mode using ::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE caps.*/</i></td></tr>
<tr><th id="1184">1184</th><td>    <a class="typedef" href="#NV_ENC_H264_ENTROPY_CODING_MODE" title='NV_ENC_H264_ENTROPY_CODING_MODE' data-type='enum _NV_ENC_H264_ENTROPY_CODING_MODE' data-ref="NV_ENC_H264_ENTROPY_CODING_MODE">NV_ENC_H264_ENTROPY_CODING_MODE</a>     <dfn class="decl" id="_NV_ENC_CONFIG_H264::entropyCodingMode" title='_NV_ENC_CONFIG_H264::entropyCodingMode' data-ref="_NV_ENC_CONFIG_H264::entropyCodingMode">entropyCodingMode</dfn>;          <i class="doc">/**&lt; [in]: Specifies the entropy coding mode. Check support for CABAC mode using ::NV_ENC_CAPS_SUPPORT_CABAC caps. */</i></td></tr>
<tr><th id="1185">1185</th><td>    <a class="typedef" href="#NV_ENC_STEREO_PACKING_MODE" title='NV_ENC_STEREO_PACKING_MODE' data-type='enum _NV_ENC_STEREO_PACKING_MODE' data-ref="NV_ENC_STEREO_PACKING_MODE">NV_ENC_STEREO_PACKING_MODE</a>          <dfn class="decl" id="_NV_ENC_CONFIG_H264::stereoMode" title='_NV_ENC_CONFIG_H264::stereoMode' data-ref="_NV_ENC_CONFIG_H264::stereoMode">stereoMode</dfn>;                 <i class="doc">/**&lt; [in]: Specifies the stereo frame packing mode which is to be signalled in frame packing arrangement SEI */</i></td></tr>
<tr><th id="1186">1186</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::intraRefreshPeriod" title='_NV_ENC_CONFIG_H264::intraRefreshPeriod' data-ref="_NV_ENC_CONFIG_H264::intraRefreshPeriod">intraRefreshPeriod</dfn>;         <i class="doc">/**&lt; [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.</i></td></tr>
<tr><th id="1187">1187</th><td><i class="doc">                                                                               Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH. */</i></td></tr>
<tr><th id="1188">1188</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::intraRefreshCnt" title='_NV_ENC_CONFIG_H264::intraRefreshCnt' data-ref="_NV_ENC_CONFIG_H264::intraRefreshCnt">intraRefreshCnt</dfn>;            <i class="doc">/**&lt; [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod */</i></td></tr>
<tr><th id="1189">1189</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::maxNumRefFrames" title='_NV_ENC_CONFIG_H264::maxNumRefFrames' data-ref="_NV_ENC_CONFIG_H264::maxNumRefFrames">maxNumRefFrames</dfn>;            <i class="doc">/**&lt; [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default dpb size.</i></td></tr>
<tr><th id="1190">1190</th><td><i class="doc">                                                                               The low latency application which wants to invalidate reference frame as an error resilience tool</i></td></tr>
<tr><th id="1191">1191</th><td><i class="doc">                                                                               is recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent</i></td></tr>
<tr><th id="1192">1192</th><td><i class="doc">                                                                               frames are invalidated. */</i></td></tr>
<tr><th id="1193">1193</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::sliceMode" title='_NV_ENC_CONFIG_H264::sliceMode' data-ref="_NV_ENC_CONFIG_H264::sliceMode">sliceMode</dfn>;                  <i class="doc">/**&lt; [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices</i></td></tr>
<tr><th id="1194">1194</th><td><i class="doc">                                                                               sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture</i></td></tr>
<tr><th id="1195">1195</th><td><i class="doc">                                                                               When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting</i></td></tr>
<tr><th id="1196">1196</th><td><i class="doc">                                                                               When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice */</i></td></tr>
<tr><th id="1197">1197</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::sliceModeData" title='_NV_ENC_CONFIG_H264::sliceModeData' data-ref="_NV_ENC_CONFIG_H264::sliceModeData">sliceModeData</dfn>;              <i class="doc">/**&lt; [in]: Specifies the parameter needed for sliceMode. For:</i></td></tr>
<tr><th id="1198">1198</th><td><i class="doc">                                                                               sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)</i></td></tr>
<tr><th id="1199">1199</th><td><i class="doc">                                                                               sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)</i></td></tr>
<tr><th id="1200">1200</th><td><i class="doc">                                                                               sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)</i></td></tr>
<tr><th id="1201">1201</th><td><i class="doc">                                                                               sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally */</i></td></tr>
<tr><th id="1202">1202</th><td>    <a class="typedef" href="#NV_ENC_CONFIG_H264_VUI_PARAMETERS" title='NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-type='struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="NV_ENC_CONFIG_H264_VUI_PARAMETERS">NV_ENC_CONFIG_H264_VUI_PARAMETERS</a>   <dfn class="decl" id="_NV_ENC_CONFIG_H264::h264VUIParameters" title='_NV_ENC_CONFIG_H264::h264VUIParameters' data-ref="_NV_ENC_CONFIG_H264::h264VUIParameters">h264VUIParameters</dfn>;          <i class="doc">/**&lt; [in]: Specifies the H264 video usability info pamameters */</i></td></tr>
<tr><th id="1203">1203</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::ltrNumFrames" title='_NV_ENC_CONFIG_H264::ltrNumFrames' data-ref="_NV_ENC_CONFIG_H264::ltrNumFrames">ltrNumFrames</dfn>;               <i class="doc">/**&lt; [in]: Specifies the number of LTR frames used.</i></td></tr>
<tr><th id="1204">1204</th><td><i class="doc">                                                                               If ltrTrustMode=1, encoder will mark first numLTRFrames base layer reference frames within each IDR interval as LTR.</i></td></tr>
<tr><th id="1205">1205</th><td><i class="doc">                                                                               If ltrMarkFrame=1, ltrNumFrames specifies maximum number of ltr frames in DPB.</i></td></tr>
<tr><th id="1206">1206</th><td><i class="doc">                                                                               If ltrNumFrames value is more that DPB size(maxNumRefFrames) encoder will take decision on its own. */</i></td></tr>
<tr><th id="1207">1207</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::ltrTrustMode" title='_NV_ENC_CONFIG_H264::ltrTrustMode' data-ref="_NV_ENC_CONFIG_H264::ltrTrustMode">ltrTrustMode</dfn>;               <i class="doc">/**&lt; [in]: Specifies the LTR operating mode.</i></td></tr>
<tr><th id="1208">1208</th><td><i class="doc">                                                                               Set to 0 to disallow encoding using LTR frames until later specified.</i></td></tr>
<tr><th id="1209">1209</th><td><i class="doc">                                                                               Set to 1 to allow encoding using LTR frames unless later invalidated.*/</i></td></tr>
<tr><th id="1210">1210</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::chromaFormatIDC" title='_NV_ENC_CONFIG_H264::chromaFormatIDC' data-ref="_NV_ENC_CONFIG_H264::chromaFormatIDC">chromaFormatIDC</dfn>;            <i class="doc">/**&lt; [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.</i></td></tr>
<tr><th id="1211">1211</th><td><i class="doc">                                                                               Check support for YUV444 encoding using ::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE caps.*/</i></td></tr>
<tr><th id="1212">1212</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::maxTemporalLayers" title='_NV_ENC_CONFIG_H264::maxTemporalLayers' data-ref="_NV_ENC_CONFIG_H264::maxTemporalLayers">maxTemporalLayers</dfn>;          <i class="doc">/**&lt; [in]: Specifies the max temporal layer used for hierarchical coding. */</i></td></tr>
<tr><th id="1213">1213</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                            <dfn class="decl" id="_NV_ENC_CONFIG_H264::reserved1" title='_NV_ENC_CONFIG_H264::reserved1' data-ref="_NV_ENC_CONFIG_H264::reserved1">reserved1</dfn>[<var>270</var>];             <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1214">1214</th><td>    <em>void</em>*                               <dfn class="decl" id="_NV_ENC_CONFIG_H264::reserved2" title='_NV_ENC_CONFIG_H264::reserved2' data-ref="_NV_ENC_CONFIG_H264::reserved2">reserved2</dfn>[<var>64</var>];              <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1215">1215</th><td>} <dfn class="typedef" id="NV_ENC_CONFIG_H264" title='NV_ENC_CONFIG_H264' data-type='struct _NV_ENC_CONFIG_H264' data-ref="NV_ENC_CONFIG_H264">NV_ENC_CONFIG_H264</dfn>;</td></tr>
<tr><th id="1216">1216</th><td></td></tr>
<tr><th id="1217">1217</th><td></td></tr>
<tr><th id="1218">1218</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1219">1219</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_CONFIG_HEVC</span></i></td></tr>
<tr><th id="1220">1220</th><td><i class="doc"> * HEVC encoder configuration parameters to be set during initialization.</i></td></tr>
<tr><th id="1221">1221</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1222">1222</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CONFIG_HEVC" title='_NV_ENC_CONFIG_HEVC' data-ref="_NV_ENC_CONFIG_HEVC"><a class="type" href="#_NV_ENC_CONFIG_HEVC" title='_NV_ENC_CONFIG_HEVC' data-ref="_NV_ENC_CONFIG_HEVC">_NV_ENC_CONFIG_HEVC</a></dfn></td></tr>
<tr><th id="1223">1223</th><td>{</td></tr>
<tr><th id="1224">1224</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::level" title='_NV_ENC_CONFIG_HEVC::level' data-ref="_NV_ENC_CONFIG_HEVC::level">level</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the level of the encoded bitstream.*/</i></td></tr>
<tr><th id="1225">1225</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::tier" title='_NV_ENC_CONFIG_HEVC::tier' data-ref="_NV_ENC_CONFIG_HEVC::tier">tier</dfn>;                                                  <i class="doc">/**&lt; [in]: Specifies the level tier of the encoded bitstream.*/</i></td></tr>
<tr><th id="1226">1226</th><td>    <a class="typedef" href="#NV_ENC_HEVC_CUSIZE" title='NV_ENC_HEVC_CUSIZE' data-type='enum _NV_ENC_HEVC_CUSIZE' data-ref="NV_ENC_HEVC_CUSIZE">NV_ENC_HEVC_CUSIZE</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::minCUSize" title='_NV_ENC_CONFIG_HEVC::minCUSize' data-ref="_NV_ENC_CONFIG_HEVC::minCUSize">minCUSize</dfn>;                                   <i class="doc">/**&lt; [in]: Specifies the minimum size of luma coding unit.*/</i></td></tr>
<tr><th id="1227">1227</th><td>    <a class="typedef" href="#NV_ENC_HEVC_CUSIZE" title='NV_ENC_HEVC_CUSIZE' data-type='enum _NV_ENC_HEVC_CUSIZE' data-ref="NV_ENC_HEVC_CUSIZE">NV_ENC_HEVC_CUSIZE</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::maxCUSize" title='_NV_ENC_CONFIG_HEVC::maxCUSize' data-ref="_NV_ENC_CONFIG_HEVC::maxCUSize">maxCUSize</dfn>;                                   <i class="doc">/**&lt; [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32.*/</i></td></tr>
<tr><th id="1228">1228</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::useConstrainedIntraPred" title='_NV_ENC_CONFIG_HEVC::useConstrainedIntraPred' data-ref="_NV_ENC_CONFIG_HEVC::useConstrainedIntraPred">useConstrainedIntraPred</dfn>               :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to enable constrained intra prediction. */</i></td></tr>
<tr><th id="1229">1229</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::disableDeblockAcrossSliceBoundary" title='_NV_ENC_CONFIG_HEVC::disableDeblockAcrossSliceBoundary' data-ref="_NV_ENC_CONFIG_HEVC::disableDeblockAcrossSliceBoundary">disableDeblockAcrossSliceBoundary</dfn>     :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to disable in loop filtering across slice boundary.*/</i></td></tr>
<tr><th id="1230">1230</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::outputBufferingPeriodSEI" title='_NV_ENC_CONFIG_HEVC::outputBufferingPeriodSEI' data-ref="_NV_ENC_CONFIG_HEVC::outputBufferingPeriodSEI">outputBufferingPeriodSEI</dfn>              :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to write SEI buffering period syntax in the bitstream */</i></td></tr>
<tr><th id="1231">1231</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::outputPictureTimingSEI" title='_NV_ENC_CONFIG_HEVC::outputPictureTimingSEI' data-ref="_NV_ENC_CONFIG_HEVC::outputPictureTimingSEI">outputPictureTimingSEI</dfn>                :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to write SEI picture timing syntax in the bitstream */</i></td></tr>
<tr><th id="1232">1232</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::outputAUD" title='_NV_ENC_CONFIG_HEVC::outputAUD' data-ref="_NV_ENC_CONFIG_HEVC::outputAUD">outputAUD</dfn>                             :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to write Access Unit Delimiter syntax. */</i></td></tr>
<tr><th id="1233">1233</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::enableLTR" title='_NV_ENC_CONFIG_HEVC::enableLTR' data-ref="_NV_ENC_CONFIG_HEVC::enableLTR">enableLTR</dfn>                             :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to enable use of long term reference pictures for inter prediction. */</i></td></tr>
<tr><th id="1234">1234</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::disableSPSPPS" title='_NV_ENC_CONFIG_HEVC::disableSPSPPS' data-ref="_NV_ENC_CONFIG_HEVC::disableSPSPPS">disableSPSPPS</dfn>                         :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to disable VPS,SPS and PPS signalling in the bitstream. */</i></td></tr>
<tr><th id="1235">1235</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::repeatSPSPPS" title='_NV_ENC_CONFIG_HEVC::repeatSPSPPS' data-ref="_NV_ENC_CONFIG_HEVC::repeatSPSPPS">repeatSPSPPS</dfn>                          :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to output VPS,SPS and PPS for every IDR frame.*/</i></td></tr>
<tr><th id="1236">1236</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::enableIntraRefresh" title='_NV_ENC_CONFIG_HEVC::enableIntraRefresh' data-ref="_NV_ENC_CONFIG_HEVC::enableIntraRefresh">enableIntraRefresh</dfn>                    :<var>1</var>;              <i class="doc">/**&lt; [in]: Set 1 to enable gradual decoder refresh or intra refresh. If the GOP structure uses B frames this will be ignored */</i></td></tr>
<tr><th id="1237">1237</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::chromaFormatIDC" title='_NV_ENC_CONFIG_HEVC::chromaFormatIDC' data-ref="_NV_ENC_CONFIG_HEVC::chromaFormatIDC">chromaFormatIDC</dfn>                       :<var>2</var>;              <i class="doc">/**&lt; [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.*/</i></td></tr>
<tr><th id="1238">1238</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::pixelBitDepthMinus8" title='_NV_ENC_CONFIG_HEVC::pixelBitDepthMinus8' data-ref="_NV_ENC_CONFIG_HEVC::pixelBitDepthMinus8">pixelBitDepthMinus8</dfn>                   :<var>3</var>;              <i class="doc">/**&lt; [in]: Specifies pixel bit depth minus 8. Should be set to 0 for 8 bit input, 2 for 10 bit input.*/</i></td></tr>
<tr><th id="1239">1239</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::reserved" title='_NV_ENC_CONFIG_HEVC::reserved' data-ref="_NV_ENC_CONFIG_HEVC::reserved">reserved</dfn>                              :<var>18</var>;             <i class="doc">/**&lt; [in]: Reserved bitfields.*/</i></td></tr>
<tr><th id="1240">1240</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::idrPeriod" title='_NV_ENC_CONFIG_HEVC::idrPeriod' data-ref="_NV_ENC_CONFIG_HEVC::idrPeriod">idrPeriod</dfn>;                                             <i class="doc">/**&lt; [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically. */</i></td></tr>
<tr><th id="1241">1241</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::intraRefreshPeriod" title='_NV_ENC_CONFIG_HEVC::intraRefreshPeriod' data-ref="_NV_ENC_CONFIG_HEVC::intraRefreshPeriod">intraRefreshPeriod</dfn>;                                    <i class="doc">/**&lt; [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.</i></td></tr>
<tr><th id="1242">1242</th><td><i class="doc">                                                                    Will be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH. */</i></td></tr>
<tr><th id="1243">1243</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::intraRefreshCnt" title='_NV_ENC_CONFIG_HEVC::intraRefreshCnt' data-ref="_NV_ENC_CONFIG_HEVC::intraRefreshCnt">intraRefreshCnt</dfn>;                                       <i class="doc">/**&lt; [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod */</i></td></tr>
<tr><th id="1244">1244</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::maxNumRefFramesInDPB" title='_NV_ENC_CONFIG_HEVC::maxNumRefFramesInDPB' data-ref="_NV_ENC_CONFIG_HEVC::maxNumRefFramesInDPB">maxNumRefFramesInDPB</dfn>;                                  <i class="doc">/**&lt; [in]: Specifies the maximum number of references frames in the DPB.*/</i></td></tr>
<tr><th id="1245">1245</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::ltrNumFrames" title='_NV_ENC_CONFIG_HEVC::ltrNumFrames' data-ref="_NV_ENC_CONFIG_HEVC::ltrNumFrames">ltrNumFrames</dfn>;                                          <i class="doc">/**&lt; [in]: Specifies the number of LTR frames used.</i></td></tr>
<tr><th id="1246">1246</th><td><i class="doc">                                                                               If ltrTrustMode=1, encoder will mark first numLTRFrames base layer reference frames within each IDR interval as LTR.</i></td></tr>
<tr><th id="1247">1247</th><td><i class="doc">                                                                               If ltrMarkFrame=1, ltrNumFrames specifies maximum number of ltr frames in DPB.</i></td></tr>
<tr><th id="1248">1248</th><td><i class="doc">                                                                               If ltrNumFrames value is more that DPB size(maxNumRefFramesInDPB) encoder will take decision on its own. */</i></td></tr>
<tr><th id="1249">1249</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::vpsId" title='_NV_ENC_CONFIG_HEVC::vpsId' data-ref="_NV_ENC_CONFIG_HEVC::vpsId">vpsId</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the VPS id of the video parameter set. Currently reserved and must be set to 0. */</i></td></tr>
<tr><th id="1250">1250</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::spsId" title='_NV_ENC_CONFIG_HEVC::spsId' data-ref="_NV_ENC_CONFIG_HEVC::spsId">spsId</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the SPS id of the sequence header. Currently reserved and must be set to 0. */</i></td></tr>
<tr><th id="1251">1251</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::ppsId" title='_NV_ENC_CONFIG_HEVC::ppsId' data-ref="_NV_ENC_CONFIG_HEVC::ppsId">ppsId</dfn>;                                                 <i class="doc">/**&lt; [in]: Specifies the PPS id of the picture header. Currently reserved and must be set to 0. */</i></td></tr>
<tr><th id="1252">1252</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::sliceMode" title='_NV_ENC_CONFIG_HEVC::sliceMode' data-ref="_NV_ENC_CONFIG_HEVC::sliceMode">sliceMode</dfn>;                                             <i class="doc">/**&lt; [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices</i></td></tr>
<tr><th id="1253">1253</th><td><i class="doc">                                                                                sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture</i></td></tr>
<tr><th id="1254">1254</th><td><i class="doc">                                                                                When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice */</i></td></tr>
<tr><th id="1255">1255</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::sliceModeData" title='_NV_ENC_CONFIG_HEVC::sliceModeData' data-ref="_NV_ENC_CONFIG_HEVC::sliceModeData">sliceModeData</dfn>;                                         <i class="doc">/**&lt; [in]: Specifies the parameter needed for sliceMode. For:</i></td></tr>
<tr><th id="1256">1256</th><td><i class="doc">                                                                                sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)</i></td></tr>
<tr><th id="1257">1257</th><td><i class="doc">                                                                                sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)</i></td></tr>
<tr><th id="1258">1258</th><td><i class="doc">                                                                                sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)</i></td></tr>
<tr><th id="1259">1259</th><td><i class="doc">                                                                                sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally */</i></td></tr>
<tr><th id="1260">1260</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::maxTemporalLayersMinus1" title='_NV_ENC_CONFIG_HEVC::maxTemporalLayersMinus1' data-ref="_NV_ENC_CONFIG_HEVC::maxTemporalLayersMinus1">maxTemporalLayersMinus1</dfn>;                               <i class="doc">/**&lt; [in]: Specifies the max temporal layer used for hierarchical coding. */</i></td></tr>
<tr><th id="1261">1261</th><td>    <a class="typedef" href="#NV_ENC_CONFIG_HEVC_VUI_PARAMETERS" title='NV_ENC_CONFIG_HEVC_VUI_PARAMETERS' data-type='NV_ENC_CONFIG_H264_VUI_PARAMETERS' data-ref="NV_ENC_CONFIG_HEVC_VUI_PARAMETERS">NV_ENC_CONFIG_HEVC_VUI_PARAMETERS</a>   <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::hevcVUIParameters" title='_NV_ENC_CONFIG_HEVC::hevcVUIParameters' data-ref="_NV_ENC_CONFIG_HEVC::hevcVUIParameters">hevcVUIParameters</dfn>;          <i class="doc">/**&lt; [in]: Specifies the HEVC video usability info pamameters */</i></td></tr>
<tr><th id="1262">1262</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::ltrTrustMode" title='_NV_ENC_CONFIG_HEVC::ltrTrustMode' data-ref="_NV_ENC_CONFIG_HEVC::ltrTrustMode">ltrTrustMode</dfn>;                                          <i class="doc">/**&lt; [in]: Specifies the LTR operating mode.</i></td></tr>
<tr><th id="1263">1263</th><td><i class="doc">                                                                               Set to 0 to disallow encoding using LTR frames until later specified.</i></td></tr>
<tr><th id="1264">1264</th><td><i class="doc">                                                                               Set to 1 to allow encoding using LTR frames unless later invalidated.*/</i></td></tr>
<tr><th id="1265">1265</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::reserved1" title='_NV_ENC_CONFIG_HEVC::reserved1' data-ref="_NV_ENC_CONFIG_HEVC::reserved1">reserved1</dfn>[<var>217</var>];                                        <i class="doc">/**&lt; [in]: Reserved and must be set to 0.*/</i></td></tr>
<tr><th id="1266">1266</th><td>    <em>void</em>*    <dfn class="decl" id="_NV_ENC_CONFIG_HEVC::reserved2" title='_NV_ENC_CONFIG_HEVC::reserved2' data-ref="_NV_ENC_CONFIG_HEVC::reserved2">reserved2</dfn>[<var>64</var>];                                         <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1267">1267</th><td>} <dfn class="typedef" id="NV_ENC_CONFIG_HEVC" title='NV_ENC_CONFIG_HEVC' data-type='struct _NV_ENC_CONFIG_HEVC' data-ref="NV_ENC_CONFIG_HEVC">NV_ENC_CONFIG_HEVC</dfn>;</td></tr>
<tr><th id="1268">1268</th><td></td></tr>
<tr><th id="1269">1269</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1270">1270</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_CODEC_CONFIG</span></i></td></tr>
<tr><th id="1271">1271</th><td><i class="doc"> * Codec-specific encoder configuration parameters to be set during initialization.</i></td></tr>
<tr><th id="1272">1272</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1273">1273</th><td><b>typedef</b> <b>union</b> <dfn class="type def" id="_NV_ENC_CODEC_CONFIG" title='_NV_ENC_CODEC_CONFIG' data-ref="_NV_ENC_CODEC_CONFIG"><a class="type" href="#_NV_ENC_CODEC_CONFIG" title='_NV_ENC_CODEC_CONFIG' data-ref="_NV_ENC_CODEC_CONFIG">_NV_ENC_CODEC_CONFIG</a></dfn></td></tr>
<tr><th id="1274">1274</th><td>{</td></tr>
<tr><th id="1275">1275</th><td>    <a class="typedef" href="#NV_ENC_CONFIG_H264" title='NV_ENC_CONFIG_H264' data-type='struct _NV_ENC_CONFIG_H264' data-ref="NV_ENC_CONFIG_H264">NV_ENC_CONFIG_H264</a>      <dfn class="decl" id="_NV_ENC_CODEC_CONFIG::h264Config" title='_NV_ENC_CODEC_CONFIG::h264Config' data-ref="_NV_ENC_CODEC_CONFIG::h264Config">h264Config</dfn>;                  <i class="doc">/**&lt; [in]: Specifies the H.264-specific encoder configuration. */</i></td></tr>
<tr><th id="1276">1276</th><td>    <a class="typedef" href="#NV_ENC_CONFIG_HEVC" title='NV_ENC_CONFIG_HEVC' data-type='struct _NV_ENC_CONFIG_HEVC' data-ref="NV_ENC_CONFIG_HEVC">NV_ENC_CONFIG_HEVC</a>      <dfn class="decl" id="_NV_ENC_CODEC_CONFIG::hevcConfig" title='_NV_ENC_CODEC_CONFIG::hevcConfig' data-ref="_NV_ENC_CODEC_CONFIG::hevcConfig">hevcConfig</dfn>;                  <i class="doc">/**&lt; [in]: Specifies the HEVC-specific encoder configuration. */</i></td></tr>
<tr><th id="1277">1277</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_CODEC_CONFIG::reserved" title='_NV_ENC_CODEC_CONFIG::reserved' data-ref="_NV_ENC_CODEC_CONFIG::reserved">reserved</dfn>[<var>256</var>];               <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1278">1278</th><td>} <dfn class="typedef" id="NV_ENC_CODEC_CONFIG" title='NV_ENC_CODEC_CONFIG' data-type='union _NV_ENC_CODEC_CONFIG' data-ref="NV_ENC_CODEC_CONFIG">NV_ENC_CODEC_CONFIG</dfn>;</td></tr>
<tr><th id="1279">1279</th><td></td></tr>
<tr><th id="1280">1280</th><td></td></tr>
<tr><th id="1281">1281</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1282">1282</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_CONFIG</span></i></td></tr>
<tr><th id="1283">1283</th><td><i class="doc"> * Encoder configuration parameters to be set during initialization.</i></td></tr>
<tr><th id="1284">1284</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1285">1285</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_CONFIG" title='_NV_ENC_CONFIG' data-ref="_NV_ENC_CONFIG"><a class="type" href="#_NV_ENC_CONFIG" title='_NV_ENC_CONFIG' data-ref="_NV_ENC_CONFIG">_NV_ENC_CONFIG</a></dfn></td></tr>
<tr><th id="1286">1286</th><td>{</td></tr>
<tr><th id="1287">1287</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_CONFIG::version" title='_NV_ENC_CONFIG::version' data-ref="_NV_ENC_CONFIG::version">version</dfn>;                                     <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_CONFIG_VER. */</i></td></tr>
<tr><th id="1288">1288</th><td>    <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>                            <dfn class="decl" id="_NV_ENC_CONFIG::profileGUID" title='_NV_ENC_CONFIG::profileGUID' data-ref="_NV_ENC_CONFIG::profileGUID">profileGUID</dfn>;                                 <i class="doc">/**&lt; [in]: Specifies the codec profile guid. If client specifies<span class="command"> \p</span> <span class="arg">NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID</span> the NvEncodeAPI interface will select the appropriate codec profile. */</i></td></tr>
<tr><th id="1289">1289</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_CONFIG::gopLength" title='_NV_ENC_CONFIG::gopLength' data-ref="_NV_ENC_CONFIG::gopLength">gopLength</dfn>;                                   <i class="doc">/**&lt; [in]: Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically. */</i></td></tr>
<tr><th id="1290">1290</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>                         <dfn class="decl" id="_NV_ENC_CONFIG::frameIntervalP" title='_NV_ENC_CONFIG::frameIntervalP' data-ref="_NV_ENC_CONFIG::frameIntervalP">frameIntervalP</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the GOP pattern as follows:<span class="command"> \p</span> <span class="arg">frameIntervalP</span> = 0: I, 1: IPP, 2: IBP, 3: IBBP  If goplength is set to NVENC_INFINITE_GOPLENGTH<span class="command"> \p</span> <span class="arg">frameIntervalP</span> should be set to 1. */</i></td></tr>
<tr><th id="1291">1291</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_CONFIG::monoChromeEncoding" title='_NV_ENC_CONFIG::monoChromeEncoding' data-ref="_NV_ENC_CONFIG::monoChromeEncoding">monoChromeEncoding</dfn>;                          <i class="doc">/**&lt; [in]: Set this to 1 to enable monochrome encoding for this session. */</i></td></tr>
<tr><th id="1292">1292</th><td>    <a class="typedef" href="#NV_ENC_PARAMS_FRAME_FIELD_MODE" title='NV_ENC_PARAMS_FRAME_FIELD_MODE' data-type='enum _NV_ENC_PARAMS_FRAME_FIELD_MODE' data-ref="NV_ENC_PARAMS_FRAME_FIELD_MODE">NV_ENC_PARAMS_FRAME_FIELD_MODE</a>  <dfn class="decl" id="_NV_ENC_CONFIG::frameFieldMode" title='_NV_ENC_CONFIG::frameFieldMode' data-ref="_NV_ENC_CONFIG::frameFieldMode">frameFieldMode</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the frame/field mode.</i></td></tr>
<tr><th id="1293">1293</th><td><i class="doc">                                                                                            Check support for field encoding using ::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING caps.</i></td></tr>
<tr><th id="1294">1294</th><td><i class="doc">                                                                                            Using a frameFieldMode other than NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME for RGB input is not supported. */</i></td></tr>
<tr><th id="1295">1295</th><td>    <a class="typedef" href="#NV_ENC_MV_PRECISION" title='NV_ENC_MV_PRECISION' data-type='enum _NV_ENC_MV_PRECISION' data-ref="NV_ENC_MV_PRECISION">NV_ENC_MV_PRECISION</a>             <dfn class="decl" id="_NV_ENC_CONFIG::mvPrecision" title='_NV_ENC_CONFIG::mvPrecision' data-ref="_NV_ENC_CONFIG::mvPrecision">mvPrecision</dfn>;                                 <i class="doc">/**&lt; [in]: Specifies the desired motion vector prediction precision. */</i></td></tr>
<tr><th id="1296">1296</th><td>    <a class="typedef" href="#NV_ENC_RC_PARAMS" title='NV_ENC_RC_PARAMS' data-type='struct _NV_ENC_RC_PARAMS' data-ref="NV_ENC_RC_PARAMS">NV_ENC_RC_PARAMS</a>                <dfn class="decl" id="_NV_ENC_CONFIG::rcParams" title='_NV_ENC_CONFIG::rcParams' data-ref="_NV_ENC_CONFIG::rcParams">rcParams</dfn>;                                    <i class="doc">/**&lt; [in]: Specifies the rate control parameters for the current encoding session. */</i></td></tr>
<tr><th id="1297">1297</th><td>    <a class="typedef" href="#NV_ENC_CODEC_CONFIG" title='NV_ENC_CODEC_CONFIG' data-type='union _NV_ENC_CODEC_CONFIG' data-ref="NV_ENC_CODEC_CONFIG">NV_ENC_CODEC_CONFIG</a>             <dfn class="decl" id="_NV_ENC_CONFIG::encodeCodecConfig" title='_NV_ENC_CONFIG::encodeCodecConfig' data-ref="_NV_ENC_CONFIG::encodeCodecConfig">encodeCodecConfig</dfn>;                           <i class="doc">/**&lt; [in]: Specifies the codec specific config parameters through this union. */</i></td></tr>
<tr><th id="1298">1298</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENC_CONFIG::reserved" title='_NV_ENC_CONFIG::reserved' data-ref="_NV_ENC_CONFIG::reserved">reserved</dfn> [<var>278</var>];                              <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1299">1299</th><td>    <em>void</em>*                           <dfn class="decl" id="_NV_ENC_CONFIG::reserved2" title='_NV_ENC_CONFIG::reserved2' data-ref="_NV_ENC_CONFIG::reserved2">reserved2</dfn>[<var>64</var>];                               <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1300">1300</th><td>} <dfn class="typedef" id="NV_ENC_CONFIG" title='NV_ENC_CONFIG' data-type='struct _NV_ENC_CONFIG' data-ref="NV_ENC_CONFIG">NV_ENC_CONFIG</dfn>;</td></tr>
<tr><th id="1301">1301</th><td></td></tr>
<tr><th id="1302">1302</th><td><i class="doc">/** macro for constructing the version field of ::_NV_ENC_CONFIG */</i></td></tr>
<tr><th id="1303">1303</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_CONFIG_VER" data-ref="_M/NV_ENC_CONFIG_VER">NV_ENC_CONFIG_VER</dfn> (NVENCAPI_STRUCT_VERSION(6) | ( 1&lt;&lt;31 ))</u></td></tr>
<tr><th id="1304">1304</th><td></td></tr>
<tr><th id="1305">1305</th><td></td></tr>
<tr><th id="1306">1306</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1307">1307</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_INITIALIZE_PARAMS</span></i></td></tr>
<tr><th id="1308">1308</th><td><i class="doc"> * Encode Session Initialization parameters.</i></td></tr>
<tr><th id="1309">1309</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1310">1310</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_INITIALIZE_PARAMS" title='_NV_ENC_INITIALIZE_PARAMS' data-ref="_NV_ENC_INITIALIZE_PARAMS"><a class="type" href="#_NV_ENC_INITIALIZE_PARAMS" title='_NV_ENC_INITIALIZE_PARAMS' data-ref="_NV_ENC_INITIALIZE_PARAMS">_NV_ENC_INITIALIZE_PARAMS</a></dfn></td></tr>
<tr><th id="1311">1311</th><td>{</td></tr>
<tr><th id="1312">1312</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::version" title='_NV_ENC_INITIALIZE_PARAMS::version' data-ref="_NV_ENC_INITIALIZE_PARAMS::version">version</dfn>;                         <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER. */</i></td></tr>
<tr><th id="1313">1313</th><td>    <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>                                       <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::encodeGUID" title='_NV_ENC_INITIALIZE_PARAMS::encodeGUID' data-ref="_NV_ENC_INITIALIZE_PARAMS::encodeGUID">encodeGUID</dfn>;                      <i class="doc">/**&lt; [in]: Specifies the Encode GUID for which the encoder is being created. ::NvEncInitializeEncoder() API will fail if this is not set, or set to unsupported value. */</i></td></tr>
<tr><th id="1314">1314</th><td>    <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>                                       <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::presetGUID" title='_NV_ENC_INITIALIZE_PARAMS::presetGUID' data-ref="_NV_ENC_INITIALIZE_PARAMS::presetGUID">presetGUID</dfn>;                      <i class="doc">/**&lt; [in]: Specifies the preset for encoding. If the preset GUID is set then , the preset configuration will be applied before any other parameter. */</i></td></tr>
<tr><th id="1315">1315</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::encodeWidth" title='_NV_ENC_INITIALIZE_PARAMS::encodeWidth' data-ref="_NV_ENC_INITIALIZE_PARAMS::encodeWidth">encodeWidth</dfn>;                     <i class="doc">/**&lt; [in]: Specifies the encode width. If not set ::NvEncInitializeEncoder() API will fail. */</i></td></tr>
<tr><th id="1316">1316</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::encodeHeight" title='_NV_ENC_INITIALIZE_PARAMS::encodeHeight' data-ref="_NV_ENC_INITIALIZE_PARAMS::encodeHeight">encodeHeight</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the encode height. If not set ::NvEncInitializeEncoder() API will fail. */</i></td></tr>
<tr><th id="1317">1317</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::darWidth" title='_NV_ENC_INITIALIZE_PARAMS::darWidth' data-ref="_NV_ENC_INITIALIZE_PARAMS::darWidth">darWidth</dfn>;                        <i class="doc">/**&lt; [in]: Specifies the display aspect ratio Width. */</i></td></tr>
<tr><th id="1318">1318</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::darHeight" title='_NV_ENC_INITIALIZE_PARAMS::darHeight' data-ref="_NV_ENC_INITIALIZE_PARAMS::darHeight">darHeight</dfn>;                       <i class="doc">/**&lt; [in]: Specifies the display aspect ratio height. */</i></td></tr>
<tr><th id="1319">1319</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::frameRateNum" title='_NV_ENC_INITIALIZE_PARAMS::frameRateNum' data-ref="_NV_ENC_INITIALIZE_PARAMS::frameRateNum">frameRateNum</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the numerator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen ). */</i></td></tr>
<tr><th id="1320">1320</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::frameRateDen" title='_NV_ENC_INITIALIZE_PARAMS::frameRateDen' data-ref="_NV_ENC_INITIALIZE_PARAMS::frameRateDen">frameRateDen</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen ). */</i></td></tr>
<tr><th id="1321">1321</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync" title='_NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync' data-ref="_NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync">enableEncodeAsync</dfn>;               <i class="doc">/**&lt; [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification. */</i></td></tr>
<tr><th id="1322">1322</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::enablePTD" title='_NV_ENC_INITIALIZE_PARAMS::enablePTD' data-ref="_NV_ENC_INITIALIZE_PARAMS::enablePTD">enablePTD</dfn>;                       <i class="doc">/**&lt; [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface. */</i></td></tr>
<tr><th id="1323">1323</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets" title='_NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets' data-ref="_NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets">reportSliceOffsets</dfn>        :<var>1</var>;    <i class="doc">/**&lt; [in]: Set this to 1 to enable reporting slice offsets in ::_NV_ENC_LOCK_BITSTREAM. NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync must be set to 0 to use this feature. Client must set this to 0 if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs */</i></td></tr>
<tr><th id="1324">1324</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::enableSubFrameWrite" title='_NV_ENC_INITIALIZE_PARAMS::enableSubFrameWrite' data-ref="_NV_ENC_INITIALIZE_PARAMS::enableSubFrameWrite">enableSubFrameWrite</dfn>       :<var>1</var>;    <i class="doc">/**&lt; [in]: Set this to 1 to write out available bitstream to memory at subframe intervals */</i></td></tr>
<tr><th id="1325">1325</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints" title='_NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints' data-ref="_NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints">enableExternalMEHints</dfn>     :<var>1</var>;    <i class="doc">/**&lt; [in]: Set to 1 to enable external ME hints for the current frame. For NV_ENC_INITIALIZE_PARAMS::enablePTD=1 with B frames, programming L1 hints is optional for B frames since Client doesn't know internal GOP structure.</i></td></tr>
<tr><th id="1326">1326</th><td><i class="doc">                                                                                           NV_ENC_PIC_PARAMS::meHintRefPicDist should preferably be set with enablePTD=1. */</i></td></tr>
<tr><th id="1327">1327</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::enableMEOnlyMode" title='_NV_ENC_INITIALIZE_PARAMS::enableMEOnlyMode' data-ref="_NV_ENC_INITIALIZE_PARAMS::enableMEOnlyMode">enableMEOnlyMode</dfn>          :<var>1</var>;    <i class="doc">/**&lt; [in]: Set to 1 to enable ME Only Mode .*/</i></td></tr>
<tr><th id="1328">1328</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::reservedBitFields" title='_NV_ENC_INITIALIZE_PARAMS::reservedBitFields' data-ref="_NV_ENC_INITIALIZE_PARAMS::reservedBitFields">reservedBitFields</dfn>         :<var>28</var>;   <i class="doc">/**&lt; [in]: Reserved bitfields and must be set to 0 */</i></td></tr>
<tr><th id="1329">1329</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::privDataSize" title='_NV_ENC_INITIALIZE_PARAMS::privDataSize' data-ref="_NV_ENC_INITIALIZE_PARAMS::privDataSize">privDataSize</dfn>;                    <i class="doc">/**&lt; [in]: Reserved private data buffer size and must be set to 0 */</i></td></tr>
<tr><th id="1330">1330</th><td>    <em>void</em>*                                      <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::privData" title='_NV_ENC_INITIALIZE_PARAMS::privData' data-ref="_NV_ENC_INITIALIZE_PARAMS::privData">privData</dfn>;                        <i class="doc">/**&lt; [in]: Reserved private data buffer and must be set to NULL */</i></td></tr>
<tr><th id="1331">1331</th><td>    <a class="typedef" href="#NV_ENC_CONFIG" title='NV_ENC_CONFIG' data-type='struct _NV_ENC_CONFIG' data-ref="NV_ENC_CONFIG">NV_ENC_CONFIG</a>*                             <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::encodeConfig" title='_NV_ENC_INITIALIZE_PARAMS::encodeConfig' data-ref="_NV_ENC_INITIALIZE_PARAMS::encodeConfig">encodeConfig</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters.</i></td></tr>
<tr><th id="1332">1332</th><td><i class="doc">                                                                                           Client can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS.</i></td></tr>
<tr><th id="1333">1333</th><td><i class="doc">                                                                                           Even in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API. */</i></td></tr>
<tr><th id="1334">1334</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::maxEncodeWidth" title='_NV_ENC_INITIALIZE_PARAMS::maxEncodeWidth' data-ref="_NV_ENC_INITIALIZE_PARAMS::maxEncodeWidth">maxEncodeWidth</dfn>;                  <i class="doc">/**&lt; [in]: Maximum encode width to be used for current Encode session.</i></td></tr>
<tr><th id="1335">1335</th><td><i class="doc">                                                                                           Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encoder will not allow dynamic resolution change. */</i></td></tr>
<tr><th id="1336">1336</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::maxEncodeHeight" title='_NV_ENC_INITIALIZE_PARAMS::maxEncodeHeight' data-ref="_NV_ENC_INITIALIZE_PARAMS::maxEncodeHeight">maxEncodeHeight</dfn>;                 <i class="doc">/**&lt; [in]: Maximum encode height to be allowed for current Encode session.</i></td></tr>
<tr><th id="1337">1337</th><td><i class="doc">                                                                                           Client should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encode will not allow dynamic resolution change. */</i></td></tr>
<tr><th id="1338">1338</th><td>    <a class="typedef" href="#NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE" title='NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-type='struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-ref="NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE">NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE</a> <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock" title='_NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock' data-ref="_NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock">maxMEHintCountsPerBlock</dfn>[<var>2</var>];      <i class="doc">/**&lt; [in]: If Client wants to pass external motion vectors in NV_ENC_PIC_PARAMS::meExternalHints buffer it must specify the maximum number of hint candidates per block per direction for the encode session.</i></td></tr>
<tr><th id="1339">1339</th><td><i class="doc">                                                                                           The NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[0] is for L0 predictors and NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[1] is for L1 predictors.</i></td></tr>
<tr><th id="1340">1340</th><td><i class="doc">                                                                                           This client must also set NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints to 1. */</i></td></tr>
<tr><th id="1341">1341</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                   <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::reserved" title='_NV_ENC_INITIALIZE_PARAMS::reserved' data-ref="_NV_ENC_INITIALIZE_PARAMS::reserved">reserved</dfn> [<var>289</var>];                  <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1342">1342</th><td>    <em>void</em>*                                      <dfn class="decl" id="_NV_ENC_INITIALIZE_PARAMS::reserved2" title='_NV_ENC_INITIALIZE_PARAMS::reserved2' data-ref="_NV_ENC_INITIALIZE_PARAMS::reserved2">reserved2</dfn>[<var>64</var>];                   <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1343">1343</th><td>} <dfn class="typedef" id="NV_ENC_INITIALIZE_PARAMS" title='NV_ENC_INITIALIZE_PARAMS' data-type='struct _NV_ENC_INITIALIZE_PARAMS' data-ref="NV_ENC_INITIALIZE_PARAMS">NV_ENC_INITIALIZE_PARAMS</dfn>;</td></tr>
<tr><th id="1344">1344</th><td></td></tr>
<tr><th id="1345">1345</th><td><i class="doc">/** macro for constructing the version field of ::_NV_ENC_INITIALIZE_PARAMS */</i></td></tr>
<tr><th id="1346">1346</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_INITIALIZE_PARAMS_VER" data-ref="_M/NV_ENC_INITIALIZE_PARAMS_VER">NV_ENC_INITIALIZE_PARAMS_VER</dfn> (NVENCAPI_STRUCT_VERSION(5) | ( 1&lt;&lt;31 ))</u></td></tr>
<tr><th id="1347">1347</th><td></td></tr>
<tr><th id="1348">1348</th><td></td></tr>
<tr><th id="1349">1349</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1350">1350</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_RECONFIGURE_PARAMS</span></i></td></tr>
<tr><th id="1351">1351</th><td><i class="doc"> * Encode Session Reconfigured parameters.</i></td></tr>
<tr><th id="1352">1352</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1353">1353</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_RECONFIGURE_PARAMS" title='_NV_ENC_RECONFIGURE_PARAMS' data-ref="_NV_ENC_RECONFIGURE_PARAMS"><a class="type" href="#_NV_ENC_RECONFIGURE_PARAMS" title='_NV_ENC_RECONFIGURE_PARAMS' data-ref="_NV_ENC_RECONFIGURE_PARAMS">_NV_ENC_RECONFIGURE_PARAMS</a></dfn></td></tr>
<tr><th id="1354">1354</th><td>{</td></tr>
<tr><th id="1355">1355</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_RECONFIGURE_PARAMS::version" title='_NV_ENC_RECONFIGURE_PARAMS::version' data-ref="_NV_ENC_RECONFIGURE_PARAMS::version">version</dfn>;                        <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_RECONFIGURE_PARAMS_VER. */</i></td></tr>
<tr><th id="1356">1356</th><td>    <a class="typedef" href="#NV_ENC_INITIALIZE_PARAMS" title='NV_ENC_INITIALIZE_PARAMS' data-type='struct _NV_ENC_INITIALIZE_PARAMS' data-ref="NV_ENC_INITIALIZE_PARAMS">NV_ENC_INITIALIZE_PARAMS</a>                    <dfn class="decl" id="_NV_ENC_RECONFIGURE_PARAMS::reInitEncodeParams" title='_NV_ENC_RECONFIGURE_PARAMS::reInitEncodeParams' data-ref="_NV_ENC_RECONFIGURE_PARAMS::reInitEncodeParams">reInitEncodeParams</dfn>;             <i class="doc">/**&lt; [in]: Encoder session re-initialization parameters. */</i></td></tr>
<tr><th id="1357">1357</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_RECONFIGURE_PARAMS::resetEncoder" title='_NV_ENC_RECONFIGURE_PARAMS::resetEncoder' data-ref="_NV_ENC_RECONFIGURE_PARAMS::resetEncoder">resetEncoder</dfn>            :<var>1</var>;     <i class="doc">/**&lt; [in]: This resets the rate control states and other internal encoder states. This should be used only with an IDR frame.</i></td></tr>
<tr><th id="1358">1358</th><td><i class="doc">                                                                                           If NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1, encoder will force the frame type to IDR */</i></td></tr>
<tr><th id="1359">1359</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_RECONFIGURE_PARAMS::forceIDR" title='_NV_ENC_RECONFIGURE_PARAMS::forceIDR' data-ref="_NV_ENC_RECONFIGURE_PARAMS::forceIDR">forceIDR</dfn>                :<var>1</var>;     <i class="doc">/**&lt; [in]: Encode the current picture as an IDR picture. This flag is only valid when Picture type decision is taken by the Encoder</i></td></tr>
<tr><th id="1360">1360</th><td><i class="doc">                                                                                           [_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]. */</i></td></tr>
<tr><th id="1361">1361</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_RECONFIGURE_PARAMS::reserved" title='_NV_ENC_RECONFIGURE_PARAMS::reserved' data-ref="_NV_ENC_RECONFIGURE_PARAMS::reserved">reserved</dfn>                :<var>30</var>;</td></tr>
<tr><th id="1362">1362</th><td></td></tr>
<tr><th id="1363">1363</th><td>}<dfn class="typedef" id="NV_ENC_RECONFIGURE_PARAMS" title='NV_ENC_RECONFIGURE_PARAMS' data-type='struct _NV_ENC_RECONFIGURE_PARAMS' data-ref="NV_ENC_RECONFIGURE_PARAMS">NV_ENC_RECONFIGURE_PARAMS</dfn>;</td></tr>
<tr><th id="1364">1364</th><td></td></tr>
<tr><th id="1365">1365</th><td><i class="doc">/** macro for constructing the version field of ::_NV_ENC_RECONFIGURE_PARAMS */</i></td></tr>
<tr><th id="1366">1366</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_RECONFIGURE_PARAMS_VER" data-ref="_M/NV_ENC_RECONFIGURE_PARAMS_VER">NV_ENC_RECONFIGURE_PARAMS_VER</dfn> (NVENCAPI_STRUCT_VERSION(1) | ( 1&lt;&lt;31 ))</u></td></tr>
<tr><th id="1367">1367</th><td></td></tr>
<tr><th id="1368">1368</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1369">1369</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_PRESET_CONFIG</span></i></td></tr>
<tr><th id="1370">1370</th><td><i class="doc"> * Encoder preset config</i></td></tr>
<tr><th id="1371">1371</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1372">1372</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_PRESET_CONFIG" title='_NV_ENC_PRESET_CONFIG' data-ref="_NV_ENC_PRESET_CONFIG"><a class="type" href="#_NV_ENC_PRESET_CONFIG" title='_NV_ENC_PRESET_CONFIG' data-ref="_NV_ENC_PRESET_CONFIG">_NV_ENC_PRESET_CONFIG</a></dfn></td></tr>
<tr><th id="1373">1373</th><td>{</td></tr>
<tr><th id="1374">1374</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>      <dfn class="decl" id="_NV_ENC_PRESET_CONFIG::version" title='_NV_ENC_PRESET_CONFIG::version' data-ref="_NV_ENC_PRESET_CONFIG::version">version</dfn>;                               <i class="doc">/**&lt; [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER. */</i></td></tr>
<tr><th id="1375">1375</th><td>    <a class="typedef" href="#NV_ENC_CONFIG" title='NV_ENC_CONFIG' data-type='struct _NV_ENC_CONFIG' data-ref="NV_ENC_CONFIG">NV_ENC_CONFIG</a> <dfn class="decl" id="_NV_ENC_PRESET_CONFIG::presetCfg" title='_NV_ENC_PRESET_CONFIG::presetCfg' data-ref="_NV_ENC_PRESET_CONFIG::presetCfg">presetCfg</dfn>;                             <i class="doc">/**&lt; [out]: preset config returned by the Nvidia Video Encoder interface. */</i></td></tr>
<tr><th id="1376">1376</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>      <dfn class="decl" id="_NV_ENC_PRESET_CONFIG::reserved1" title='_NV_ENC_PRESET_CONFIG::reserved1' data-ref="_NV_ENC_PRESET_CONFIG::reserved1">reserved1</dfn>[<var>255</var>];                        <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1377">1377</th><td>    <em>void</em>*         <dfn class="decl" id="_NV_ENC_PRESET_CONFIG::reserved2" title='_NV_ENC_PRESET_CONFIG::reserved2' data-ref="_NV_ENC_PRESET_CONFIG::reserved2">reserved2</dfn>[<var>64</var>];                         <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1378">1378</th><td>}<dfn class="typedef" id="NV_ENC_PRESET_CONFIG" title='NV_ENC_PRESET_CONFIG' data-type='struct _NV_ENC_PRESET_CONFIG' data-ref="NV_ENC_PRESET_CONFIG">NV_ENC_PRESET_CONFIG</dfn>;</td></tr>
<tr><th id="1379">1379</th><td></td></tr>
<tr><th id="1380">1380</th><td><i class="doc">/** macro for constructing the version field of ::_NV_ENC_PRESET_CONFIG */</i></td></tr>
<tr><th id="1381">1381</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_PRESET_CONFIG_VER" data-ref="_M/NV_ENC_PRESET_CONFIG_VER">NV_ENC_PRESET_CONFIG_VER</dfn> (NVENCAPI_STRUCT_VERSION(4) | ( 1&lt;&lt;31 ))</u></td></tr>
<tr><th id="1382">1382</th><td></td></tr>
<tr><th id="1383">1383</th><td></td></tr>
<tr><th id="1384">1384</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1385">1385</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_SEI_PAYLOAD</span></i></td></tr>
<tr><th id="1386">1386</th><td><i class="doc"> *  User SEI message</i></td></tr>
<tr><th id="1387">1387</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1388">1388</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_SEI_PAYLOAD" title='_NV_ENC_SEI_PAYLOAD' data-ref="_NV_ENC_SEI_PAYLOAD"><a class="type" href="#_NV_ENC_SEI_PAYLOAD" title='_NV_ENC_SEI_PAYLOAD' data-ref="_NV_ENC_SEI_PAYLOAD">_NV_ENC_SEI_PAYLOAD</a></dfn></td></tr>
<tr><th id="1389">1389</th><td>{</td></tr>
<tr><th id="1390">1390</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_SEI_PAYLOAD::payloadSize" title='_NV_ENC_SEI_PAYLOAD::payloadSize' data-ref="_NV_ENC_SEI_PAYLOAD::payloadSize">payloadSize</dfn>;            <i class="doc">/**&lt; [in] SEI payload size in bytes. SEI payload must be byte aligned, as described in Annex D */</i></td></tr>
<tr><th id="1391">1391</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_SEI_PAYLOAD::payloadType" title='_NV_ENC_SEI_PAYLOAD::payloadType' data-ref="_NV_ENC_SEI_PAYLOAD::payloadType">payloadType</dfn>;            <i class="doc">/**&lt; [in] SEI payload types and syntax can be found in Annex D of the H.264 Specification. */</i></td></tr>
<tr><th id="1392">1392</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> *<dfn class="decl" id="_NV_ENC_SEI_PAYLOAD::payload" title='_NV_ENC_SEI_PAYLOAD::payload' data-ref="_NV_ENC_SEI_PAYLOAD::payload">payload</dfn>;                <i class="doc">/**&lt; [in] pointer to user data */</i></td></tr>
<tr><th id="1393">1393</th><td>} <dfn class="typedef" id="NV_ENC_SEI_PAYLOAD" title='NV_ENC_SEI_PAYLOAD' data-type='struct _NV_ENC_SEI_PAYLOAD' data-ref="NV_ENC_SEI_PAYLOAD">NV_ENC_SEI_PAYLOAD</dfn>;</td></tr>
<tr><th id="1394">1394</th><td></td></tr>
<tr><th id="1395">1395</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_H264_SEI_PAYLOAD" data-ref="_M/NV_ENC_H264_SEI_PAYLOAD">NV_ENC_H264_SEI_PAYLOAD</dfn> NV_ENC_SEI_PAYLOAD</u></td></tr>
<tr><th id="1396">1396</th><td></td></tr>
<tr><th id="1397">1397</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1398">1398</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_PIC_PARAMS_H264</span></i></td></tr>
<tr><th id="1399">1399</th><td><i class="doc"> * H264 specific enc pic params. sent on a per frame basis.</i></td></tr>
<tr><th id="1400">1400</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1401">1401</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_PIC_PARAMS_H264" title='_NV_ENC_PIC_PARAMS_H264' data-ref="_NV_ENC_PIC_PARAMS_H264"><a class="type" href="#_NV_ENC_PIC_PARAMS_H264" title='_NV_ENC_PIC_PARAMS_H264' data-ref="_NV_ENC_PIC_PARAMS_H264">_NV_ENC_PIC_PARAMS_H264</a></dfn></td></tr>
<tr><th id="1402">1402</th><td>{</td></tr>
<tr><th id="1403">1403</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::displayPOCSyntax" title='_NV_ENC_PIC_PARAMS_H264::displayPOCSyntax' data-ref="_NV_ENC_PIC_PARAMS_H264::displayPOCSyntax">displayPOCSyntax</dfn>;                           <i class="doc">/**&lt; [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision. */</i></td></tr>
<tr><th id="1404">1404</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::reserved3" title='_NV_ENC_PIC_PARAMS_H264::reserved3' data-ref="_NV_ENC_PIC_PARAMS_H264::reserved3">reserved3</dfn>;                                  <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1405">1405</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::refPicFlag" title='_NV_ENC_PIC_PARAMS_H264::refPicFlag' data-ref="_NV_ENC_PIC_PARAMS_H264::refPicFlag">refPicFlag</dfn>;                                 <i class="doc">/**&lt; [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1. */</i></td></tr>
<tr><th id="1406">1406</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::colourPlaneId" title='_NV_ENC_PIC_PARAMS_H264::colourPlaneId' data-ref="_NV_ENC_PIC_PARAMS_H264::colourPlaneId">colourPlaneId</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the colour plane ID associated with the current input. */</i></td></tr>
<tr><th id="1407">1407</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::forceIntraRefreshWithFrameCnt" title='_NV_ENC_PIC_PARAMS_H264::forceIntraRefreshWithFrameCnt' data-ref="_NV_ENC_PIC_PARAMS_H264::forceIntraRefreshWithFrameCnt">forceIntraRefreshWithFrameCnt</dfn>;              <i class="doc">/**&lt; [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.</i></td></tr>
<tr><th id="1408">1408</th><td><i class="doc">                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message</i></td></tr>
<tr><th id="1409">1409</th><td><i class="doc">                                                                    forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified */</i></td></tr>
<tr><th id="1410">1410</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::constrainedFrame" title='_NV_ENC_PIC_PARAMS_H264::constrainedFrame' data-ref="_NV_ENC_PIC_PARAMS_H264::constrainedFrame">constrainedFrame</dfn>           :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame.</i></td></tr>
<tr><th id="1411">1411</th><td><i class="doc">                                                                    NV_ENC_INITIALIZE_PARAMS::enableConstrainedEncoding should be set to 1 */</i></td></tr>
<tr><th id="1412">1412</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::sliceModeDataUpdate" title='_NV_ENC_PIC_PARAMS_H264::sliceModeDataUpdate' data-ref="_NV_ENC_PIC_PARAMS_H264::sliceModeDataUpdate">sliceModeDataUpdate</dfn>        :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter</i></td></tr>
<tr><th id="1413">1413</th><td><i class="doc">                                                                    When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting */</i></td></tr>
<tr><th id="1414">1414</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::ltrMarkFrame" title='_NV_ENC_PIC_PARAMS_H264::ltrMarkFrame' data-ref="_NV_ENC_PIC_PARAMS_H264::ltrMarkFrame">ltrMarkFrame</dfn>               :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to mark this frame as LTR */</i></td></tr>
<tr><th id="1415">1415</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::ltrUseFrames" title='_NV_ENC_PIC_PARAMS_H264::ltrUseFrames' data-ref="_NV_ENC_PIC_PARAMS_H264::ltrUseFrames">ltrUseFrames</dfn>               :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */</i></td></tr>
<tr><th id="1416">1416</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::reservedBitFields" title='_NV_ENC_PIC_PARAMS_H264::reservedBitFields' data-ref="_NV_ENC_PIC_PARAMS_H264::reservedBitFields">reservedBitFields</dfn>          :<var>28</var>;             <i class="doc">/**&lt; [in]: Reserved bit fields and must be set to 0 */</i></td></tr>
<tr><th id="1417">1417</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>* <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::sliceTypeData" title='_NV_ENC_PIC_PARAMS_H264::sliceTypeData' data-ref="_NV_ENC_PIC_PARAMS_H264::sliceTypeData">sliceTypeData</dfn>;                              <i class="doc">/**&lt; [in]: Deprecated. */</i></td></tr>
<tr><th id="1418">1418</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::sliceTypeArrayCnt" title='_NV_ENC_PIC_PARAMS_H264::sliceTypeArrayCnt' data-ref="_NV_ENC_PIC_PARAMS_H264::sliceTypeArrayCnt">sliceTypeArrayCnt</dfn>;                          <i class="doc">/**&lt; [in]: Deprecated. */</i></td></tr>
<tr><th id="1419">1419</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::seiPayloadArrayCnt" title='_NV_ENC_PIC_PARAMS_H264::seiPayloadArrayCnt' data-ref="_NV_ENC_PIC_PARAMS_H264::seiPayloadArrayCnt">seiPayloadArrayCnt</dfn>;                         <i class="doc">/**&lt; [in]: Specifies the number of elements allocated in  seiPayloadArray array. */</i></td></tr>
<tr><th id="1420">1420</th><td>    <a class="typedef" href="#NV_ENC_SEI_PAYLOAD" title='NV_ENC_SEI_PAYLOAD' data-type='struct _NV_ENC_SEI_PAYLOAD' data-ref="NV_ENC_SEI_PAYLOAD">NV_ENC_SEI_PAYLOAD</a>* <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::seiPayloadArray" title='_NV_ENC_PIC_PARAMS_H264::seiPayloadArray' data-ref="_NV_ENC_PIC_PARAMS_H264::seiPayloadArray">seiPayloadArray</dfn>;                 <i class="doc">/**&lt; [in]: Array of SEI payloads which will be inserted for this frame. */</i></td></tr>
<tr><th id="1421">1421</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::sliceMode" title='_NV_ENC_PIC_PARAMS_H264::sliceMode' data-ref="_NV_ENC_PIC_PARAMS_H264::sliceMode">sliceMode</dfn>;                                  <i class="doc">/**&lt; [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices</i></td></tr>
<tr><th id="1422">1422</th><td><i class="doc">                                                                    sliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture</i></td></tr>
<tr><th id="1423">1423</th><td><i class="doc">                                                                    When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting</i></td></tr>
<tr><th id="1424">1424</th><td><i class="doc">                                                                    When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice */</i></td></tr>
<tr><th id="1425">1425</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::sliceModeData" title='_NV_ENC_PIC_PARAMS_H264::sliceModeData' data-ref="_NV_ENC_PIC_PARAMS_H264::sliceModeData">sliceModeData</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the parameter needed for sliceMode. For:</i></td></tr>
<tr><th id="1426">1426</th><td><i class="doc">                                                                    sliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)</i></td></tr>
<tr><th id="1427">1427</th><td><i class="doc">                                                                    sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)</i></td></tr>
<tr><th id="1428">1428</th><td><i class="doc">                                                                    sliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)</i></td></tr>
<tr><th id="1429">1429</th><td><i class="doc">                                                                    sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally */</i></td></tr>
<tr><th id="1430">1430</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::ltrMarkFrameIdx" title='_NV_ENC_PIC_PARAMS_H264::ltrMarkFrameIdx' data-ref="_NV_ENC_PIC_PARAMS_H264::ltrMarkFrameIdx">ltrMarkFrameIdx</dfn>;                            <i class="doc">/**&lt; [in]: Specifies the long term referenceframe index to use for marking this frame as LTR.*/</i></td></tr>
<tr><th id="1431">1431</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::ltrUseFrameBitmap" title='_NV_ENC_PIC_PARAMS_H264::ltrUseFrameBitmap' data-ref="_NV_ENC_PIC_PARAMS_H264::ltrUseFrameBitmap">ltrUseFrameBitmap</dfn>;                          <i class="doc">/**&lt; [in]: Specifies the the associated bitmap of LTR frame indices when encoding this frame. */</i></td></tr>
<tr><th id="1432">1432</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::ltrUsageMode" title='_NV_ENC_PIC_PARAMS_H264::ltrUsageMode' data-ref="_NV_ENC_PIC_PARAMS_H264::ltrUsageMode">ltrUsageMode</dfn>;                               <i class="doc">/**&lt; [in]: Specifies additional usage constraints for encoding using LTR frames from this point further. 0: no constraints, 1: no short term refs older than current, no previous LTR frames.*/</i></td></tr>
<tr><th id="1433">1433</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::reserved" title='_NV_ENC_PIC_PARAMS_H264::reserved' data-ref="_NV_ENC_PIC_PARAMS_H264::reserved">reserved</dfn> [<var>243</var>];                             <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1434">1434</th><td>    <em>void</em>*    <dfn class="decl" id="_NV_ENC_PIC_PARAMS_H264::reserved2" title='_NV_ENC_PIC_PARAMS_H264::reserved2' data-ref="_NV_ENC_PIC_PARAMS_H264::reserved2">reserved2</dfn>[<var>62</var>];                              <i class="doc">/**&lt; [in]: Reserved and must be set to NULL. */</i></td></tr>
<tr><th id="1435">1435</th><td>} <dfn class="typedef" id="NV_ENC_PIC_PARAMS_H264" title='NV_ENC_PIC_PARAMS_H264' data-type='struct _NV_ENC_PIC_PARAMS_H264' data-ref="NV_ENC_PIC_PARAMS_H264">NV_ENC_PIC_PARAMS_H264</dfn>;</td></tr>
<tr><th id="1436">1436</th><td></td></tr>
<tr><th id="1437">1437</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1438">1438</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_PIC_PARAMS_HEVC</span></i></td></tr>
<tr><th id="1439">1439</th><td><i class="doc"> * HEVC specific enc pic params. sent on a per frame basis.</i></td></tr>
<tr><th id="1440">1440</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1441">1441</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_PIC_PARAMS_HEVC" title='_NV_ENC_PIC_PARAMS_HEVC' data-ref="_NV_ENC_PIC_PARAMS_HEVC"><a class="type" href="#_NV_ENC_PIC_PARAMS_HEVC" title='_NV_ENC_PIC_PARAMS_HEVC' data-ref="_NV_ENC_PIC_PARAMS_HEVC">_NV_ENC_PIC_PARAMS_HEVC</a></dfn></td></tr>
<tr><th id="1442">1442</th><td>{</td></tr>
<tr><th id="1443">1443</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::displayPOCSyntax" title='_NV_ENC_PIC_PARAMS_HEVC::displayPOCSyntax' data-ref="_NV_ENC_PIC_PARAMS_HEVC::displayPOCSyntax">displayPOCSyntax</dfn>;                           <i class="doc">/**&lt; [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision. */</i></td></tr>
<tr><th id="1444">1444</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::refPicFlag" title='_NV_ENC_PIC_PARAMS_HEVC::refPicFlag' data-ref="_NV_ENC_PIC_PARAMS_HEVC::refPicFlag">refPicFlag</dfn>;                                 <i class="doc">/**&lt; [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1. */</i></td></tr>
<tr><th id="1445">1445</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::temporalId" title='_NV_ENC_PIC_PARAMS_HEVC::temporalId' data-ref="_NV_ENC_PIC_PARAMS_HEVC::temporalId">temporalId</dfn>;                                 <i class="doc">/**&lt; [in]: Specifies the temporal id of the picture */</i></td></tr>
<tr><th id="1446">1446</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::forceIntraRefreshWithFrameCnt" title='_NV_ENC_PIC_PARAMS_HEVC::forceIntraRefreshWithFrameCnt' data-ref="_NV_ENC_PIC_PARAMS_HEVC::forceIntraRefreshWithFrameCnt">forceIntraRefreshWithFrameCnt</dfn>;              <i class="doc">/**&lt; [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.</i></td></tr>
<tr><th id="1447">1447</th><td><i class="doc">                                                                    When outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message</i></td></tr>
<tr><th id="1448">1448</th><td><i class="doc">                                                                    forceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified */</i></td></tr>
<tr><th id="1449">1449</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::constrainedFrame" title='_NV_ENC_PIC_PARAMS_HEVC::constrainedFrame' data-ref="_NV_ENC_PIC_PARAMS_HEVC::constrainedFrame">constrainedFrame</dfn>           :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to encode this frame with each slice completely independent of other slices in the frame.</i></td></tr>
<tr><th id="1450">1450</th><td><i class="doc">                                                                    NV_ENC_INITIALIZE_PARAMS::enableConstrainedEncoding should be set to 1 */</i></td></tr>
<tr><th id="1451">1451</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::sliceModeDataUpdate" title='_NV_ENC_PIC_PARAMS_HEVC::sliceModeDataUpdate' data-ref="_NV_ENC_PIC_PARAMS_HEVC::sliceModeDataUpdate">sliceModeDataUpdate</dfn>        :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to change the sliceModeData field to specify new sliceSize Parameter</i></td></tr>
<tr><th id="1452">1452</th><td><i class="doc">                                                                    When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting */</i></td></tr>
<tr><th id="1453">1453</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrame" title='_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrame' data-ref="_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrame">ltrMarkFrame</dfn>               :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client wants to mark this frame as LTR */</i></td></tr>
<tr><th id="1454">1454</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrames" title='_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrames' data-ref="_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrames">ltrUseFrames</dfn>               :<var>1</var>;              <i class="doc">/**&lt; [in]: Set to 1 if client allows encoding this frame using the LTR frames specified in ltrFrameBitmap */</i></td></tr>
<tr><th id="1455">1455</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::reservedBitFields" title='_NV_ENC_PIC_PARAMS_HEVC::reservedBitFields' data-ref="_NV_ENC_PIC_PARAMS_HEVC::reservedBitFields">reservedBitFields</dfn>          :<var>28</var>;             <i class="doc">/**&lt; [in]: Reserved bit fields and must be set to 0 */</i></td></tr>
<tr><th id="1456">1456</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>* <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::sliceTypeData" title='_NV_ENC_PIC_PARAMS_HEVC::sliceTypeData' data-ref="_NV_ENC_PIC_PARAMS_HEVC::sliceTypeData">sliceTypeData</dfn>;                              <i class="doc">/**&lt; [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3.</i></td></tr>
<tr><th id="1457">1457</th><td><i class="doc">                                                                    Client should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264</i></td></tr>
<tr><th id="1458">1458</th><td><i class="doc">                                                                    Array element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I</i></td></tr>
<tr><th id="1459">1459</th><td><i class="doc">                                                                    all other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT */</i></td></tr>
<tr><th id="1460">1460</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::sliceTypeArrayCnt" title='_NV_ENC_PIC_PARAMS_HEVC::sliceTypeArrayCnt' data-ref="_NV_ENC_PIC_PARAMS_HEVC::sliceTypeArrayCnt">sliceTypeArrayCnt</dfn>;                          <i class="doc">/**&lt; [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0 */</i></td></tr>
<tr><th id="1461">1461</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::sliceMode" title='_NV_ENC_PIC_PARAMS_HEVC::sliceMode' data-ref="_NV_ENC_PIC_PARAMS_HEVC::sliceMode">sliceMode</dfn>;                                  <i class="doc">/**&lt; [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices</i></td></tr>
<tr><th id="1462">1462</th><td><i class="doc">                                                                    sliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture</i></td></tr>
<tr><th id="1463">1463</th><td><i class="doc">                                                                    When forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting</i></td></tr>
<tr><th id="1464">1464</th><td><i class="doc">                                                                    When sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice */</i></td></tr>
<tr><th id="1465">1465</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::sliceModeData" title='_NV_ENC_PIC_PARAMS_HEVC::sliceModeData' data-ref="_NV_ENC_PIC_PARAMS_HEVC::sliceModeData">sliceModeData</dfn>;                              <i class="doc">/**&lt; [in]: Specifies the parameter needed for sliceMode. For:</i></td></tr>
<tr><th id="1466">1466</th><td><i class="doc">                                                                    sliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)</i></td></tr>
<tr><th id="1467">1467</th><td><i class="doc">                                                                    sliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)</i></td></tr>
<tr><th id="1468">1468</th><td><i class="doc">                                                                    sliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)</i></td></tr>
<tr><th id="1469">1469</th><td><i class="doc">                                                                    sliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally */</i></td></tr>
<tr><th id="1470">1470</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrameIdx" title='_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrameIdx' data-ref="_NV_ENC_PIC_PARAMS_HEVC::ltrMarkFrameIdx">ltrMarkFrameIdx</dfn>;                            <i class="doc">/**&lt; [in]: Specifies the long term reference frame index to use for marking this frame as LTR.*/</i></td></tr>
<tr><th id="1471">1471</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrameBitmap" title='_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrameBitmap' data-ref="_NV_ENC_PIC_PARAMS_HEVC::ltrUseFrameBitmap">ltrUseFrameBitmap</dfn>;                          <i class="doc">/**&lt; [in]: Specifies the associated bitmap of LTR frame indices when encoding this frame. */</i></td></tr>
<tr><th id="1472">1472</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::ltrUsageMode" title='_NV_ENC_PIC_PARAMS_HEVC::ltrUsageMode' data-ref="_NV_ENC_PIC_PARAMS_HEVC::ltrUsageMode">ltrUsageMode</dfn>;                               <i class="doc">/**&lt; [in]: Specifies additional usage constraints for encoding using LTR frames from this point further. 0: no constraints, 1: no short term refs older than current, no previous LTR frames.*/</i></td></tr>
<tr><th id="1473">1473</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArrayCnt" title='_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArrayCnt' data-ref="_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArrayCnt">seiPayloadArrayCnt</dfn>;                         <i class="doc">/**&lt; [in]: Specifies the number of elements allocated in  seiPayloadArray array. */</i></td></tr>
<tr><th id="1474">1474</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::reserved" title='_NV_ENC_PIC_PARAMS_HEVC::reserved' data-ref="_NV_ENC_PIC_PARAMS_HEVC::reserved">reserved</dfn>;                                   <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1475">1475</th><td>    <a class="typedef" href="#NV_ENC_SEI_PAYLOAD" title='NV_ENC_SEI_PAYLOAD' data-type='struct _NV_ENC_SEI_PAYLOAD' data-ref="NV_ENC_SEI_PAYLOAD">NV_ENC_SEI_PAYLOAD</a>* <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArray" title='_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArray' data-ref="_NV_ENC_PIC_PARAMS_HEVC::seiPayloadArray">seiPayloadArray</dfn>;                 <i class="doc">/**&lt; [in]: Array of SEI payloads which will be inserted for this frame. */</i></td></tr>
<tr><th id="1476">1476</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::reserved2" title='_NV_ENC_PIC_PARAMS_HEVC::reserved2' data-ref="_NV_ENC_PIC_PARAMS_HEVC::reserved2">reserved2</dfn> [<var>244</var>];                             <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1477">1477</th><td>    <em>void</em>*    <dfn class="decl" id="_NV_ENC_PIC_PARAMS_HEVC::reserved3" title='_NV_ENC_PIC_PARAMS_HEVC::reserved3' data-ref="_NV_ENC_PIC_PARAMS_HEVC::reserved3">reserved3</dfn>[<var>61</var>];                              <i class="doc">/**&lt; [in]: Reserved and must be set to NULL. */</i></td></tr>
<tr><th id="1478">1478</th><td>} <dfn class="typedef" id="NV_ENC_PIC_PARAMS_HEVC" title='NV_ENC_PIC_PARAMS_HEVC' data-type='struct _NV_ENC_PIC_PARAMS_HEVC' data-ref="NV_ENC_PIC_PARAMS_HEVC">NV_ENC_PIC_PARAMS_HEVC</dfn>;</td></tr>
<tr><th id="1479">1479</th><td></td></tr>
<tr><th id="1480">1480</th><td></td></tr>
<tr><th id="1481">1481</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1482">1482</th><td><i class="doc"> * Codec specific per-picture encoding parameters.</i></td></tr>
<tr><th id="1483">1483</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1484">1484</th><td><b>typedef</b> <b>union</b> <dfn class="type def" id="_NV_ENC_CODEC_PIC_PARAMS" title='_NV_ENC_CODEC_PIC_PARAMS' data-ref="_NV_ENC_CODEC_PIC_PARAMS"><a class="type" href="#_NV_ENC_CODEC_PIC_PARAMS" title='_NV_ENC_CODEC_PIC_PARAMS' data-ref="_NV_ENC_CODEC_PIC_PARAMS">_NV_ENC_CODEC_PIC_PARAMS</a></dfn></td></tr>
<tr><th id="1485">1485</th><td>{</td></tr>
<tr><th id="1486">1486</th><td>    <a class="typedef" href="#NV_ENC_PIC_PARAMS_H264" title='NV_ENC_PIC_PARAMS_H264' data-type='struct _NV_ENC_PIC_PARAMS_H264' data-ref="NV_ENC_PIC_PARAMS_H264">NV_ENC_PIC_PARAMS_H264</a> <dfn class="decl" id="_NV_ENC_CODEC_PIC_PARAMS::h264PicParams" title='_NV_ENC_CODEC_PIC_PARAMS::h264PicParams' data-ref="_NV_ENC_CODEC_PIC_PARAMS::h264PicParams">h264PicParams</dfn>;                <i class="doc">/**&lt; [in]: H264 encode picture params. */</i></td></tr>
<tr><th id="1487">1487</th><td>    <a class="typedef" href="#NV_ENC_PIC_PARAMS_HEVC" title='NV_ENC_PIC_PARAMS_HEVC' data-type='struct _NV_ENC_PIC_PARAMS_HEVC' data-ref="NV_ENC_PIC_PARAMS_HEVC">NV_ENC_PIC_PARAMS_HEVC</a> <dfn class="decl" id="_NV_ENC_CODEC_PIC_PARAMS::hevcPicParams" title='_NV_ENC_CODEC_PIC_PARAMS::hevcPicParams' data-ref="_NV_ENC_CODEC_PIC_PARAMS::hevcPicParams">hevcPicParams</dfn>;                <i class="doc">/**&lt; [in]: HEVC encode picture params. Currently unsupported and must not to be used.  */</i></td></tr>
<tr><th id="1488">1488</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>               <dfn class="decl" id="_NV_ENC_CODEC_PIC_PARAMS::reserved" title='_NV_ENC_CODEC_PIC_PARAMS::reserved' data-ref="_NV_ENC_CODEC_PIC_PARAMS::reserved">reserved</dfn>[<var>256</var>];                <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1489">1489</th><td>} <dfn class="typedef" id="NV_ENC_CODEC_PIC_PARAMS" title='NV_ENC_CODEC_PIC_PARAMS' data-type='union _NV_ENC_CODEC_PIC_PARAMS' data-ref="NV_ENC_CODEC_PIC_PARAMS">NV_ENC_CODEC_PIC_PARAMS</dfn>;</td></tr>
<tr><th id="1490">1490</th><td></td></tr>
<tr><th id="1491">1491</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1492">1492</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_PIC_PARAMS</span></i></td></tr>
<tr><th id="1493">1493</th><td><i class="doc"> * Encoding parameters that need to be sent on a per frame basis.</i></td></tr>
<tr><th id="1494">1494</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1495">1495</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_PIC_PARAMS" title='_NV_ENC_PIC_PARAMS' data-ref="_NV_ENC_PIC_PARAMS"><a class="type" href="#_NV_ENC_PIC_PARAMS" title='_NV_ENC_PIC_PARAMS' data-ref="_NV_ENC_PIC_PARAMS">_NV_ENC_PIC_PARAMS</a></dfn></td></tr>
<tr><th id="1496">1496</th><td>{</td></tr>
<tr><th id="1497">1497</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::version" title='_NV_ENC_PIC_PARAMS::version' data-ref="_NV_ENC_PIC_PARAMS::version">version</dfn>;                        <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_VER. */</i></td></tr>
<tr><th id="1498">1498</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputWidth" title='_NV_ENC_PIC_PARAMS::inputWidth' data-ref="_NV_ENC_PIC_PARAMS::inputWidth">inputWidth</dfn>;                     <i class="doc">/**&lt; [in]: Specifies the input buffer width */</i></td></tr>
<tr><th id="1499">1499</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputHeight" title='_NV_ENC_PIC_PARAMS::inputHeight' data-ref="_NV_ENC_PIC_PARAMS::inputHeight">inputHeight</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the input buffer height */</i></td></tr>
<tr><th id="1500">1500</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputPitch" title='_NV_ENC_PIC_PARAMS::inputPitch' data-ref="_NV_ENC_PIC_PARAMS::inputPitch">inputPitch</dfn>;                     <i class="doc">/**&lt; [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth. */</i></td></tr>
<tr><th id="1501">1501</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::encodePicFlags" title='_NV_ENC_PIC_PARAMS::encodePicFlags' data-ref="_NV_ENC_PIC_PARAMS::encodePicFlags">encodePicFlags</dfn>;                 <i class="doc">/**&lt; [in]: Specifies bit-wise OR`ed encode pic flags. See ::NV_ENC_PIC_FLAGS enum. */</i></td></tr>
<tr><th id="1502">1502</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::frameIdx" title='_NV_ENC_PIC_PARAMS::frameIdx' data-ref="_NV_ENC_PIC_PARAMS::frameIdx">frameIdx</dfn>;                       <i class="doc">/**&lt; [in]: Specifies the frame index associated with the input frame [optional]. */</i></td></tr>
<tr><th id="1503">1503</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputTimeStamp" title='_NV_ENC_PIC_PARAMS::inputTimeStamp' data-ref="_NV_ENC_PIC_PARAMS::inputTimeStamp">inputTimeStamp</dfn>;                 <i class="doc">/**&lt; [in]: Specifies presentation timestamp associated with the input picture. */</i></td></tr>
<tr><th id="1504">1504</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputDuration" title='_NV_ENC_PIC_PARAMS::inputDuration' data-ref="_NV_ENC_PIC_PARAMS::inputDuration">inputDuration</dfn>;                  <i class="doc">/**&lt; [in]: Specifies duration of the input picture */</i></td></tr>
<tr><th id="1505">1505</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>                            <dfn class="decl" id="_NV_ENC_PIC_PARAMS::inputBuffer" title='_NV_ENC_PIC_PARAMS::inputBuffer' data-ref="_NV_ENC_PIC_PARAMS::inputBuffer">inputBuffer</dfn>;                    <i class="doc">/**&lt; [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs.*/</i></td></tr>
<tr><th id="1506">1506</th><td>    <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a>                           <dfn class="decl" id="_NV_ENC_PIC_PARAMS::outputBitstream" title='_NV_ENC_PIC_PARAMS::outputBitstream' data-ref="_NV_ENC_PIC_PARAMS::outputBitstream">outputBitstream</dfn>;                <i class="doc">/**&lt; [in]: Specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API. */</i></td></tr>
<tr><th id="1507">1507</th><td>    <em>void</em>*                                       <dfn class="decl" id="_NV_ENC_PIC_PARAMS::completionEvent" title='_NV_ENC_PIC_PARAMS::completionEvent' data-ref="_NV_ENC_PIC_PARAMS::completionEvent">completionEvent</dfn>;                <i class="doc">/**&lt; [in]: Specifies an event to be signalled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer. */</i></td></tr>
<tr><th id="1508">1508</th><td>    <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>                        <dfn class="decl" id="_NV_ENC_PIC_PARAMS::bufferFmt" title='_NV_ENC_PIC_PARAMS::bufferFmt' data-ref="_NV_ENC_PIC_PARAMS::bufferFmt">bufferFmt</dfn>;                      <i class="doc">/**&lt; [in]: Specifies the input buffer format. */</i></td></tr>
<tr><th id="1509">1509</th><td>    <a class="typedef" href="#NV_ENC_PIC_STRUCT" title='NV_ENC_PIC_STRUCT' data-type='enum _NV_ENC_PIC_STRUCT' data-ref="NV_ENC_PIC_STRUCT">NV_ENC_PIC_STRUCT</a>                           <dfn class="decl" id="_NV_ENC_PIC_PARAMS::pictureStruct" title='_NV_ENC_PIC_PARAMS::pictureStruct' data-ref="_NV_ENC_PIC_PARAMS::pictureStruct">pictureStruct</dfn>;                  <i class="doc">/**&lt; [in]: Specifies structure of the input picture. */</i></td></tr>
<tr><th id="1510">1510</th><td>    <a class="typedef" href="#NV_ENC_PIC_TYPE" title='NV_ENC_PIC_TYPE' data-type='enum _NV_ENC_PIC_TYPE' data-ref="NV_ENC_PIC_TYPE">NV_ENC_PIC_TYPE</a>                             <dfn class="decl" id="_NV_ENC_PIC_PARAMS::pictureType" title='_NV_ENC_PIC_PARAMS::pictureType' data-ref="_NV_ENC_PIC_PARAMS::pictureType">pictureType</dfn>;                    <i class="doc">/**&lt; [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder. */</i></td></tr>
<tr><th id="1511">1511</th><td>    <a class="typedef" href="#NV_ENC_CODEC_PIC_PARAMS" title='NV_ENC_CODEC_PIC_PARAMS' data-type='union _NV_ENC_CODEC_PIC_PARAMS' data-ref="NV_ENC_CODEC_PIC_PARAMS">NV_ENC_CODEC_PIC_PARAMS</a>                     <dfn class="decl" id="_NV_ENC_PIC_PARAMS::codecPicParams" title='_NV_ENC_PIC_PARAMS::codecPicParams' data-ref="_NV_ENC_PIC_PARAMS::codecPicParams">codecPicParams</dfn>;                 <i class="doc">/**&lt; [in]: Specifies the codec specific per-picture encoding parameters. */</i></td></tr>
<tr><th id="1512">1512</th><td>    <a class="typedef" href="#NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE" title='NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-type='struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE' data-ref="NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE">NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE</a> <dfn class="decl" id="_NV_ENC_PIC_PARAMS::meHintCountsPerBlock" title='_NV_ENC_PIC_PARAMS::meHintCountsPerBlock' data-ref="_NV_ENC_PIC_PARAMS::meHintCountsPerBlock">meHintCountsPerBlock</dfn>[<var>2</var>];        <i class="doc">/**&lt; [in]: Specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors.</i></td></tr>
<tr><th id="1513">1513</th><td><i class="doc">                                                                                           The candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder intialization. */</i></td></tr>
<tr><th id="1514">1514</th><td>    <a class="typedef" href="#NVENC_EXTERNAL_ME_HINT" title='NVENC_EXTERNAL_ME_HINT' data-type='struct _NVENC_EXTERNAL_ME_HINT' data-ref="NVENC_EXTERNAL_ME_HINT">NVENC_EXTERNAL_ME_HINT</a>                     *<dfn class="decl" id="_NV_ENC_PIC_PARAMS::meExternalHints" title='_NV_ENC_PIC_PARAMS::meExternalHints' data-ref="_NV_ENC_PIC_PARAMS::meExternalHints">meExternalHints</dfn>;                <i class="doc">/**&lt; [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks multiplied by the total number of candidates per macroblock.</i></td></tr>
<tr><th id="1515">1515</th><td><i class="doc">                                                                                           The total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8</i></td></tr>
<tr><th id="1516">1516</th><td><i class="doc">                                                                                           + 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1) */</i></td></tr>
<tr><th id="1517">1517</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::reserved1" title='_NV_ENC_PIC_PARAMS::reserved1' data-ref="_NV_ENC_PIC_PARAMS::reserved1">reserved1</dfn>[<var>6</var>];                    <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1518">1518</th><td>    <em>void</em>*                                       <dfn class="decl" id="_NV_ENC_PIC_PARAMS::reserved2" title='_NV_ENC_PIC_PARAMS::reserved2' data-ref="_NV_ENC_PIC_PARAMS::reserved2">reserved2</dfn>[<var>2</var>];                    <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1519">1519</th><td>    <a class="typedef" href="../../../include/stdint.h.html#int8_t" title='int8_t' data-type='signed char' data-ref="int8_t">int8_t</a>                                     *<dfn class="decl" id="_NV_ENC_PIC_PARAMS::qpDeltaMap" title='_NV_ENC_PIC_PARAMS::qpDeltaMap' data-ref="_NV_ENC_PIC_PARAMS::qpDeltaMap">qpDeltaMap</dfn>;                      <i class="doc">/**&lt; [in]: Specifies the pointer to signed byte array containing QP delta value per MB in raster scan order in the current picture. This QP modifier is applied on top of the QP chosen by rate control. */</i></td></tr>
<tr><th id="1520">1520</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::qpDeltaMapSize" title='_NV_ENC_PIC_PARAMS::qpDeltaMapSize' data-ref="_NV_ENC_PIC_PARAMS::qpDeltaMapSize">qpDeltaMapSize</dfn>;                  <i class="doc">/**&lt; [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs */</i></td></tr>
<tr><th id="1521">1521</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::reservedBitFields" title='_NV_ENC_PIC_PARAMS::reservedBitFields' data-ref="_NV_ENC_PIC_PARAMS::reservedBitFields">reservedBitFields</dfn>;               <i class="doc">/**&lt; [in]: Reserved bitfields and must be set to 0 */</i></td></tr>
<tr><th id="1522">1522</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::meHintRefPicDist" title='_NV_ENC_PIC_PARAMS::meHintRefPicDist' data-ref="_NV_ENC_PIC_PARAMS::meHintRefPicDist">meHintRefPicDist</dfn>[<var>2</var>];             <i class="doc">/**&lt; [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints.</i></td></tr>
<tr><th id="1523">1523</th><td><i class="doc">                                                                                            If not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0 */</i></td></tr>
<tr><th id="1524">1524</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                                    <dfn class="decl" id="_NV_ENC_PIC_PARAMS::reserved3" title='_NV_ENC_PIC_PARAMS::reserved3' data-ref="_NV_ENC_PIC_PARAMS::reserved3">reserved3</dfn>[<var>286</var>];                  <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1525">1525</th><td>    <em>void</em>*                                       <dfn class="decl" id="_NV_ENC_PIC_PARAMS::reserved4" title='_NV_ENC_PIC_PARAMS::reserved4' data-ref="_NV_ENC_PIC_PARAMS::reserved4">reserved4</dfn>[<var>60</var>];                   <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1526">1526</th><td>} <dfn class="typedef" id="NV_ENC_PIC_PARAMS" title='NV_ENC_PIC_PARAMS' data-type='struct _NV_ENC_PIC_PARAMS' data-ref="NV_ENC_PIC_PARAMS">NV_ENC_PIC_PARAMS</dfn>;</td></tr>
<tr><th id="1527">1527</th><td></td></tr>
<tr><th id="1528">1528</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_PIC_PARAMS */</i></td></tr>
<tr><th id="1529">1529</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_PIC_PARAMS_VER" data-ref="_M/NV_ENC_PIC_PARAMS_VER">NV_ENC_PIC_PARAMS_VER</dfn> (NVENCAPI_STRUCT_VERSION(4) | ( 1&lt;&lt;31 ))</u></td></tr>
<tr><th id="1530">1530</th><td></td></tr>
<tr><th id="1531">1531</th><td></td></tr>
<tr><th id="1532">1532</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1533">1533</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_MEONLY_PARAMS</span></i></td></tr>
<tr><th id="1534">1534</th><td><i class="doc"> * MEOnly parameters that need to be sent on a per motion estimation basis.</i></td></tr>
<tr><th id="1535">1535</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1536">1536</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_MEONLY_PARAMS" title='_NV_ENC_MEONLY_PARAMS' data-ref="_NV_ENC_MEONLY_PARAMS"><a class="type" href="#_NV_ENC_MEONLY_PARAMS" title='_NV_ENC_MEONLY_PARAMS' data-ref="_NV_ENC_MEONLY_PARAMS">_NV_ENC_MEONLY_PARAMS</a></dfn></td></tr>
<tr><th id="1537">1537</th><td>{</td></tr>
<tr><th id="1538">1538</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::version" title='_NV_ENC_MEONLY_PARAMS::version' data-ref="_NV_ENC_MEONLY_PARAMS::version">version</dfn>;                            <i class="doc">/**&lt; [in]: Struct version. Must be set to NV_ENC_MEONLY_PARAMS_VER.*/</i></td></tr>
<tr><th id="1539">1539</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::inputWidth" title='_NV_ENC_MEONLY_PARAMS::inputWidth' data-ref="_NV_ENC_MEONLY_PARAMS::inputWidth">inputWidth</dfn>;                         <i class="doc">/**&lt; [in]: Specifies the input buffer width */</i></td></tr>
<tr><th id="1540">1540</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::inputHeight" title='_NV_ENC_MEONLY_PARAMS::inputHeight' data-ref="_NV_ENC_MEONLY_PARAMS::inputHeight">inputHeight</dfn>;                        <i class="doc">/**&lt; [in]: Specifies the input buffer height */</i></td></tr>
<tr><th id="1541">1541</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>        <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::inputBuffer" title='_NV_ENC_MEONLY_PARAMS::inputBuffer' data-ref="_NV_ENC_MEONLY_PARAMS::inputBuffer">inputBuffer</dfn>;                        <i class="doc">/**&lt; [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs. */</i></td></tr>
<tr><th id="1542">1542</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>        <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::referenceFrame" title='_NV_ENC_MEONLY_PARAMS::referenceFrame' data-ref="_NV_ENC_MEONLY_PARAMS::referenceFrame">referenceFrame</dfn>;                     <i class="doc">/**&lt; [in]: Specifies the reference frame pointer */</i></td></tr>
<tr><th id="1543">1543</th><td>    <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a>       <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::mvBuffer" title='_NV_ENC_MEONLY_PARAMS::mvBuffer' data-ref="_NV_ENC_MEONLY_PARAMS::mvBuffer">mvBuffer</dfn>;                           <i class="doc">/**&lt; [in]: Specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer. Client must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data. */</i></td></tr>
<tr><th id="1544">1544</th><td>    <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>    <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::bufferFmt" title='_NV_ENC_MEONLY_PARAMS::bufferFmt' data-ref="_NV_ENC_MEONLY_PARAMS::bufferFmt">bufferFmt</dfn>;                          <i class="doc">/**&lt; [in]: Specifies the input buffer format. */</i></td></tr>
<tr><th id="1545">1545</th><td>    <em>void</em>*                   <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::completionEvent" title='_NV_ENC_MEONLY_PARAMS::completionEvent' data-ref="_NV_ENC_MEONLY_PARAMS::completionEvent">completionEvent</dfn>;                    <i class="doc">/**&lt; [in]: Specifies an event to be signalled on completion of motion estimation</i></td></tr>
<tr><th id="1546">1546</th><td><i class="doc">                                                                           of this Frame [only if operating in Asynchronous mode].</i></td></tr>
<tr><th id="1547">1547</th><td><i class="doc">                                                                           Each output buffer should be associated with a distinct event pointer. */</i></td></tr>
<tr><th id="1548">1548</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::reserved1" title='_NV_ENC_MEONLY_PARAMS::reserved1' data-ref="_NV_ENC_MEONLY_PARAMS::reserved1">reserved1</dfn>[<var>252</var>];                     <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1549">1549</th><td>    <em>void</em>*                   <dfn class="decl" id="_NV_ENC_MEONLY_PARAMS::reserved2" title='_NV_ENC_MEONLY_PARAMS::reserved2' data-ref="_NV_ENC_MEONLY_PARAMS::reserved2">reserved2</dfn>[<var>60</var>];                      <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1550">1550</th><td>} <dfn class="typedef" id="NV_ENC_MEONLY_PARAMS" title='NV_ENC_MEONLY_PARAMS' data-type='struct _NV_ENC_MEONLY_PARAMS' data-ref="NV_ENC_MEONLY_PARAMS">NV_ENC_MEONLY_PARAMS</dfn>;</td></tr>
<tr><th id="1551">1551</th><td></td></tr>
<tr><th id="1552">1552</th><td><i class="doc">/** NV_ENC_MEONLY_PARAMS struct version*/</i></td></tr>
<tr><th id="1553">1553</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_MEONLY_PARAMS_VER" data-ref="_M/NV_ENC_MEONLY_PARAMS_VER">NV_ENC_MEONLY_PARAMS_VER</dfn> NVENCAPI_STRUCT_VERSION(2)</u></td></tr>
<tr><th id="1554">1554</th><td></td></tr>
<tr><th id="1555">1555</th><td></td></tr>
<tr><th id="1556">1556</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1557">1557</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_LOCK_BITSTREAM</span></i></td></tr>
<tr><th id="1558">1558</th><td><i class="doc"> * Bitstream buffer lock parameters.</i></td></tr>
<tr><th id="1559">1559</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1560">1560</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_LOCK_BITSTREAM" title='_NV_ENC_LOCK_BITSTREAM' data-ref="_NV_ENC_LOCK_BITSTREAM"><a class="type" href="#_NV_ENC_LOCK_BITSTREAM" title='_NV_ENC_LOCK_BITSTREAM' data-ref="_NV_ENC_LOCK_BITSTREAM">_NV_ENC_LOCK_BITSTREAM</a></dfn></td></tr>
<tr><th id="1561">1561</th><td>{</td></tr>
<tr><th id="1562">1562</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::version" title='_NV_ENC_LOCK_BITSTREAM::version' data-ref="_NV_ENC_LOCK_BITSTREAM::version">version</dfn>;                     <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER. */</i></td></tr>
<tr><th id="1563">1563</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::doNotWait" title='_NV_ENC_LOCK_BITSTREAM::doNotWait' data-ref="_NV_ENC_LOCK_BITSTREAM::doNotWait">doNotWait</dfn>         :<var>1</var>;        <i class="doc">/**&lt; [in]: If this flag is set, the NvEncodeAPI interface will return buffer pointer even if operation is not completed. If not set, the call will block until operation completes. */</i></td></tr>
<tr><th id="1564">1564</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::ltrFrame" title='_NV_ENC_LOCK_BITSTREAM::ltrFrame' data-ref="_NV_ENC_LOCK_BITSTREAM::ltrFrame">ltrFrame</dfn>          :<var>1</var>;        <i class="doc">/**&lt; [out]: Flag indicating this frame is marked as LTR frame */</i></td></tr>
<tr><th id="1565">1565</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::reservedBitFields" title='_NV_ENC_LOCK_BITSTREAM::reservedBitFields' data-ref="_NV_ENC_LOCK_BITSTREAM::reservedBitFields">reservedBitFields</dfn> :<var>30</var>;       <i class="doc">/**&lt; [in]: Reserved bit fields and must be set to 0 */</i></td></tr>
<tr><th id="1566">1566</th><td>    <em>void</em>*                   <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::outputBitstream" title='_NV_ENC_LOCK_BITSTREAM::outputBitstream' data-ref="_NV_ENC_LOCK_BITSTREAM::outputBitstream">outputBitstream</dfn>;             <i class="doc">/**&lt; [in]: Pointer to the bitstream buffer being locked. */</i></td></tr>
<tr><th id="1567">1567</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>*               <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::sliceOffsets" title='_NV_ENC_LOCK_BITSTREAM::sliceOffsets' data-ref="_NV_ENC_LOCK_BITSTREAM::sliceOffsets">sliceOffsets</dfn>;                <i class="doc">/**&lt; [in,out]: Array which receives the slice offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs. */</i></td></tr>
<tr><th id="1568">1568</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::frameIdx" title='_NV_ENC_LOCK_BITSTREAM::frameIdx' data-ref="_NV_ENC_LOCK_BITSTREAM::frameIdx">frameIdx</dfn>;                    <i class="doc">/**&lt; [out]: Frame no. for which the bitstream is being retrieved. */</i></td></tr>
<tr><th id="1569">1569</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::hwEncodeStatus" title='_NV_ENC_LOCK_BITSTREAM::hwEncodeStatus' data-ref="_NV_ENC_LOCK_BITSTREAM::hwEncodeStatus">hwEncodeStatus</dfn>;              <i class="doc">/**&lt; [out]: The NvEncodeAPI interface status for the locked picture. */</i></td></tr>
<tr><th id="1570">1570</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::numSlices" title='_NV_ENC_LOCK_BITSTREAM::numSlices' data-ref="_NV_ENC_LOCK_BITSTREAM::numSlices">numSlices</dfn>;                   <i class="doc">/**&lt; [out]: Number of slices in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1. */</i></td></tr>
<tr><th id="1571">1571</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes" title='_NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes' data-ref="_NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes">bitstreamSizeInBytes</dfn>;        <i class="doc">/**&lt; [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr. */</i></td></tr>
<tr><th id="1572">1572</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::outputTimeStamp" title='_NV_ENC_LOCK_BITSTREAM::outputTimeStamp' data-ref="_NV_ENC_LOCK_BITSTREAM::outputTimeStamp">outputTimeStamp</dfn>;             <i class="doc">/**&lt; [out]: Presentation timestamp associated with the encoded output. */</i></td></tr>
<tr><th id="1573">1573</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::outputDuration" title='_NV_ENC_LOCK_BITSTREAM::outputDuration' data-ref="_NV_ENC_LOCK_BITSTREAM::outputDuration">outputDuration</dfn>;              <i class="doc">/**&lt; [out]: Presentation duration associates with the encoded output. */</i></td></tr>
<tr><th id="1574">1574</th><td>    <em>void</em>*                   <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr" title='_NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr' data-ref="_NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr">bitstreamBufferPtr</dfn>;          <i class="doc">/**&lt; [out]: Pointer to the generated output bitstream.</i></td></tr>
<tr><th id="1575">1575</th><td><i class="doc">                                                                     For MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to</i></td></tr>
<tr><th id="1576">1576</th><td><i class="doc">                                                                     NV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC  */</i></td></tr>
<tr><th id="1577">1577</th><td>    <a class="typedef" href="#NV_ENC_PIC_TYPE" title='NV_ENC_PIC_TYPE' data-type='enum _NV_ENC_PIC_TYPE' data-ref="NV_ENC_PIC_TYPE">NV_ENC_PIC_TYPE</a>         <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::pictureType" title='_NV_ENC_LOCK_BITSTREAM::pictureType' data-ref="_NV_ENC_LOCK_BITSTREAM::pictureType">pictureType</dfn>;                 <i class="doc">/**&lt; [out]: Picture type of the encoded picture. */</i></td></tr>
<tr><th id="1578">1578</th><td>    <a class="typedef" href="#NV_ENC_PIC_STRUCT" title='NV_ENC_PIC_STRUCT' data-type='enum _NV_ENC_PIC_STRUCT' data-ref="NV_ENC_PIC_STRUCT">NV_ENC_PIC_STRUCT</a>       <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::pictureStruct" title='_NV_ENC_LOCK_BITSTREAM::pictureStruct' data-ref="_NV_ENC_LOCK_BITSTREAM::pictureStruct">pictureStruct</dfn>;               <i class="doc">/**&lt; [out]: Structure of the generated output picture. */</i></td></tr>
<tr><th id="1579">1579</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::frameAvgQP" title='_NV_ENC_LOCK_BITSTREAM::frameAvgQP' data-ref="_NV_ENC_LOCK_BITSTREAM::frameAvgQP">frameAvgQP</dfn>;                  <i class="doc">/**&lt; [out]: Average QP of the frame. */</i></td></tr>
<tr><th id="1580">1580</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::frameSatd" title='_NV_ENC_LOCK_BITSTREAM::frameSatd' data-ref="_NV_ENC_LOCK_BITSTREAM::frameSatd">frameSatd</dfn>;                   <i class="doc">/**&lt; [out]: Total SATD cost for whole frame. */</i></td></tr>
<tr><th id="1581">1581</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::ltrFrameIdx" title='_NV_ENC_LOCK_BITSTREAM::ltrFrameIdx' data-ref="_NV_ENC_LOCK_BITSTREAM::ltrFrameIdx">ltrFrameIdx</dfn>;                 <i class="doc">/**&lt; [out]: Frame index associated with this LTR frame. */</i></td></tr>
<tr><th id="1582">1582</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::ltrFrameBitmap" title='_NV_ENC_LOCK_BITSTREAM::ltrFrameBitmap' data-ref="_NV_ENC_LOCK_BITSTREAM::ltrFrameBitmap">ltrFrameBitmap</dfn>;              <i class="doc">/**&lt; [out]: Bitmap of LTR frames indices which were used for encoding this frame. Value of 0 if no LTR frames were used. */</i></td></tr>
<tr><th id="1583">1583</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::reserved" title='_NV_ENC_LOCK_BITSTREAM::reserved' data-ref="_NV_ENC_LOCK_BITSTREAM::reserved">reserved</dfn> [<var>236</var>];              <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1584">1584</th><td>    <em>void</em>*                   <dfn class="decl" id="_NV_ENC_LOCK_BITSTREAM::reserved2" title='_NV_ENC_LOCK_BITSTREAM::reserved2' data-ref="_NV_ENC_LOCK_BITSTREAM::reserved2">reserved2</dfn>[<var>64</var>];               <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1585">1585</th><td>} <dfn class="typedef" id="NV_ENC_LOCK_BITSTREAM" title='NV_ENC_LOCK_BITSTREAM' data-type='struct _NV_ENC_LOCK_BITSTREAM' data-ref="NV_ENC_LOCK_BITSTREAM">NV_ENC_LOCK_BITSTREAM</dfn>;</td></tr>
<tr><th id="1586">1586</th><td></td></tr>
<tr><th id="1587">1587</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_LOCK_BITSTREAM */</i></td></tr>
<tr><th id="1588">1588</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_LOCK_BITSTREAM_VER" data-ref="_M/NV_ENC_LOCK_BITSTREAM_VER">NV_ENC_LOCK_BITSTREAM_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1589">1589</th><td></td></tr>
<tr><th id="1590">1590</th><td></td></tr>
<tr><th id="1591">1591</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1592">1592</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_LOCK_INPUT_BUFFER</span></i></td></tr>
<tr><th id="1593">1593</th><td><i class="doc"> * Uncompressed Input Buffer lock parameters.</i></td></tr>
<tr><th id="1594">1594</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1595">1595</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_LOCK_INPUT_BUFFER" title='_NV_ENC_LOCK_INPUT_BUFFER' data-ref="_NV_ENC_LOCK_INPUT_BUFFER"><a class="type" href="#_NV_ENC_LOCK_INPUT_BUFFER" title='_NV_ENC_LOCK_INPUT_BUFFER' data-ref="_NV_ENC_LOCK_INPUT_BUFFER">_NV_ENC_LOCK_INPUT_BUFFER</a></dfn></td></tr>
<tr><th id="1596">1596</th><td>{</td></tr>
<tr><th id="1597">1597</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::version" title='_NV_ENC_LOCK_INPUT_BUFFER::version' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::version">version</dfn>;                   <i class="doc">/**&lt; [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER. */</i></td></tr>
<tr><th id="1598">1598</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::doNotWait" title='_NV_ENC_LOCK_INPUT_BUFFER::doNotWait' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::doNotWait">doNotWait</dfn>         :<var>1</var>;      <i class="doc">/**&lt; [in]:  Set to 1 to make ::NvEncLockInputBuffer() a unblocking call. If the encoding is not completed, driver will return ::NV_ENC_ERR_ENCODER_BUSY error code. */</i></td></tr>
<tr><th id="1599">1599</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::reservedBitFields" title='_NV_ENC_LOCK_INPUT_BUFFER::reservedBitFields' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::reservedBitFields">reservedBitFields</dfn> :<var>31</var>;     <i class="doc">/**&lt; [in]:  Reserved bitfields and must be set to 0 */</i></td></tr>
<tr><th id="1600">1600</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>          <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::inputBuffer" title='_NV_ENC_LOCK_INPUT_BUFFER::inputBuffer' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::inputBuffer">inputBuffer</dfn>;               <i class="doc">/**&lt; [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API. */</i></td></tr>
<tr><th id="1601">1601</th><td>    <em>void</em>*                     <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr" title='_NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr">bufferDataPtr</dfn>;             <i class="doc">/**&lt; [out]: Pointed to the locked input buffer data. Client can only access input buffer using the<span class="command"> \p</span> <span class="arg">bufferDataPtr.</span> */</i></td></tr>
<tr><th id="1602">1602</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::pitch" title='_NV_ENC_LOCK_INPUT_BUFFER::pitch' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::pitch">pitch</dfn>;                     <i class="doc">/**&lt; [out]: Pitch of the locked input buffer. */</i></td></tr>
<tr><th id="1603">1603</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                  <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::reserved1" title='_NV_ENC_LOCK_INPUT_BUFFER::reserved1' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::reserved1">reserved1</dfn>[<var>251</var>];            <i class="doc">/**&lt; [in]:  Reserved and must be set to 0  */</i></td></tr>
<tr><th id="1604">1604</th><td>    <em>void</em>*                     <dfn class="decl" id="_NV_ENC_LOCK_INPUT_BUFFER::reserved2" title='_NV_ENC_LOCK_INPUT_BUFFER::reserved2' data-ref="_NV_ENC_LOCK_INPUT_BUFFER::reserved2">reserved2</dfn>[<var>64</var>];             <i class="doc">/**&lt; [in]:  Reserved and must be set to NULL  */</i></td></tr>
<tr><th id="1605">1605</th><td>} <dfn class="typedef" id="NV_ENC_LOCK_INPUT_BUFFER" title='NV_ENC_LOCK_INPUT_BUFFER' data-type='struct _NV_ENC_LOCK_INPUT_BUFFER' data-ref="NV_ENC_LOCK_INPUT_BUFFER">NV_ENC_LOCK_INPUT_BUFFER</dfn>;</td></tr>
<tr><th id="1606">1606</th><td></td></tr>
<tr><th id="1607">1607</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_LOCK_INPUT_BUFFER */</i></td></tr>
<tr><th id="1608">1608</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_LOCK_INPUT_BUFFER_VER" data-ref="_M/NV_ENC_LOCK_INPUT_BUFFER_VER">NV_ENC_LOCK_INPUT_BUFFER_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1609">1609</th><td></td></tr>
<tr><th id="1610">1610</th><td></td></tr>
<tr><th id="1611">1611</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1612">1612</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_MAP_INPUT_RESOURCE</span></i></td></tr>
<tr><th id="1613">1613</th><td><i class="doc"> * Map an input resource to a Nvidia Encoder Input Buffer</i></td></tr>
<tr><th id="1614">1614</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1615">1615</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_MAP_INPUT_RESOURCE" title='_NV_ENC_MAP_INPUT_RESOURCE' data-ref="_NV_ENC_MAP_INPUT_RESOURCE"><a class="type" href="#_NV_ENC_MAP_INPUT_RESOURCE" title='_NV_ENC_MAP_INPUT_RESOURCE' data-ref="_NV_ENC_MAP_INPUT_RESOURCE">_NV_ENC_MAP_INPUT_RESOURCE</a></dfn></td></tr>
<tr><th id="1616">1616</th><td>{</td></tr>
<tr><th id="1617">1617</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                   <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::version" title='_NV_ENC_MAP_INPUT_RESOURCE::version' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::version">version</dfn>;                   <i class="doc">/**&lt; [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER. */</i></td></tr>
<tr><th id="1618">1618</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                   <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::subResourceIndex" title='_NV_ENC_MAP_INPUT_RESOURCE::subResourceIndex' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::subResourceIndex">subResourceIndex</dfn>;          <i class="doc">/**&lt; [in]:  Deprecated. Do not use. */</i></td></tr>
<tr><th id="1619">1619</th><td>    <em>void</em>*                      <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::inputResource" title='_NV_ENC_MAP_INPUT_RESOURCE::inputResource' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::inputResource">inputResource</dfn>;             <i class="doc">/**&lt; [in]:  Deprecated. Do not use. */</i></td></tr>
<tr><th id="1620">1620</th><td>    <a class="typedef" href="#NV_ENC_REGISTERED_PTR" title='NV_ENC_REGISTERED_PTR' data-type='void *' data-ref="NV_ENC_REGISTERED_PTR">NV_ENC_REGISTERED_PTR</a>      <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::registeredResource" title='_NV_ENC_MAP_INPUT_RESOURCE::registeredResource' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::registeredResource">registeredResource</dfn>;        <i class="doc">/**&lt; [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource. */</i></td></tr>
<tr><th id="1621">1621</th><td>    <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a>           <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::mappedResource" title='_NV_ENC_MAP_INPUT_RESOURCE::mappedResource' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::mappedResource">mappedResource</dfn>;            <i class="doc">/**&lt; [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API. */</i></td></tr>
<tr><th id="1622">1622</th><td>    <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>       <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::mappedBufferFmt" title='_NV_ENC_MAP_INPUT_RESOURCE::mappedBufferFmt' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::mappedBufferFmt">mappedBufferFmt</dfn>;           <i class="doc">/**&lt; [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer. */</i></td></tr>
<tr><th id="1623">1623</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                   <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::reserved1" title='_NV_ENC_MAP_INPUT_RESOURCE::reserved1' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::reserved1">reserved1</dfn>[<var>251</var>];            <i class="doc">/**&lt; [in]:  Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1624">1624</th><td>    <em>void</em>*                      <dfn class="decl" id="_NV_ENC_MAP_INPUT_RESOURCE::reserved2" title='_NV_ENC_MAP_INPUT_RESOURCE::reserved2' data-ref="_NV_ENC_MAP_INPUT_RESOURCE::reserved2">reserved2</dfn>[<var>63</var>];             <i class="doc">/**&lt; [in]:  Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1625">1625</th><td>} <dfn class="typedef" id="NV_ENC_MAP_INPUT_RESOURCE" title='NV_ENC_MAP_INPUT_RESOURCE' data-type='struct _NV_ENC_MAP_INPUT_RESOURCE' data-ref="NV_ENC_MAP_INPUT_RESOURCE">NV_ENC_MAP_INPUT_RESOURCE</dfn>;</td></tr>
<tr><th id="1626">1626</th><td></td></tr>
<tr><th id="1627">1627</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_MAP_INPUT_RESOURCE */</i></td></tr>
<tr><th id="1628">1628</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_MAP_INPUT_RESOURCE_VER" data-ref="_M/NV_ENC_MAP_INPUT_RESOURCE_VER">NV_ENC_MAP_INPUT_RESOURCE_VER</dfn> NVENCAPI_STRUCT_VERSION(4)</u></td></tr>
<tr><th id="1629">1629</th><td></td></tr>
<tr><th id="1630">1630</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1631">1631</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_REGISTER_RESOURCE</span></i></td></tr>
<tr><th id="1632">1632</th><td><i class="doc"> * Register a resource for future use with the Nvidia Video Encoder Interface.</i></td></tr>
<tr><th id="1633">1633</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1634">1634</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_REGISTER_RESOURCE" title='_NV_ENC_REGISTER_RESOURCE' data-ref="_NV_ENC_REGISTER_RESOURCE"><a class="type" href="#_NV_ENC_REGISTER_RESOURCE" title='_NV_ENC_REGISTER_RESOURCE' data-ref="_NV_ENC_REGISTER_RESOURCE">_NV_ENC_REGISTER_RESOURCE</a></dfn></td></tr>
<tr><th id="1635">1635</th><td>{</td></tr>
<tr><th id="1636">1636</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::version" title='_NV_ENC_REGISTER_RESOURCE::version' data-ref="_NV_ENC_REGISTER_RESOURCE::version">version</dfn>;                        <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_REGISTER_RESOURCE_VER. */</i></td></tr>
<tr><th id="1637">1637</th><td>    <a class="typedef" href="#NV_ENC_INPUT_RESOURCE_TYPE" title='NV_ENC_INPUT_RESOURCE_TYPE' data-type='enum _NV_ENC_INPUT_RESOURCE_TYPE' data-ref="NV_ENC_INPUT_RESOURCE_TYPE">NV_ENC_INPUT_RESOURCE_TYPE</a>  <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::resourceType" title='_NV_ENC_REGISTER_RESOURCE::resourceType' data-ref="_NV_ENC_REGISTER_RESOURCE::resourceType">resourceType</dfn>;                   <i class="doc">/**&lt; [in]: Specifies the type of resource to be registered. Supported values are ::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX, ::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR. */</i></td></tr>
<tr><th id="1638">1638</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::width" title='_NV_ENC_REGISTER_RESOURCE::width' data-ref="_NV_ENC_REGISTER_RESOURCE::width">width</dfn>;                          <i class="doc">/**&lt; [in]: Input buffer Width. */</i></td></tr>
<tr><th id="1639">1639</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::height" title='_NV_ENC_REGISTER_RESOURCE::height' data-ref="_NV_ENC_REGISTER_RESOURCE::height">height</dfn>;                         <i class="doc">/**&lt; [in]: Input buffer Height. */</i></td></tr>
<tr><th id="1640">1640</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::pitch" title='_NV_ENC_REGISTER_RESOURCE::pitch' data-ref="_NV_ENC_REGISTER_RESOURCE::pitch">pitch</dfn>;                          <i class="doc">/**&lt; [in]: Input buffer Pitch.  */</i></td></tr>
<tr><th id="1641">1641</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::subResourceIndex" title='_NV_ENC_REGISTER_RESOURCE::subResourceIndex' data-ref="_NV_ENC_REGISTER_RESOURCE::subResourceIndex">subResourceIndex</dfn>;               <i class="doc">/**&lt; [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces. */</i></td></tr>
<tr><th id="1642">1642</th><td>    <em>void</em>*                       <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::resourceToRegister" title='_NV_ENC_REGISTER_RESOURCE::resourceToRegister' data-ref="_NV_ENC_REGISTER_RESOURCE::resourceToRegister">resourceToRegister</dfn>;             <i class="doc">/**&lt; [in]: Handle to the resource that is being registered. */</i></td></tr>
<tr><th id="1643">1643</th><td>    <a class="typedef" href="#NV_ENC_REGISTERED_PTR" title='NV_ENC_REGISTERED_PTR' data-type='void *' data-ref="NV_ENC_REGISTERED_PTR">NV_ENC_REGISTERED_PTR</a>       <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::registeredResource" title='_NV_ENC_REGISTER_RESOURCE::registeredResource' data-ref="_NV_ENC_REGISTER_RESOURCE::registeredResource">registeredResource</dfn>;             <i class="doc">/**&lt; [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface. */</i></td></tr>
<tr><th id="1644">1644</th><td>    <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>        <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::bufferFormat" title='_NV_ENC_REGISTER_RESOURCE::bufferFormat' data-ref="_NV_ENC_REGISTER_RESOURCE::bufferFormat">bufferFormat</dfn>;                   <i class="doc">/**&lt; [in]: Buffer format of resource to be registered. */</i></td></tr>
<tr><th id="1645">1645</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                    <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::reserved1" title='_NV_ENC_REGISTER_RESOURCE::reserved1' data-ref="_NV_ENC_REGISTER_RESOURCE::reserved1">reserved1</dfn>[<var>248</var>];                 <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1646">1646</th><td>    <em>void</em>*                       <dfn class="decl" id="_NV_ENC_REGISTER_RESOURCE::reserved2" title='_NV_ENC_REGISTER_RESOURCE::reserved2' data-ref="_NV_ENC_REGISTER_RESOURCE::reserved2">reserved2</dfn>[<var>62</var>];                  <i class="doc">/**&lt; [in]: Reserved and must be set to NULL. */</i></td></tr>
<tr><th id="1647">1647</th><td>} <dfn class="typedef" id="NV_ENC_REGISTER_RESOURCE" title='NV_ENC_REGISTER_RESOURCE' data-type='struct _NV_ENC_REGISTER_RESOURCE' data-ref="NV_ENC_REGISTER_RESOURCE">NV_ENC_REGISTER_RESOURCE</dfn>;</td></tr>
<tr><th id="1648">1648</th><td></td></tr>
<tr><th id="1649">1649</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_REGISTER_RESOURCE */</i></td></tr>
<tr><th id="1650">1650</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_REGISTER_RESOURCE_VER" data-ref="_M/NV_ENC_REGISTER_RESOURCE_VER">NV_ENC_REGISTER_RESOURCE_VER</dfn> NVENCAPI_STRUCT_VERSION(3)</u></td></tr>
<tr><th id="1651">1651</th><td></td></tr>
<tr><th id="1652">1652</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1653">1653</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_STAT</span></i></td></tr>
<tr><th id="1654">1654</th><td><i class="doc"> * Encode Stats structure.</i></td></tr>
<tr><th id="1655">1655</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1656">1656</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_STAT" title='_NV_ENC_STAT' data-ref="_NV_ENC_STAT"><a class="type" href="#_NV_ENC_STAT" title='_NV_ENC_STAT' data-ref="_NV_ENC_STAT">_NV_ENC_STAT</a></dfn></td></tr>
<tr><th id="1657">1657</th><td>{</td></tr>
<tr><th id="1658">1658</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::version" title='_NV_ENC_STAT::version' data-ref="_NV_ENC_STAT::version">version</dfn>;                         <i class="doc">/**&lt; [in]:  Struct version. Must be set to ::NV_ENC_STAT_VER. */</i></td></tr>
<tr><th id="1659">1659</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::reserved" title='_NV_ENC_STAT::reserved' data-ref="_NV_ENC_STAT::reserved">reserved</dfn>;                        <i class="doc">/**&lt; [in]:  Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1660">1660</th><td>    <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a>   <dfn class="decl" id="_NV_ENC_STAT::outputBitStream" title='_NV_ENC_STAT::outputBitStream' data-ref="_NV_ENC_STAT::outputBitStream">outputBitStream</dfn>;                 <i class="doc">/**&lt; [out]: Specifies the pointer to output bitstream. */</i></td></tr>
<tr><th id="1661">1661</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::bitStreamSize" title='_NV_ENC_STAT::bitStreamSize' data-ref="_NV_ENC_STAT::bitStreamSize">bitStreamSize</dfn>;                   <i class="doc">/**&lt; [out]: Size of generated bitstream in bytes. */</i></td></tr>
<tr><th id="1662">1662</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::picType" title='_NV_ENC_STAT::picType' data-ref="_NV_ENC_STAT::picType">picType</dfn>;                         <i class="doc">/**&lt; [out]: Picture type of encoded picture. See ::NV_ENC_PIC_TYPE. */</i></td></tr>
<tr><th id="1663">1663</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::lastValidByteOffset" title='_NV_ENC_STAT::lastValidByteOffset' data-ref="_NV_ENC_STAT::lastValidByteOffset">lastValidByteOffset</dfn>;             <i class="doc">/**&lt; [out]: Offset of last valid bytes of completed bitstream */</i></td></tr>
<tr><th id="1664">1664</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::sliceOffsets" title='_NV_ENC_STAT::sliceOffsets' data-ref="_NV_ENC_STAT::sliceOffsets">sliceOffsets</dfn>[<var>16</var>];                <i class="doc">/**&lt; [out]: Offsets of each slice */</i></td></tr>
<tr><th id="1665">1665</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::picIdx" title='_NV_ENC_STAT::picIdx' data-ref="_NV_ENC_STAT::picIdx">picIdx</dfn>;                          <i class="doc">/**&lt; [out]: Picture number */</i></td></tr>
<tr><th id="1666">1666</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_STAT::reserved1" title='_NV_ENC_STAT::reserved1' data-ref="_NV_ENC_STAT::reserved1">reserved1</dfn>[<var>233</var>];                  <i class="doc">/**&lt; [in]:  Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1667">1667</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_STAT::reserved2" title='_NV_ENC_STAT::reserved2' data-ref="_NV_ENC_STAT::reserved2">reserved2</dfn>[<var>64</var>];                   <i class="doc">/**&lt; [in]:  Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1668">1668</th><td>} <dfn class="typedef" id="NV_ENC_STAT" title='NV_ENC_STAT' data-type='struct _NV_ENC_STAT' data-ref="NV_ENC_STAT">NV_ENC_STAT</dfn>;</td></tr>
<tr><th id="1669">1669</th><td></td></tr>
<tr><th id="1670">1670</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_STAT */</i></td></tr>
<tr><th id="1671">1671</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_STAT_VER" data-ref="_M/NV_ENC_STAT_VER">NV_ENC_STAT_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1672">1672</th><td></td></tr>
<tr><th id="1673">1673</th><td></td></tr>
<tr><th id="1674">1674</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1675">1675</th><td><i class="doc"> * <span class="command">\struct</span> <span class="verb">_NV_ENC_SEQUENCE_PARAM_PAYLOAD</span></i></td></tr>
<tr><th id="1676">1676</th><td><i class="doc"> * Sequence and picture paramaters payload.</i></td></tr>
<tr><th id="1677">1677</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1678">1678</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD"><a class="type" href="#_NV_ENC_SEQUENCE_PARAM_PAYLOAD" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD">_NV_ENC_SEQUENCE_PARAM_PAYLOAD</a></dfn></td></tr>
<tr><th id="1679">1679</th><td>{</td></tr>
<tr><th id="1680">1680</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::version" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::version' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::version">version</dfn>;                         <i class="doc">/**&lt; [in]:  Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER. */</i></td></tr>
<tr><th id="1681">1681</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize">inBufferSize</dfn>;                    <i class="doc">/**&lt; [in]:  Specifies the size of the spsppsBuffer provied by the client */</i></td></tr>
<tr><th id="1682">1682</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsId" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsId' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsId">spsId</dfn>;                           <i class="doc">/**&lt; [in]:  Specifies the SPS id to be used in sequence header. Default value is 0.  */</i></td></tr>
<tr><th id="1683">1683</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::ppsId" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::ppsId' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::ppsId">ppsId</dfn>;                           <i class="doc">/**&lt; [in]:  Specifies the PPS id to be used in picture header. Default value is 0.  */</i></td></tr>
<tr><th id="1684">1684</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer">spsppsBuffer</dfn>;                    <i class="doc">/**&lt; [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize. It is the client's responsibility to manage this memory. */</i></td></tr>
<tr><th id="1685">1685</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>*           <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize">outSPSPPSPayloadSize</dfn>;            <i class="doc">/**&lt; [out]: Size of the sequence and picture header in  bytes written by the NvEncodeAPI interface to the SPSPPSBuffer. */</i></td></tr>
<tr><th id="1686">1686</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved">reserved</dfn> [<var>250</var>];                  <i class="doc">/**&lt; [in]:  Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1687">1687</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved2" title='_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved2' data-ref="_NV_ENC_SEQUENCE_PARAM_PAYLOAD::reserved2">reserved2</dfn>[<var>64</var>];                   <i class="doc">/**&lt; [in]:  Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1688">1688</th><td>} <dfn class="typedef" id="NV_ENC_SEQUENCE_PARAM_PAYLOAD" title='NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-type='struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-ref="NV_ENC_SEQUENCE_PARAM_PAYLOAD">NV_ENC_SEQUENCE_PARAM_PAYLOAD</dfn>;</td></tr>
<tr><th id="1689">1689</th><td></td></tr>
<tr><th id="1690">1690</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD */</i></td></tr>
<tr><th id="1691">1691</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER" data-ref="_M/NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER">NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1692">1692</th><td></td></tr>
<tr><th id="1693">1693</th><td></td></tr>
<tr><th id="1694">1694</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1695">1695</th><td><i class="doc"> * Event registration/unregistration parameters.</i></td></tr>
<tr><th id="1696">1696</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1697">1697</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_EVENT_PARAMS" title='_NV_ENC_EVENT_PARAMS' data-ref="_NV_ENC_EVENT_PARAMS"><a class="type" href="#_NV_ENC_EVENT_PARAMS" title='_NV_ENC_EVENT_PARAMS' data-ref="_NV_ENC_EVENT_PARAMS">_NV_ENC_EVENT_PARAMS</a></dfn></td></tr>
<tr><th id="1698">1698</th><td>{</td></tr>
<tr><th id="1699">1699</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_EVENT_PARAMS::version" title='_NV_ENC_EVENT_PARAMS::version' data-ref="_NV_ENC_EVENT_PARAMS::version">version</dfn>;                          <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER. */</i></td></tr>
<tr><th id="1700">1700</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_EVENT_PARAMS::reserved" title='_NV_ENC_EVENT_PARAMS::reserved' data-ref="_NV_ENC_EVENT_PARAMS::reserved">reserved</dfn>;                         <i class="doc">/**&lt; [in]: Reserved and must be set to 0 */</i></td></tr>
<tr><th id="1701">1701</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_EVENT_PARAMS::completionEvent" title='_NV_ENC_EVENT_PARAMS::completionEvent' data-ref="_NV_ENC_EVENT_PARAMS::completionEvent">completionEvent</dfn>;                  <i class="doc">/**&lt; [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface. */</i></td></tr>
<tr><th id="1702">1702</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_EVENT_PARAMS::reserved1" title='_NV_ENC_EVENT_PARAMS::reserved1' data-ref="_NV_ENC_EVENT_PARAMS::reserved1">reserved1</dfn>[<var>253</var>];                   <i class="doc">/**&lt; [in]: Reserved and must be set to 0    */</i></td></tr>
<tr><th id="1703">1703</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_EVENT_PARAMS::reserved2" title='_NV_ENC_EVENT_PARAMS::reserved2' data-ref="_NV_ENC_EVENT_PARAMS::reserved2">reserved2</dfn>[<var>64</var>];                    <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1704">1704</th><td>} <dfn class="typedef" id="NV_ENC_EVENT_PARAMS" title='NV_ENC_EVENT_PARAMS' data-type='struct _NV_ENC_EVENT_PARAMS' data-ref="NV_ENC_EVENT_PARAMS">NV_ENC_EVENT_PARAMS</dfn>;</td></tr>
<tr><th id="1705">1705</th><td></td></tr>
<tr><th id="1706">1706</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_EVENT_PARAMS */</i></td></tr>
<tr><th id="1707">1707</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_EVENT_PARAMS_VER" data-ref="_M/NV_ENC_EVENT_PARAMS_VER">NV_ENC_EVENT_PARAMS_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1708">1708</th><td></td></tr>
<tr><th id="1709">1709</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1710">1710</th><td><i class="doc"> * Encoder Session Creation parameters</i></td></tr>
<tr><th id="1711">1711</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1712">1712</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS"><a class="type" href="#_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS">_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS</a></dfn></td></tr>
<tr><th id="1713">1713</th><td>{</td></tr>
<tr><th id="1714">1714</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::version" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::version' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::version">version</dfn>;                          <i class="doc">/**&lt; [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER. */</i></td></tr>
<tr><th id="1715">1715</th><td>    <a class="typedef" href="#NV_ENC_DEVICE_TYPE" title='NV_ENC_DEVICE_TYPE' data-type='enum _NV_ENC_DEVICE_TYPE' data-ref="NV_ENC_DEVICE_TYPE">NV_ENC_DEVICE_TYPE</a>  <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::deviceType" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::deviceType' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::deviceType">deviceType</dfn>;                       <i class="doc">/**&lt; [in]: Specified the device Type */</i></td></tr>
<tr><th id="1716">1716</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::device" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::device' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::device">device</dfn>;                           <i class="doc">/**&lt; [in]: Pointer to client device. */</i></td></tr>
<tr><th id="1717">1717</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved">reserved</dfn>;                         <i class="doc">/**&lt; [in]: Reserved and must be set to 0. */</i></td></tr>
<tr><th id="1718">1718</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::apiVersion" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::apiVersion' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::apiVersion">apiVersion</dfn>;                       <i class="doc">/**&lt; [in]: API version. Should be set to NVENCAPI_VERSION. */</i></td></tr>
<tr><th id="1719">1719</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>            <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved1" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved1' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved1">reserved1</dfn>[<var>253</var>];                   <i class="doc">/**&lt; [in]: Reserved and must be set to 0    */</i></td></tr>
<tr><th id="1720">1720</th><td>    <em>void</em>*               <dfn class="decl" id="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved2" title='_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved2' data-ref="_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS::reserved2">reserved2</dfn>[<var>64</var>];                    <i class="doc">/**&lt; [in]: Reserved and must be set to NULL */</i></td></tr>
<tr><th id="1721">1721</th><td>} <dfn class="typedef" id="NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS" title='NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS' data-type='struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS' data-ref="NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS">NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS</dfn>;</td></tr>
<tr><th id="1722">1722</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS */</i></td></tr>
<tr><th id="1723">1723</th><td><u>#define <dfn class="macro" id="_M/NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER" data-ref="_M/NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER">NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER</dfn> NVENCAPI_STRUCT_VERSION(1)</u></td></tr>
<tr><th id="1724">1724</th><td></td></tr>
<tr><th id="1725">1725</th><td><i class="doc">/** @} */</i> <i>/* END ENCODER_STRUCTURE */</i></td></tr>
<tr><th id="1726">1726</th><td></td></tr>
<tr><th id="1727">1727</th><td></td></tr>
<tr><th id="1728">1728</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1729">1729</th><td><i class="doc"> * <span class="command">\addtogroup</span> <span class="verb">ENCODE_FUNC NvEncodeAPI Functions</span></i></td></tr>
<tr><th id="1730">1730</th><td><i class="doc"> * @{</i></td></tr>
<tr><th id="1731">1731</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1732">1732</th><td><i class="doc"></i></td></tr>
<tr><th id="1733">1733</th><td><i class="doc">// NvEncOpenEncodeSession</i></td></tr>
<tr><th id="1734">1734</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1735">1735</th><td><i class="doc"> * <span class="command">\brief</span> Opens an encoding session.</i></td></tr>
<tr><th id="1736">1736</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1737">1737</th><td><i class="doc"> * Deprecated.</i></td></tr>
<tr><th id="1738">1738</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1739">1739</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1740">1740</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_CAL<span class="command">L\n</span></i></td></tr>
<tr><th id="1741">1741</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1742">1742</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1743">1743</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncOpenEncodeSession" title='NvEncOpenEncodeSession' data-ref="NvEncOpenEncodeSession">NvEncOpenEncodeSession</dfn>                     (<em>void</em>* <dfn class="local col6 decl" id="6device" title='device' data-type='void *' data-ref="6device">device</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col7 decl" id="7deviceType" title='deviceType' data-type='uint32_t' data-ref="7deviceType">deviceType</dfn>, <em>void</em>** <dfn class="local col8 decl" id="8encoder" title='encoder' data-type='void **' data-ref="8encoder">encoder</dfn>);</td></tr>
<tr><th id="1744">1744</th><td></td></tr>
<tr><th id="1745">1745</th><td><i>// NvEncGetEncodeGuidCount</i></td></tr>
<tr><th id="1746">1746</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1747">1747</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves the number of supported encode GUIDs.</i></td></tr>
<tr><th id="1748">1748</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1749">1749</th><td><i class="doc"> * The function returns the number of codec guids supported by the NvEncodeAPI</i></td></tr>
<tr><th id="1750">1750</th><td><i class="doc"> * interface.</i></td></tr>
<tr><th id="1751">1751</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1752">1752</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1753">1753</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1754">1754</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">encodeGUIDCount</span></i></td></tr>
<tr><th id="1755">1755</th><td><i class="doc"> *   Number of supported encode GUIDs.</i></td></tr>
<tr><th id="1756">1756</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1757">1757</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1758">1758</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1759">1759</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1760">1760</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1761">1761</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1762">1762</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1763">1763</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1764">1764</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1765">1765</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1766">1766</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1767">1767</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1768">1768</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeGUIDCount" title='NvEncGetEncodeGUIDCount' data-ref="NvEncGetEncodeGUIDCount">NvEncGetEncodeGUIDCount</dfn>                    (<em>void</em>* <dfn class="local col9 decl" id="9encoder" title='encoder' data-type='void *' data-ref="9encoder">encoder</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col0 decl" id="10encodeGUIDCount" title='encodeGUIDCount' data-type='uint32_t *' data-ref="10encodeGUIDCount">encodeGUIDCount</dfn>);</td></tr>
<tr><th id="1769">1769</th><td></td></tr>
<tr><th id="1770">1770</th><td></td></tr>
<tr><th id="1771">1771</th><td><i>// NvEncGetEncodeGUIDs</i></td></tr>
<tr><th id="1772">1772</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1773">1773</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves an array of supported encoder codec GUIDs.</i></td></tr>
<tr><th id="1774">1774</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1775">1775</th><td><i class="doc"> * The function returns an array of codec guids supported by the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1776">1776</th><td><i class="doc"> * The client must allocate an array where the NvEncodeAPI interface can</i></td></tr>
<tr><th id="1777">1777</th><td><i class="doc"> * fill the supported guids and pass the pointer in<span class="command"> \p</span> <span class="arg">*GUIDs</span> parameter.</i></td></tr>
<tr><th id="1778">1778</th><td><i class="doc"> * The size of the array can be determined by using ::NvEncGetEncodeGUIDCount() API.</i></td></tr>
<tr><th id="1779">1779</th><td><i class="doc"> * The Nvidia Encoding interface returns the number of codec guids it has actually</i></td></tr>
<tr><th id="1780">1780</th><td><i class="doc"> * filled in the guid array in the<span class="command"> \p</span> <span class="arg">GUIDCount</span> parameter.</i></td></tr>
<tr><th id="1781">1781</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1782">1782</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1783">1783</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1784">1784</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">guidArraySize</span></i></td></tr>
<tr><th id="1785">1785</th><td><i class="doc"> *   Number of GUIDs to retrieved. Should be set to the number retrieved using</i></td></tr>
<tr><th id="1786">1786</th><td><i class="doc"> *   ::NvEncGetEncodeGUIDCount.</i></td></tr>
<tr><th id="1787">1787</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">GUIDs</span></i></td></tr>
<tr><th id="1788">1788</th><td><i class="doc"> *   Array of supported Encode GUIDs.</i></td></tr>
<tr><th id="1789">1789</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">GUIDCount</span></i></td></tr>
<tr><th id="1790">1790</th><td><i class="doc"> *   Number of supported Encode GUIDs.</i></td></tr>
<tr><th id="1791">1791</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1792">1792</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1793">1793</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1794">1794</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1795">1795</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1796">1796</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1797">1797</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1798">1798</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1799">1799</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1800">1800</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1801">1801</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1802">1802</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1803">1803</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeGUIDs" title='NvEncGetEncodeGUIDs' data-ref="NvEncGetEncodeGUIDs">NvEncGetEncodeGUIDs</dfn>                        (<em>void</em>* <dfn class="local col1 decl" id="11encoder" title='encoder' data-type='void *' data-ref="11encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col2 decl" id="12GUIDs" title='GUIDs' data-type='GUID *' data-ref="12GUIDs">GUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col3 decl" id="13guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="13guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col4 decl" id="14GUIDCount" title='GUIDCount' data-type='uint32_t *' data-ref="14GUIDCount">GUIDCount</dfn>);</td></tr>
<tr><th id="1804">1804</th><td></td></tr>
<tr><th id="1805">1805</th><td></td></tr>
<tr><th id="1806">1806</th><td><i>// NvEncGetEncodeProfileGuidCount</i></td></tr>
<tr><th id="1807">1807</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1808">1808</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves the number of supported profile GUIDs.</i></td></tr>
<tr><th id="1809">1809</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1810">1810</th><td><i class="doc"> * The function returns the number of profile GUIDs supported for a given codec.</i></td></tr>
<tr><th id="1811">1811</th><td><i class="doc"> * The client must first enumerate the codec guids supported by the NvEncodeAPI</i></td></tr>
<tr><th id="1812">1812</th><td><i class="doc"> * interface. After determining the codec guid, it can query the NvEncodeAPI</i></td></tr>
<tr><th id="1813">1813</th><td><i class="doc"> * interface to determine the number of profile guids supported for a particular</i></td></tr>
<tr><th id="1814">1814</th><td><i class="doc"> * codec guid.</i></td></tr>
<tr><th id="1815">1815</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1816">1816</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1817">1817</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1818">1818</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1819">1819</th><td><i class="doc"> *   The codec guid for which the profile guids are being enumerated.</i></td></tr>
<tr><th id="1820">1820</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">encodeProfileGUIDCount</span></i></td></tr>
<tr><th id="1821">1821</th><td><i class="doc"> *   Number of encode profiles supported for the given encodeGUID.</i></td></tr>
<tr><th id="1822">1822</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1823">1823</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1824">1824</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1825">1825</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1826">1826</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1827">1827</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1828">1828</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1829">1829</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1830">1830</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1831">1831</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1832">1832</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1833">1833</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1834">1834</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeProfileGUIDCount" title='NvEncGetEncodeProfileGUIDCount' data-ref="NvEncGetEncodeProfileGUIDCount">NvEncGetEncodeProfileGUIDCount</dfn>                    (<em>void</em>* <dfn class="local col5 decl" id="15encoder" title='encoder' data-type='void *' data-ref="15encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col6 decl" id="16encodeGUID" title='encodeGUID' data-type='GUID' data-ref="16encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col7 decl" id="17encodeProfileGUIDCount" title='encodeProfileGUIDCount' data-type='uint32_t *' data-ref="17encodeProfileGUIDCount">encodeProfileGUIDCount</dfn>);</td></tr>
<tr><th id="1835">1835</th><td></td></tr>
<tr><th id="1836">1836</th><td></td></tr>
<tr><th id="1837">1837</th><td><i>// NvEncGetEncodeProfileGUIDs</i></td></tr>
<tr><th id="1838">1838</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1839">1839</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves an array of supported encode profile GUIDs.</i></td></tr>
<tr><th id="1840">1840</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1841">1841</th><td><i class="doc"> * The function returns an array of supported profile guids for a particular</i></td></tr>
<tr><th id="1842">1842</th><td><i class="doc"> * codec guid. The client must allocate an array where the NvEncodeAPI interface</i></td></tr>
<tr><th id="1843">1843</th><td><i class="doc"> * can populate the profile guids. The client can determine the array size using</i></td></tr>
<tr><th id="1844">1844</th><td><i class="doc"> * ::NvEncGetEncodeProfileGUIDCount() API. The client must also validiate that the</i></td></tr>
<tr><th id="1845">1845</th><td><i class="doc"> * NvEncodeAPI interface supports the GUID the client wants to pass as<span class="command"> \p</span> <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1846">1846</th><td><i class="doc"> * parameter.</i></td></tr>
<tr><th id="1847">1847</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1848">1848</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1849">1849</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1850">1850</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1851">1851</th><td><i class="doc"> *   The encode guid whose profile guids are being enumerated.</i></td></tr>
<tr><th id="1852">1852</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">guidArraySize</span></i></td></tr>
<tr><th id="1853">1853</th><td><i class="doc"> *   Number of GUIDs to be retrieved. Should be set to the number retrieved using</i></td></tr>
<tr><th id="1854">1854</th><td><i class="doc"> *   ::NvEncGetEncodeProfileGUIDCount.</i></td></tr>
<tr><th id="1855">1855</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">profileGUIDs</span></i></td></tr>
<tr><th id="1856">1856</th><td><i class="doc"> *   Array of supported Encode Profile GUIDs</i></td></tr>
<tr><th id="1857">1857</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">GUIDCount</span></i></td></tr>
<tr><th id="1858">1858</th><td><i class="doc"> *   Number of valid encode profile GUIDs in<span class="command"> \p</span> <span class="arg">profileGUIDs</span> array.</i></td></tr>
<tr><th id="1859">1859</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1860">1860</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1861">1861</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1862">1862</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1863">1863</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1864">1864</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1865">1865</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1866">1866</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1867">1867</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1868">1868</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1869">1869</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1870">1870</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1871">1871</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeProfileGUIDs" title='NvEncGetEncodeProfileGUIDs' data-ref="NvEncGetEncodeProfileGUIDs">NvEncGetEncodeProfileGUIDs</dfn>                               (<em>void</em>* <dfn class="local col8 decl" id="18encoder" title='encoder' data-type='void *' data-ref="18encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col9 decl" id="19encodeGUID" title='encodeGUID' data-type='GUID' data-ref="19encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col0 decl" id="20profileGUIDs" title='profileGUIDs' data-type='GUID *' data-ref="20profileGUIDs">profileGUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col1 decl" id="21guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="21guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col2 decl" id="22GUIDCount" title='GUIDCount' data-type='uint32_t *' data-ref="22GUIDCount">GUIDCount</dfn>);</td></tr>
<tr><th id="1872">1872</th><td></td></tr>
<tr><th id="1873">1873</th><td><i>// NvEncGetInputFormatCount</i></td></tr>
<tr><th id="1874">1874</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1875">1875</th><td><i class="doc"> * <span class="command">\brief</span> Retrieve the number of supported Input formats.</i></td></tr>
<tr><th id="1876">1876</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1877">1877</th><td><i class="doc"> * The function returns the number of supported input formats. The client must</i></td></tr>
<tr><th id="1878">1878</th><td><i class="doc"> * query the NvEncodeAPI interface to determine the supported input formats</i></td></tr>
<tr><th id="1879">1879</th><td><i class="doc"> * before creating the input surfaces.</i></td></tr>
<tr><th id="1880">1880</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1881">1881</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1882">1882</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1883">1883</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1884">1884</th><td><i class="doc"> *   Encode GUID, corresponding to which the number of supported input formats</i></td></tr>
<tr><th id="1885">1885</th><td><i class="doc"> *   is to be retrieved.</i></td></tr>
<tr><th id="1886">1886</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">inputFmtCount</span></i></td></tr>
<tr><th id="1887">1887</th><td><i class="doc"> *   Number of input formats supported for specified Encode GUID.</i></td></tr>
<tr><th id="1888">1888</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1889">1889</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1890">1890</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1891">1891</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1892">1892</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1893">1893</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1894">1894</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1895">1895</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1896">1896</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1897">1897</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1898">1898</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1899">1899</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetInputFormatCount" title='NvEncGetInputFormatCount' data-ref="NvEncGetInputFormatCount">NvEncGetInputFormatCount</dfn>                   (<em>void</em>* <dfn class="local col3 decl" id="23encoder" title='encoder' data-type='void *' data-ref="23encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col4 decl" id="24encodeGUID" title='encodeGUID' data-type='GUID' data-ref="24encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col5 decl" id="25inputFmtCount" title='inputFmtCount' data-type='uint32_t *' data-ref="25inputFmtCount">inputFmtCount</dfn>);</td></tr>
<tr><th id="1900">1900</th><td></td></tr>
<tr><th id="1901">1901</th><td></td></tr>
<tr><th id="1902">1902</th><td><i>// NvEncGetInputFormats</i></td></tr>
<tr><th id="1903">1903</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1904">1904</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves an array of supported Input formats</i></td></tr>
<tr><th id="1905">1905</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1906">1906</th><td><i class="doc"> * Returns an array of supported input formats  The client must use the input</i></td></tr>
<tr><th id="1907">1907</th><td><i class="doc"> * format to create input surface using ::NvEncCreateInputBuffer() API.</i></td></tr>
<tr><th id="1908">1908</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1909">1909</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1910">1910</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1911">1911</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1912">1912</th><td><i class="doc"> *   Encode GUID, corresponding to which the number of supported input formats</i></td></tr>
<tr><th id="1913">1913</th><td><i class="doc"> *   is to be retrieved.</i></td></tr>
<tr><th id="1914">1914</th><td><i class="doc"> *<span class="command">\param</span> [in] <span class="arg">inputFmtArraySize</span></i></td></tr>
<tr><th id="1915">1915</th><td><i class="doc"> *   Size input format count array passed in<span class="command"> \p</span> <span class="arg">inputFmts.</span></i></td></tr>
<tr><th id="1916">1916</th><td><i class="doc"> *<span class="command">\param</span> [out] <span class="arg">inputFmts</span></i></td></tr>
<tr><th id="1917">1917</th><td><i class="doc"> *   Array of input formats supported for this Encode GUID.</i></td></tr>
<tr><th id="1918">1918</th><td><i class="doc"> *<span class="command">\param</span> [out] <span class="arg">inputFmtCount</span></i></td></tr>
<tr><th id="1919">1919</th><td><i class="doc"> *   The number of valid input format types returned by the NvEncodeAPI</i></td></tr>
<tr><th id="1920">1920</th><td><i class="doc"> *   interface in<span class="command"> \p</span> <span class="arg">inputFmts</span> array.</i></td></tr>
<tr><th id="1921">1921</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1922">1922</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1923">1923</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1924">1924</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1925">1925</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1926">1926</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1927">1927</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1928">1928</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1929">1929</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1930">1930</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1931">1931</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1932">1932</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1933">1933</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetInputFormats" title='NvEncGetInputFormats' data-ref="NvEncGetInputFormats">NvEncGetInputFormats</dfn>                       (<em>void</em>* <dfn class="local col6 decl" id="26encoder" title='encoder' data-type='void *' data-ref="26encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col7 decl" id="27encodeGUID" title='encodeGUID' data-type='GUID' data-ref="27encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>* <dfn class="local col8 decl" id="28inputFmts" title='inputFmts' data-type='NV_ENC_BUFFER_FORMAT *' data-ref="28inputFmts">inputFmts</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col9 decl" id="29inputFmtArraySize" title='inputFmtArraySize' data-type='uint32_t' data-ref="29inputFmtArraySize">inputFmtArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col0 decl" id="30inputFmtCount" title='inputFmtCount' data-type='uint32_t *' data-ref="30inputFmtCount">inputFmtCount</dfn>);</td></tr>
<tr><th id="1934">1934</th><td></td></tr>
<tr><th id="1935">1935</th><td></td></tr>
<tr><th id="1936">1936</th><td><i>// NvEncGetEncodeCaps</i></td></tr>
<tr><th id="1937">1937</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1938">1938</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves the capability value for a specified encoder attribute.</i></td></tr>
<tr><th id="1939">1939</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1940">1940</th><td><i class="doc"> * The function returns the capability value for a given encoder attribute. The</i></td></tr>
<tr><th id="1941">1941</th><td><i class="doc"> * client must validate the encodeGUID using ::NvEncGetEncodeGUIDs() API before</i></td></tr>
<tr><th id="1942">1942</th><td><i class="doc"> * calling this function. The encoder attribute being queried are enumerated in</i></td></tr>
<tr><th id="1943">1943</th><td><i class="doc"> * ::NV_ENC_CAPS_PARAM enum.</i></td></tr>
<tr><th id="1944">1944</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1945">1945</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1946">1946</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1947">1947</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1948">1948</th><td><i class="doc"> *   Encode GUID, corresponding to which the capability attribute is to be retrieved.</i></td></tr>
<tr><th id="1949">1949</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">capsParam</span></i></td></tr>
<tr><th id="1950">1950</th><td><i class="doc"> *   Used to specify attribute being queried. Refer ::NV_ENC_CAPS_PARAM for  more</i></td></tr>
<tr><th id="1951">1951</th><td><i class="doc"> * details.</i></td></tr>
<tr><th id="1952">1952</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">capsVal</span></i></td></tr>
<tr><th id="1953">1953</th><td><i class="doc"> *   The value corresponding to the capability attribute being queried.</i></td></tr>
<tr><th id="1954">1954</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1955">1955</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1956">1956</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1957">1957</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1958">1958</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1959">1959</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1960">1960</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1961">1961</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1962">1962</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1963">1963</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1964">1964</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1965">1965</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeCaps" title='NvEncGetEncodeCaps' data-ref="NvEncGetEncodeCaps">NvEncGetEncodeCaps</dfn>                     (<em>void</em>* <dfn class="local col1 decl" id="31encoder" title='encoder' data-type='void *' data-ref="31encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col2 decl" id="32encodeGUID" title='encodeGUID' data-type='GUID' data-ref="32encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#NV_ENC_CAPS_PARAM" title='NV_ENC_CAPS_PARAM' data-type='struct _NV_ENC_CAPS_PARAM' data-ref="NV_ENC_CAPS_PARAM">NV_ENC_CAPS_PARAM</a>* <dfn class="local col3 decl" id="33capsParam" title='capsParam' data-type='NV_ENC_CAPS_PARAM *' data-ref="33capsParam">capsParam</dfn>, <em>int</em>* <dfn class="local col4 decl" id="34capsVal" title='capsVal' data-type='int *' data-ref="34capsVal">capsVal</dfn>);</td></tr>
<tr><th id="1966">1966</th><td></td></tr>
<tr><th id="1967">1967</th><td></td></tr>
<tr><th id="1968">1968</th><td><i>// NvEncGetEncodePresetCount</i></td></tr>
<tr><th id="1969">1969</th><td><i class="doc">/**</i></td></tr>
<tr><th id="1970">1970</th><td><i class="doc"> * <span class="command">\brief</span> Retrieves the number of supported preset GUIDs.</i></td></tr>
<tr><th id="1971">1971</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1972">1972</th><td><i class="doc"> * The function returns the number of preset GUIDs available for a given codec.</i></td></tr>
<tr><th id="1973">1973</th><td><i class="doc"> * The client must validate the codec guid using ::NvEncGetEncodeGUIDs() API</i></td></tr>
<tr><th id="1974">1974</th><td><i class="doc"> * before calling this function.</i></td></tr>
<tr><th id="1975">1975</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1976">1976</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="1977">1977</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="1978">1978</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="1979">1979</th><td><i class="doc"> *   Encode GUID, corresponding to which the number of supported presets is to</i></td></tr>
<tr><th id="1980">1980</th><td><i class="doc"> *   be retrieved.</i></td></tr>
<tr><th id="1981">1981</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">encodePresetGUIDCount</span></i></td></tr>
<tr><th id="1982">1982</th><td><i class="doc"> *   Receives the number of supported preset GUIDs.</i></td></tr>
<tr><th id="1983">1983</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1984">1984</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="1985">1985</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="1986">1986</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="1987">1987</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="1988">1988</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="1989">1989</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1990">1990</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="1991">1991</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="1992">1992</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="1993">1993</th><td><i class="doc"> *</i></td></tr>
<tr><th id="1994">1994</th><td><i class="doc"> */</i></td></tr>
<tr><th id="1995">1995</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodePresetCount" title='NvEncGetEncodePresetCount' data-ref="NvEncGetEncodePresetCount">NvEncGetEncodePresetCount</dfn>              (<em>void</em>* <dfn class="local col5 decl" id="35encoder" title='encoder' data-type='void *' data-ref="35encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col6 decl" id="36encodeGUID" title='encodeGUID' data-type='GUID' data-ref="36encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col7 decl" id="37encodePresetGUIDCount" title='encodePresetGUIDCount' data-type='uint32_t *' data-ref="37encodePresetGUIDCount">encodePresetGUIDCount</dfn>);</td></tr>
<tr><th id="1996">1996</th><td></td></tr>
<tr><th id="1997">1997</th><td></td></tr>
<tr><th id="1998">1998</th><td><i>// NvEncGetEncodePresetGUIDs</i></td></tr>
<tr><th id="1999">1999</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2000">2000</th><td><i class="doc"> * <span class="command">\brief</span> Receives an array of supported encoder preset GUIDs.</i></td></tr>
<tr><th id="2001">2001</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2002">2002</th><td><i class="doc"> * The function returns an array of encode preset guids available for a given codec.</i></td></tr>
<tr><th id="2003">2003</th><td><i class="doc"> * The client can directly use one of the preset guids based upon the use case</i></td></tr>
<tr><th id="2004">2004</th><td><i class="doc"> * or target device. The preset guid chosen can be directly used in</i></td></tr>
<tr><th id="2005">2005</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::presetGUID parameter to ::NvEncEncodePicture() API.</i></td></tr>
<tr><th id="2006">2006</th><td><i class="doc"> * Alternately client can  also use the preset guid to retrieve the encoding config</i></td></tr>
<tr><th id="2007">2007</th><td><i class="doc"> * parameters being used by NvEncodeAPI interface for that given preset, using</i></td></tr>
<tr><th id="2008">2008</th><td><i class="doc"> * ::NvEncGetEncodePresetConfig() API. It can then modify preset config parameters</i></td></tr>
<tr><th id="2009">2009</th><td><i class="doc"> * as per its use case and send it to NvEncodeAPI interface as part of</i></td></tr>
<tr><th id="2010">2010</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::encodeConfig parameter for NvEncInitializeEncoder()</i></td></tr>
<tr><th id="2011">2011</th><td><i class="doc"> * API.</i></td></tr>
<tr><th id="2012">2012</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2013">2013</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2014">2014</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2015">2015</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2016">2016</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="2017">2017</th><td><i class="doc"> *   Encode GUID, corresponding to which the list of supported presets is to be</i></td></tr>
<tr><th id="2018">2018</th><td><i class="doc"> *   retrieved.</i></td></tr>
<tr><th id="2019">2019</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">guidArraySize</span></i></td></tr>
<tr><th id="2020">2020</th><td><i class="doc"> *   Size of array of preset guids passed in<span class="command"> \p</span> <span class="arg">preset</span> GUIDs</i></td></tr>
<tr><th id="2021">2021</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">presetGUIDs</span></i></td></tr>
<tr><th id="2022">2022</th><td><i class="doc"> *   Array of supported Encode preset GUIDs from the NvEncodeAPI interface</i></td></tr>
<tr><th id="2023">2023</th><td><i class="doc"> *   to client.</i></td></tr>
<tr><th id="2024">2024</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">encodePresetGUIDCount</span></i></td></tr>
<tr><th id="2025">2025</th><td><i class="doc"> *   Receives the number of preset GUIDs returned by the NvEncodeAPI</i></td></tr>
<tr><th id="2026">2026</th><td><i class="doc"> *   interface.</i></td></tr>
<tr><th id="2027">2027</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2028">2028</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2029">2029</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2030">2030</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2031">2031</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2032">2032</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2033">2033</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2034">2034</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2035">2035</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2036">2036</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2037">2037</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2038">2038</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2039">2039</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodePresetGUIDs" title='NvEncGetEncodePresetGUIDs' data-ref="NvEncGetEncodePresetGUIDs">NvEncGetEncodePresetGUIDs</dfn>                  (<em>void</em>* <dfn class="local col8 decl" id="38encoder" title='encoder' data-type='void *' data-ref="38encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col9 decl" id="39encodeGUID" title='encodeGUID' data-type='GUID' data-ref="39encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col0 decl" id="40presetGUIDs" title='presetGUIDs' data-type='GUID *' data-ref="40presetGUIDs">presetGUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col1 decl" id="41guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="41guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col2 decl" id="42encodePresetGUIDCount" title='encodePresetGUIDCount' data-type='uint32_t *' data-ref="42encodePresetGUIDCount">encodePresetGUIDCount</dfn>);</td></tr>
<tr><th id="2040">2040</th><td></td></tr>
<tr><th id="2041">2041</th><td></td></tr>
<tr><th id="2042">2042</th><td><i>// NvEncGetEncodePresetConfig</i></td></tr>
<tr><th id="2043">2043</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2044">2044</th><td><i class="doc"> * <span class="command">\brief</span> Returns a preset config structure supported for given preset GUID.</i></td></tr>
<tr><th id="2045">2045</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2046">2046</th><td><i class="doc"> * The function returns a preset config structure for a given preset guid. Before</i></td></tr>
<tr><th id="2047">2047</th><td><i class="doc"> * using this function the client must enumerate the preset guids available for</i></td></tr>
<tr><th id="2048">2048</th><td><i class="doc"> * a given codec. The preset config structure can be modified by the client depending</i></td></tr>
<tr><th id="2049">2049</th><td><i class="doc"> * upon its use case and can be then used to initialize the encoder using</i></td></tr>
<tr><th id="2050">2050</th><td><i class="doc"> * ::NvEncInitializeEncoder() API. The client can use this function only if it</i></td></tr>
<tr><th id="2051">2051</th><td><i class="doc"> * wants to modify the NvEncodeAPI preset configuration, otherwise it can</i></td></tr>
<tr><th id="2052">2052</th><td><i class="doc"> * directly use the preset guid.</i></td></tr>
<tr><th id="2053">2053</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2054">2054</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2055">2055</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2056">2056</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encodeGUID</span></i></td></tr>
<tr><th id="2057">2057</th><td><i class="doc"> *   Encode GUID, corresponding to which the list of supported presets is to be</i></td></tr>
<tr><th id="2058">2058</th><td><i class="doc"> *   retrieved.</i></td></tr>
<tr><th id="2059">2059</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">presetGUID</span></i></td></tr>
<tr><th id="2060">2060</th><td><i class="doc"> *   Preset GUID, corresponding to which the Encoding configurations is to be</i></td></tr>
<tr><th id="2061">2061</th><td><i class="doc"> *   retrieved.</i></td></tr>
<tr><th id="2062">2062</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">presetConfig</span></i></td></tr>
<tr><th id="2063">2063</th><td><i class="doc"> *   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for</i></td></tr>
<tr><th id="2064">2064</th><td><i class="doc">*    more details.</i></td></tr>
<tr><th id="2065">2065</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2066">2066</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2067">2067</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2068">2068</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2069">2069</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2070">2070</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2071">2071</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2072">2072</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2073">2073</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2074">2074</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2075">2075</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2076">2076</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2077">2077</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2078">2078</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodePresetConfig" title='NvEncGetEncodePresetConfig' data-ref="NvEncGetEncodePresetConfig">NvEncGetEncodePresetConfig</dfn>               (<em>void</em>* <dfn class="local col3 decl" id="43encoder" title='encoder' data-type='void *' data-ref="43encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col4 decl" id="44encodeGUID" title='encodeGUID' data-type='GUID' data-ref="44encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>  <dfn class="local col5 decl" id="45presetGUID" title='presetGUID' data-type='GUID' data-ref="45presetGUID">presetGUID</dfn>, <a class="typedef" href="#NV_ENC_PRESET_CONFIG" title='NV_ENC_PRESET_CONFIG' data-type='struct _NV_ENC_PRESET_CONFIG' data-ref="NV_ENC_PRESET_CONFIG">NV_ENC_PRESET_CONFIG</a>* <dfn class="local col6 decl" id="46presetConfig" title='presetConfig' data-type='NV_ENC_PRESET_CONFIG *' data-ref="46presetConfig">presetConfig</dfn>);</td></tr>
<tr><th id="2079">2079</th><td></td></tr>
<tr><th id="2080">2080</th><td><i>// NvEncInitializeEncoder</i></td></tr>
<tr><th id="2081">2081</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2082">2082</th><td><i class="doc"> * <span class="command">\brief</span> Initialize the encoder.</i></td></tr>
<tr><th id="2083">2083</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2084">2084</th><td><i class="doc"> * This API must be used to initialize the encoder. The initialization parameter</i></td></tr>
<tr><th id="2085">2085</th><td><i class="doc"> * is passed using<span class="command"> \p</span> <span class="arg">*createEncodeParams</span>  The client must send the following</i></td></tr>
<tr><th id="2086">2086</th><td><i class="doc"> * fields of the _NV_ENC_INITIALIZE_PARAMS structure with a valid value.</i></td></tr>
<tr><th id="2087">2087</th><td><i class="doc"> * - NV_ENC_INITIALIZE_PARAMS::encodeGUID</i></td></tr>
<tr><th id="2088">2088</th><td><i class="doc"> * - NV_ENC_INITIALIZE_PARAMS::encodeWidth</i></td></tr>
<tr><th id="2089">2089</th><td><i class="doc"> * - NV_ENC_INITIALIZE_PARAMS::encodeHeight</i></td></tr>
<tr><th id="2090">2090</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2091">2091</th><td><i class="doc"> * The client can pass a preset guid directly to the NvEncodeAPI interface using</i></td></tr>
<tr><th id="2092">2092</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::presetGUID field. If the client doesn't pass</i></td></tr>
<tr><th id="2093">2093</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::encodeConfig structure, the codec specific parameters</i></td></tr>
<tr><th id="2094">2094</th><td><i class="doc"> * will be selected based on the preset guid. The preset guid must have been</i></td></tr>
<tr><th id="2095">2095</th><td><i class="doc"> * validated by the client using ::NvEncGetEncodePresetGUIDs() API.</i></td></tr>
<tr><th id="2096">2096</th><td><i class="doc"> * If the client passes a custom ::_NV_ENC_CONFIG structure through</i></td></tr>
<tr><th id="2097">2097</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::encodeConfig , it will override the codec specific parameters</i></td></tr>
<tr><th id="2098">2098</th><td><i class="doc"> * based on the preset guid. It is recommended that even if the client passes a custom config,</i></td></tr>
<tr><th id="2099">2099</th><td><i class="doc"> * it should also send a preset guid. In this case, the preset guid passed by the client</i></td></tr>
<tr><th id="2100">2100</th><td><i class="doc"> * will not override any of the custom config parameters programmed by the client,</i></td></tr>
<tr><th id="2101">2101</th><td><i class="doc"> * it is only used as a hint by the NvEncodeAPI interface to determine certain encoder parameters</i></td></tr>
<tr><th id="2102">2102</th><td><i class="doc"> * which are not exposed to the client.</i></td></tr>
<tr><th id="2103">2103</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2104">2104</th><td><i class="doc"> * There are two modes of operation for the encoder namely:</i></td></tr>
<tr><th id="2105">2105</th><td><i class="doc"> * - Asynchronous mode</i></td></tr>
<tr><th id="2106">2106</th><td><i class="doc"> * - Synchronous mode</i></td></tr>
<tr><th id="2107">2107</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2108">2108</th><td><i class="doc"> * The client can select asynchronous or synchronous mode by setting the<span class="command"> \p</span></i></td></tr>
<tr><th id="2109">2109</th><td><i class="doc"> * <span class="arg">enableEncodeAsync</span> field in ::_NV_ENC_INITIALIZE_PARAMS to 1 or 0 respectively.</i></td></tr>
<tr><th id="2110">2110</th><td><i class="doc"> *<span class="command">\par</span> Asynchronous mode of operation:</i></td></tr>
<tr><th id="2111">2111</th><td><i class="doc"> * The Asynchronous mode can be enabled by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1.</i></td></tr>
<tr><th id="2112">2112</th><td><i class="doc"> * The client operating in asynchronous mode must allocate completion event object</i></td></tr>
<tr><th id="2113">2113</th><td><i class="doc"> * for each output buffer and pass the completion event object in the</i></td></tr>
<tr><th id="2114">2114</th><td><i class="doc"> * ::NvEncEncodePicture() API. The client can create another thread and wait on</i></td></tr>
<tr><th id="2115">2115</th><td><i class="doc"> * the event object to be signalled by NvEncodeAPI interface on completion of the</i></td></tr>
<tr><th id="2116">2116</th><td><i class="doc"> * encoding process for the output frame. This should unblock the main thread from</i></td></tr>
<tr><th id="2117">2117</th><td><i class="doc"> * submitting work to the encoder. When the event is signalled the client can call</i></td></tr>
<tr><th id="2118">2118</th><td><i class="doc"> * NvEncodeAPI interfaces to copy the bitstream data using ::NvEncLockBitstream()</i></td></tr>
<tr><th id="2119">2119</th><td><i class="doc"> * API. This is the preferred mode of operation.</i></td></tr>
<tr><th id="2120">2120</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2121">2121</th><td><i class="doc"> * NOTE: Asynchronous mode is not supported on Linux.</i></td></tr>
<tr><th id="2122">2122</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2123">2123</th><td><i class="doc"> *<span class="command">\par</span> Synchronous mode of operation:</i></td></tr>
<tr><th id="2124">2124</th><td><i class="doc"> * The client can select synchronous mode by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0.</i></td></tr>
<tr><th id="2125">2125</th><td><i class="doc"> * The client working in synchronous mode can work in a single threaded or multi</i></td></tr>
<tr><th id="2126">2126</th><td><i class="doc"> * threaded mode. The client need not allocate any event objects. The client can</i></td></tr>
<tr><th id="2127">2127</th><td><i class="doc"> * only lock the bitstream data after NvEncodeAPI interface has returned</i></td></tr>
<tr><th id="2128">2128</th><td><i class="doc"> * ::NV_ENC_SUCCESS from encode picture. The NvEncodeAPI interface can return</i></td></tr>
<tr><th id="2129">2129</th><td><i class="doc"> * ::NV_ENC_ERR_NEED_MORE_INPUT error code from ::NvEncEncodePicture() API. The</i></td></tr>
<tr><th id="2130">2130</th><td><i class="doc"> * client must not lock the output buffer in such case but should send the next</i></td></tr>
<tr><th id="2131">2131</th><td><i class="doc"> * frame for encoding. The client must keep on calling ::NvEncEncodePicture() API</i></td></tr>
<tr><th id="2132">2132</th><td><i class="doc"> * until it returns ::NV_ENC_SUCCESS.<span class="command"> \n</span></i></td></tr>
<tr><th id="2133">2133</th><td><i class="doc"> * The client must always lock the bitstream data in order in which it has submitted.</i></td></tr>
<tr><th id="2134">2134</th><td><i class="doc"> * This is true for both asynchronous and synchronous mode.</i></td></tr>
<tr><th id="2135">2135</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2136">2136</th><td><i class="doc"> *<span class="command">\par</span> Picture type decision:</i></td></tr>
<tr><th id="2137">2137</th><td><i class="doc"> * If the client is taking the picture type decision and it must disable the picture</i></td></tr>
<tr><th id="2138">2138</th><td><i class="doc"> * type decision module in NvEncodeAPI by setting NV_ENC_INITIALIZE_PARAMS::enablePTD</i></td></tr>
<tr><th id="2139">2139</th><td><i class="doc"> * to 0. In this case the client is  required to send the picture in encoding</i></td></tr>
<tr><th id="2140">2140</th><td><i class="doc"> * order to NvEncodeAPI by doing the re-ordering for B frames.<span class="command"> \n</span></i></td></tr>
<tr><th id="2141">2141</th><td><i class="doc"> * If the client doesn't want to take the picture type decision it can enable</i></td></tr>
<tr><th id="2142">2142</th><td><i class="doc"> * picture type decision module in the NvEncodeAPI interface by setting</i></td></tr>
<tr><th id="2143">2143</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::enablePTD to 1 and send the input pictures in display</i></td></tr>
<tr><th id="2144">2144</th><td><i class="doc"> * order.</i></td></tr>
<tr><th id="2145">2145</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2146">2146</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2147">2147</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2148">2148</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">createEncodeParams</span></i></td></tr>
<tr><th id="2149">2149</th><td><i class="doc"> *   Refer ::_NV_ENC_INITIALIZE_PARAMS for details.</i></td></tr>
<tr><th id="2150">2150</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2151">2151</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2152">2152</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2153">2153</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2154">2154</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2155">2155</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2156">2156</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2157">2157</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2158">2158</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2159">2159</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2160">2160</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2161">2161</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2162">2162</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2163">2163</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncInitializeEncoder" title='NvEncInitializeEncoder' data-ref="NvEncInitializeEncoder">NvEncInitializeEncoder</dfn>                     (<em>void</em>* <dfn class="local col7 decl" id="47encoder" title='encoder' data-type='void *' data-ref="47encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INITIALIZE_PARAMS" title='NV_ENC_INITIALIZE_PARAMS' data-type='struct _NV_ENC_INITIALIZE_PARAMS' data-ref="NV_ENC_INITIALIZE_PARAMS">NV_ENC_INITIALIZE_PARAMS</a>* <dfn class="local col8 decl" id="48createEncodeParams" title='createEncodeParams' data-type='NV_ENC_INITIALIZE_PARAMS *' data-ref="48createEncodeParams">createEncodeParams</dfn>);</td></tr>
<tr><th id="2164">2164</th><td></td></tr>
<tr><th id="2165">2165</th><td></td></tr>
<tr><th id="2166">2166</th><td><i>// NvEncCreateInputBuffer</i></td></tr>
<tr><th id="2167">2167</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2168">2168</th><td><i class="doc"> * <span class="command">\brief</span> Allocates Input buffer.</i></td></tr>
<tr><th id="2169">2169</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2170">2170</th><td><i class="doc"> * This function is used to allocate an input buffer. The client must enumerate</i></td></tr>
<tr><th id="2171">2171</th><td><i class="doc"> * the input buffer format before allocating the input buffer resources. The</i></td></tr>
<tr><th id="2172">2172</th><td><i class="doc"> * NV_ENC_INPUT_PTR returned by the NvEncodeAPI interface in the</i></td></tr>
<tr><th id="2173">2173</th><td><i class="doc"> * NV_ENC_CREATE_INPUT_BUFFER::inputBuffer field can be directly used in</i></td></tr>
<tr><th id="2174">2174</th><td><i class="doc"> * ::NvEncEncodePicture() API. The number of input buffers to be allocated by the</i></td></tr>
<tr><th id="2175">2175</th><td><i class="doc"> * client must be at least 4 more than the number of B frames being used for encoding.</i></td></tr>
<tr><th id="2176">2176</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2177">2177</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2178">2178</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2179">2179</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">createInputBufferParams</span></i></td></tr>
<tr><th id="2180">2180</th><td><i class="doc"> *  Pointer to the ::NV_ENC_CREATE_INPUT_BUFFER structure.</i></td></tr>
<tr><th id="2181">2181</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2182">2182</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2183">2183</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2184">2184</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2185">2185</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2186">2186</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2187">2187</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2188">2188</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2189">2189</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2190">2190</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2191">2191</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2192">2192</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2193">2193</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2194">2194</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncCreateInputBuffer" title='NvEncCreateInputBuffer' data-ref="NvEncCreateInputBuffer">NvEncCreateInputBuffer</dfn>                     (<em>void</em>* <dfn class="local col9 decl" id="49encoder" title='encoder' data-type='void *' data-ref="49encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_INPUT_BUFFER" title='NV_ENC_CREATE_INPUT_BUFFER' data-type='struct _NV_ENC_CREATE_INPUT_BUFFER' data-ref="NV_ENC_CREATE_INPUT_BUFFER">NV_ENC_CREATE_INPUT_BUFFER</a>* <dfn class="local col0 decl" id="50createInputBufferParams" title='createInputBufferParams' data-type='NV_ENC_CREATE_INPUT_BUFFER *' data-ref="50createInputBufferParams">createInputBufferParams</dfn>);</td></tr>
<tr><th id="2195">2195</th><td></td></tr>
<tr><th id="2196">2196</th><td></td></tr>
<tr><th id="2197">2197</th><td><i>// NvEncDestroyInputBuffer</i></td></tr>
<tr><th id="2198">2198</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2199">2199</th><td><i class="doc"> * <span class="command">\brief</span> Release an input buffers.</i></td></tr>
<tr><th id="2200">2200</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2201">2201</th><td><i class="doc"> * This function is used to free an input buffer. If the client has allocated</i></td></tr>
<tr><th id="2202">2202</th><td><i class="doc"> * any input buffer using ::NvEncCreateInputBuffer() API, it must free those</i></td></tr>
<tr><th id="2203">2203</th><td><i class="doc"> * input buffers by calling this function. The client must release the input</i></td></tr>
<tr><th id="2204">2204</th><td><i class="doc"> * buffers before destroying the encoder using ::NvEncDestroyEncoder() API.</i></td></tr>
<tr><th id="2205">2205</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2206">2206</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2207">2207</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2208">2208</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">inputBuffer</span></i></td></tr>
<tr><th id="2209">2209</th><td><i class="doc"> *   Pointer to the input buffer to be released.</i></td></tr>
<tr><th id="2210">2210</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2211">2211</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2212">2212</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2213">2213</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2214">2214</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2215">2215</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2216">2216</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2217">2217</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2218">2218</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2219">2219</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2220">2220</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2221">2221</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2222">2222</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2223">2223</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncDestroyInputBuffer" title='NvEncDestroyInputBuffer' data-ref="NvEncDestroyInputBuffer">NvEncDestroyInputBuffer</dfn>                    (<em>void</em>* <dfn class="local col1 decl" id="51encoder" title='encoder' data-type='void *' data-ref="51encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col2 decl" id="52inputBuffer" title='inputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="52inputBuffer">inputBuffer</dfn>);</td></tr>
<tr><th id="2224">2224</th><td></td></tr>
<tr><th id="2225">2225</th><td></td></tr>
<tr><th id="2226">2226</th><td><i>// NvEncCreateBitstreamBuffer</i></td></tr>
<tr><th id="2227">2227</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2228">2228</th><td><i class="doc"> * <span class="command">\brief</span> Allocates an output bitstream buffer</i></td></tr>
<tr><th id="2229">2229</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2230">2230</th><td><i class="doc"> * This function is used to allocate an output bitstream buffer and returns a</i></td></tr>
<tr><th id="2231">2231</th><td><i class="doc"> * NV_ENC_OUTPUT_PTR to bitstream  buffer to the client in the</i></td></tr>
<tr><th id="2232">2232</th><td><i class="doc"> * NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer field.</i></td></tr>
<tr><th id="2233">2233</th><td><i class="doc"> * The client can only call this function after the encoder session has been</i></td></tr>
<tr><th id="2234">2234</th><td><i class="doc"> * initialized using ::NvEncInitializeEncoder() API. The minimum number of output</i></td></tr>
<tr><th id="2235">2235</th><td><i class="doc"> * buffers allocated by the client must be at least 4 more than the number of B</i></td></tr>
<tr><th id="2236">2236</th><td><i class="doc"> * B frames being used for encoding. The client can only access the output</i></td></tr>
<tr><th id="2237">2237</th><td><i class="doc"> * bitsteam data by locking the<span class="command"> \p</span> <span class="arg">bitstreamBuffer</span> using the ::NvEncLockBitstream()</i></td></tr>
<tr><th id="2238">2238</th><td><i class="doc"> * function.</i></td></tr>
<tr><th id="2239">2239</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2240">2240</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2241">2241</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2242">2242</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">createBitstreamBufferParams</span></i></td></tr>
<tr><th id="2243">2243</th><td><i class="doc"> *   Pointer ::NV_ENC_CREATE_BITSTREAM_BUFFER for details.</i></td></tr>
<tr><th id="2244">2244</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2245">2245</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2246">2246</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2247">2247</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2248">2248</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2249">2249</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2250">2250</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2251">2251</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2252">2252</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2253">2253</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2254">2254</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2255">2255</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2256">2256</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2257">2257</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2258">2258</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncCreateBitstreamBuffer" title='NvEncCreateBitstreamBuffer' data-ref="NvEncCreateBitstreamBuffer">NvEncCreateBitstreamBuffer</dfn>                 (<em>void</em>* <dfn class="local col3 decl" id="53encoder" title='encoder' data-type='void *' data-ref="53encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_BITSTREAM_BUFFER" title='NV_ENC_CREATE_BITSTREAM_BUFFER' data-type='struct _NV_ENC_CREATE_BITSTREAM_BUFFER' data-ref="NV_ENC_CREATE_BITSTREAM_BUFFER">NV_ENC_CREATE_BITSTREAM_BUFFER</a>* <dfn class="local col4 decl" id="54createBitstreamBufferParams" title='createBitstreamBufferParams' data-type='NV_ENC_CREATE_BITSTREAM_BUFFER *' data-ref="54createBitstreamBufferParams">createBitstreamBufferParams</dfn>);</td></tr>
<tr><th id="2259">2259</th><td></td></tr>
<tr><th id="2260">2260</th><td></td></tr>
<tr><th id="2261">2261</th><td><i>// NvEncDestroyBitstreamBuffer</i></td></tr>
<tr><th id="2262">2262</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2263">2263</th><td><i class="doc"> * <span class="command">\brief</span> Release a bitstream buffer.</i></td></tr>
<tr><th id="2264">2264</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2265">2265</th><td><i class="doc"> * This function is used to release the output bitstream buffer allocated using</i></td></tr>
<tr><th id="2266">2266</th><td><i class="doc"> * the ::NvEncCreateBitstreamBuffer() function. The client must release the output</i></td></tr>
<tr><th id="2267">2267</th><td><i class="doc"> * bitstreamBuffer using this function before destroying the encoder session.</i></td></tr>
<tr><th id="2268">2268</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2269">2269</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2270">2270</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2271">2271</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">bitstreamBuffer</span></i></td></tr>
<tr><th id="2272">2272</th><td><i class="doc"> *   Pointer to the bitstream buffer being released.</i></td></tr>
<tr><th id="2273">2273</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2274">2274</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2275">2275</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2276">2276</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2277">2277</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2278">2278</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2279">2279</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2280">2280</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2281">2281</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2282">2282</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2283">2283</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2284">2284</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2285">2285</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2286">2286</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2287">2287</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncDestroyBitstreamBuffer" title='NvEncDestroyBitstreamBuffer' data-ref="NvEncDestroyBitstreamBuffer">NvEncDestroyBitstreamBuffer</dfn>                (<em>void</em>* <dfn class="local col5 decl" id="55encoder" title='encoder' data-type='void *' data-ref="55encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col6 decl" id="56bitstreamBuffer" title='bitstreamBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="56bitstreamBuffer">bitstreamBuffer</dfn>);</td></tr>
<tr><th id="2288">2288</th><td></td></tr>
<tr><th id="2289">2289</th><td><i>// NvEncEncodePicture</i></td></tr>
<tr><th id="2290">2290</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2291">2291</th><td><i class="doc"> * <span class="command">\brief</span> Submit an input picture for encoding.</i></td></tr>
<tr><th id="2292">2292</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2293">2293</th><td><i class="doc"> * This function is used to submit an input picture buffer for encoding. The</i></td></tr>
<tr><th id="2294">2294</th><td><i class="doc"> * encoding parameters are passed using<span class="command"> \p</span> <span class="arg">*encodePicParams</span> which is a pointer</i></td></tr>
<tr><th id="2295">2295</th><td><i class="doc"> * to the ::_NV_ENC_PIC_PARAMS structure.</i></td></tr>
<tr><th id="2296">2296</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2297">2297</th><td><i class="doc"> * If the client has set NV_ENC_INITIALIZE_PARAMS::enablePTD to 0, then it must</i></td></tr>
<tr><th id="2298">2298</th><td><i class="doc"> * send a valid value for the following fields.</i></td></tr>
<tr><th id="2299">2299</th><td><i class="doc"> * - NV_ENC_PIC_PARAMS::pictureType</i></td></tr>
<tr><th id="2300">2300</th><td><i class="doc"> * - NV_ENC_PIC_PARAMS_H264::displayPOCSyntax (H264 only)</i></td></tr>
<tr><th id="2301">2301</th><td><i class="doc"> * - NV_ENC_PIC_PARAMS_H264::frameNumSyntax(H264 only)</i></td></tr>
<tr><th id="2302">2302</th><td><i class="doc"> * - NV_ENC_PIC_PARAMS_H264::refPicFlag(H264 only)</i></td></tr>
<tr><th id="2303">2303</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2304">2304</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2305">2305</th><td><i class="doc"> *<span class="command">\par</span> Asynchronous Encoding</i></td></tr>
<tr><th id="2306">2306</th><td><i class="doc"> * If the client has enabled asynchronous mode of encoding by setting</i></td></tr>
<tr><th id="2307">2307</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 in the ::NvEncInitializeEncoder()</i></td></tr>
<tr><th id="2308">2308</th><td><i class="doc"> * API ,then the client must send a valid NV_ENC_PIC_PARAMS::completionEvent.</i></td></tr>
<tr><th id="2309">2309</th><td><i class="doc"> * Incase of asynchronous mode of operation, client can queue the ::NvEncEncodePicture()</i></td></tr>
<tr><th id="2310">2310</th><td><i class="doc"> * API commands from the main thread and then queue output buffers to be processed</i></td></tr>
<tr><th id="2311">2311</th><td><i class="doc"> * to a secondary worker thread. Before the locking the output buffers in the</i></td></tr>
<tr><th id="2312">2312</th><td><i class="doc"> * secondary thread , the client must wait on NV_ENC_PIC_PARAMS::completionEvent</i></td></tr>
<tr><th id="2313">2313</th><td><i class="doc"> * it has queued in ::NvEncEncodePicture() API call. The client must always process</i></td></tr>
<tr><th id="2314">2314</th><td><i class="doc"> * completion event and the output buffer in the same order in which they have been</i></td></tr>
<tr><th id="2315">2315</th><td><i class="doc"> * submitted for encoding. The NvEncodeAPI interface is responsible for any</i></td></tr>
<tr><th id="2316">2316</th><td><i class="doc"> * re-ordering required for B frames and will always ensure that encoded bitstream</i></td></tr>
<tr><th id="2317">2317</th><td><i class="doc"> * data is written in the same order in which output buffer is submitted.</i></td></tr>
<tr><th id="2318">2318</th><td><i class="doc"> *<span class="command">\code</span></i></td></tr>
<tr><th id="2319">2319</th><td><i class="doc"><span class="verb">  The below example shows how  asynchronous encoding in case of 1 B frames</span></i></td></tr>
<tr><th id="2320">2320</th><td><i class="doc"><span class="verb"></span><span class="verb">  ------------------------------------------------------------------------</span></i></td></tr>
<tr><th id="2321">2321</th><td><i class="doc"><span class="verb"></span><span class="verb">  Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)</span></i></td></tr>
<tr><th id="2322">2322</th><td><i class="doc"><span class="verb"></span><span class="verb">  and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to</span></i></td></tr>
<tr><th id="2323">2323</th><td><i class="doc"><span class="verb"></span><span class="verb">  keep a copy of the input buffers for re-ordering and it allocates following</span></i></td></tr>
<tr><th id="2324">2324</th><td><i class="doc"><span class="verb"></span><span class="verb">  internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI</span></i></td></tr>
<tr><th id="2325">2325</th><td><i class="doc"><span class="verb"></span><span class="verb">  and the client is not responsible for the allocating or freeing the memory of</span></i></td></tr>
<tr><th id="2326">2326</th><td><i class="doc"><span class="verb"></span><span class="verb">  the internal buffers.</span></i></td></tr>
<tr><th id="2327">2327</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2328">2328</th><td><i class="doc"><span class="verb"></span><span class="verb">  a) The client main thread will queue the following encode frame calls.</span></i></td></tr>
<tr><th id="2329">2329</th><td><i class="doc"><span class="verb"></span><span class="verb">  Note the picture type is unknown to the client, the decision is being taken by</span></i></td></tr>
<tr><th id="2330">2330</th><td><i class="doc"><span class="verb"></span><span class="verb">  NvEncodeAPI interface. The client should pass ::_NV_ENC_PIC_PARAMS parameter</span></i></td></tr>
<tr><th id="2331">2331</th><td><i class="doc"><span class="verb"></span><span class="verb">  consisting of allocated input buffer, output buffer and output events in successive</span></i></td></tr>
<tr><th id="2332">2332</th><td><i class="doc"><span class="verb"></span><span class="verb">  ::NvEncEncodePicture() API calls along with other required encode picture params.</span></i></td></tr>
<tr><th id="2333">2333</th><td><i class="doc"><span class="verb"></span><span class="verb">  For example:</span></i></td></tr>
<tr><th id="2334">2334</th><td><i class="doc"><span class="verb"></span><span class="verb">  1st EncodePicture parameters - (I1, O1, E1)</span></i></td></tr>
<tr><th id="2335">2335</th><td><i class="doc"><span class="verb"></span><span class="verb">  2nd EncodePicture parameters - (I2, O2, E2)</span></i></td></tr>
<tr><th id="2336">2336</th><td><i class="doc"><span class="verb"></span><span class="verb">  3rd EncodePicture parameters - (I3, O3, E3)</span></i></td></tr>
<tr><th id="2337">2337</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2338">2338</th><td><i class="doc"><span class="verb"></span><span class="verb">  b) NvEncodeAPI SW will receive the following encode Commands from the client.</span></i></td></tr>
<tr><th id="2339">2339</th><td><i class="doc"><span class="verb"></span><span class="verb">  The left side shows input from client in the form (Input buffer, Output Buffer,</span></i></td></tr>
<tr><th id="2340">2340</th><td><i class="doc"><span class="verb"></span><span class="verb">  Output Event). The right hand side shows a possible picture type decision take by</span></i></td></tr>
<tr><th id="2341">2341</th><td><i class="doc"><span class="verb"></span><span class="verb">  the NvEncodeAPI interface.</span></i></td></tr>
<tr><th id="2342">2342</th><td><i class="doc"><span class="verb"></span><span class="verb">  (I1, O1, E1)    ---P1 Frame</span></i></td></tr>
<tr><th id="2343">2343</th><td><i class="doc"><span class="verb"></span><span class="verb">  (I2, O2, E2)    ---B2 Frame</span></i></td></tr>
<tr><th id="2344">2344</th><td><i class="doc"><span class="verb"></span><span class="verb">  (I3, O3, E3)    ---P3 Frame</span></i></td></tr>
<tr><th id="2345">2345</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2346">2346</th><td><i class="doc"><span class="verb"></span><span class="verb">  c) NvEncodeAPI interface will make a copy of the input buffers to its internal</span></i></td></tr>
<tr><th id="2347">2347</th><td><i class="doc"><span class="verb"></span><span class="verb">   buffersfor re-ordering. These copies are done as part of nvEncEncodePicture</span></i></td></tr>
<tr><th id="2348">2348</th><td><i class="doc"><span class="verb"></span><span class="verb">   function call from the client and NvEncodeAPI interface is responsible for</span></i></td></tr>
<tr><th id="2349">2349</th><td><i class="doc"><span class="verb"></span><span class="verb">   synchronization of copy operation with the actual encoding operation.</span></i></td></tr>
<tr><th id="2350">2350</th><td><i class="doc"><span class="verb"></span><span class="verb">   I1 --&gt; NvI1</span></i></td></tr>
<tr><th id="2351">2351</th><td><i class="doc"><span class="verb"></span><span class="verb">   I2 --&gt; NvI2</span></i></td></tr>
<tr><th id="2352">2352</th><td><i class="doc"><span class="verb"></span><span class="verb">   I3 --&gt; NvI3</span></i></td></tr>
<tr><th id="2353">2353</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2354">2354</th><td><i class="doc"><span class="verb"></span><span class="verb">  d) After returning from ::NvEncEncodePicture() call , the client must queue the output</span></i></td></tr>
<tr><th id="2355">2355</th><td><i class="doc"><span class="verb"></span><span class="verb">   bitstream  processing work to the secondary thread. The output bitstream processing</span></i></td></tr>
<tr><th id="2356">2356</th><td><i class="doc"><span class="verb"></span><span class="verb">   for asynchronous mode consist of first waiting on completion event(E1, E2..)</span></i></td></tr>
<tr><th id="2357">2357</th><td><i class="doc"><span class="verb"></span><span class="verb">   and then locking the output bitstream buffer(O1, O2..) for reading the encoded</span></i></td></tr>
<tr><th id="2358">2358</th><td><i class="doc"><span class="verb"></span><span class="verb">   data. The work queued to the secondary thread by the client is in the following order</span></i></td></tr>
<tr><th id="2359">2359</th><td><i class="doc"><span class="verb"></span><span class="verb">   (I1, O1, E1)</span></i></td></tr>
<tr><th id="2360">2360</th><td><i class="doc"><span class="verb"></span><span class="verb">   (I2, O2, E2)</span></i></td></tr>
<tr><th id="2361">2361</th><td><i class="doc"><span class="verb"></span><span class="verb">   (I3, O3, E3)</span></i></td></tr>
<tr><th id="2362">2362</th><td><i class="doc"><span class="verb"></span><span class="verb">   Note they are in the same order in which client calls ::NvEncEncodePicture() API</span></i></td></tr>
<tr><th id="2363">2363</th><td><i class="doc"><span class="verb"></span><span class="verb">   in \p step a).</span></i></td></tr>
<tr><th id="2364">2364</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2365">2365</th><td><i class="doc"><span class="verb"></span><span class="verb">  e) NvEncodeAPI interface  will do the re-ordering such that Encoder HW will receive</span></i></td></tr>
<tr><th id="2366">2366</th><td><i class="doc"><span class="verb"></span><span class="verb">  the following encode commands:</span></i></td></tr>
<tr><th id="2367">2367</th><td><i class="doc"><span class="verb"></span><span class="verb">  (NvI1, O1, E1)   ---P1 Frame</span></i></td></tr>
<tr><th id="2368">2368</th><td><i class="doc"><span class="verb"></span><span class="verb">  (NvI3, O2, E2)   ---P3 Frame</span></i></td></tr>
<tr><th id="2369">2369</th><td><i class="doc"><span class="verb"></span><span class="verb">  (NvI2, O3, E3)   ---B2 frame</span></i></td></tr>
<tr><th id="2370">2370</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2371">2371</th><td><i class="doc"><span class="verb"></span><span class="verb">  f) After the encoding operations are completed, the events will be signalled</span></i></td></tr>
<tr><th id="2372">2372</th><td><i class="doc"><span class="verb"></span><span class="verb">  by NvEncodeAPI interface in the following order :</span></i></td></tr>
<tr><th id="2373">2373</th><td><i class="doc"><span class="verb"></span><span class="verb">  (O1, E1) ---P1 Frame ,output bitstream copied to O1 and event E1 signalled.</span></i></td></tr>
<tr><th id="2374">2374</th><td><i class="doc"><span class="verb"></span><span class="verb">  (O2, E2) ---P3 Frame ,output bitstream copied to O2 and event E2 signalled.</span></i></td></tr>
<tr><th id="2375">2375</th><td><i class="doc"><span class="verb"></span><span class="verb">  (O3, E3) ---B2 Frame ,output bitstream copied to O3 and event E3 signalled.</span></i></td></tr>
<tr><th id="2376">2376</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2377">2377</th><td><i class="doc"><span class="verb"></span><span class="verb">  g) The client must lock the bitstream data using ::NvEncLockBitstream() API in</span></i></td></tr>
<tr><th id="2378">2378</th><td><i class="doc"><span class="verb"></span><span class="verb">   the order O1,O2,O3  to read the encoded data, after waiting for the events</span></i></td></tr>
<tr><th id="2379">2379</th><td><i class="doc"><span class="verb"></span><span class="verb">   to be signalled in the same order i.e E1, E2 and E3.The output processing is</span></i></td></tr>
<tr><th id="2380">2380</th><td><i class="doc"><span class="verb"></span><span class="verb">   done in the secondary thread in the following order:</span></i></td></tr>
<tr><th id="2381">2381</th><td><i class="doc"><span class="verb"></span><span class="verb">   Waits on E1, copies encoded bitstream from O1</span></i></td></tr>
<tr><th id="2382">2382</th><td><i class="doc"><span class="verb"></span><span class="verb">   Waits on E2, copies encoded bitstream from O2</span></i></td></tr>
<tr><th id="2383">2383</th><td><i class="doc"><span class="verb"></span><span class="verb">   Waits on E3, copies encoded bitstream from O3</span></i></td></tr>
<tr><th id="2384">2384</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2385">2385</th><td><i class="doc"><span class="verb"></span><span class="verb">  -Note the client will receive the events signalling and output buffer in the</span></i></td></tr>
<tr><th id="2386">2386</th><td><i class="doc"><span class="verb"></span><span class="verb">   same order in which they have submitted for encoding.</span></i></td></tr>
<tr><th id="2387">2387</th><td><i class="doc"><span class="verb"></span><span class="verb">  -Note the LockBitstream will have picture type field which will notify the</span></i></td></tr>
<tr><th id="2388">2388</th><td><i class="doc"><span class="verb"></span><span class="verb">   output picture type to the clients.</span></i></td></tr>
<tr><th id="2389">2389</th><td><i class="doc"><span class="verb"></span><span class="verb">  -Note the input, output buffer and the output completion event are free to be</span></i></td></tr>
<tr><th id="2390">2390</th><td><i class="doc"><span class="verb"></span><span class="verb">   reused once NvEncodeAPI interfaced has signalled the event and the client has</span></i></td></tr>
<tr><th id="2391">2391</th><td><i class="doc"><span class="verb"></span><span class="verb">   copied the data from the output buffer.</span></i></td></tr>
<tr><th id="2392">2392</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2393">2393</th><td><i class="doc"><span class="verb"></span> * \endcode</i></td></tr>
<tr><th id="2394">2394</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2395">2395</th><td><i class="doc"> *<span class="command">\par</span> Synchronous Encoding</i></td></tr>
<tr><th id="2396">2396</th><td><i class="doc"> * The client can enable synchronous mode of encoding by setting</i></td></tr>
<tr><th id="2397">2397</th><td><i class="doc"> * NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 in ::NvEncInitializeEncoder() API.</i></td></tr>
<tr><th id="2398">2398</th><td><i class="doc"> * The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for</i></td></tr>
<tr><th id="2399">2399</th><td><i class="doc"> * some ::NvEncEncodePicture() API calls when NV_ENC_INITIALIZE_PARAMS::enablePTD</i></td></tr>
<tr><th id="2400">2400</th><td><i class="doc"> * is set to 1, but the client must not treat it as a fatal error. The NvEncodeAPI</i></td></tr>
<tr><th id="2401">2401</th><td><i class="doc"> * interface might not be able to submit an input picture buffer for encoding</i></td></tr>
<tr><th id="2402">2402</th><td><i class="doc"> * immediately due to re-ordering for B frames. The NvEncodeAPI interface cannot</i></td></tr>
<tr><th id="2403">2403</th><td><i class="doc"> * submit the input picture which is decided to be encoded as B frame as it waits</i></td></tr>
<tr><th id="2404">2404</th><td><i class="doc"> * for backward reference from  temporally subsequent frames. This input picture</i></td></tr>
<tr><th id="2405">2405</th><td><i class="doc"> * is buffered internally and waits for more input picture to arrive. The client</i></td></tr>
<tr><th id="2406">2406</th><td><i class="doc"> * must not call ::NvEncLockBitstream() API on the output buffers whose</i></td></tr>
<tr><th id="2407">2407</th><td><i class="doc"> * ::NvEncEncodePicture() API returns ::NV_ENC_ERR_NEED_MORE_INPUT. The client must</i></td></tr>
<tr><th id="2408">2408</th><td><i class="doc"> * wait for the NvEncodeAPI interface to return ::NV_ENC_SUCCESS before locking the</i></td></tr>
<tr><th id="2409">2409</th><td><i class="doc"> * output bitstreams to read the encoded bitstream data. The following example</i></td></tr>
<tr><th id="2410">2410</th><td><i class="doc"> * explains the scenario with synchronous encoding with 2 B frames.</i></td></tr>
<tr><th id="2411">2411</th><td><i class="doc"> *<span class="command">\code</span></i></td></tr>
<tr><th id="2412">2412</th><td><i class="doc"><span class="verb"> The below example shows how  synchronous encoding works in case of 1 B frames</span></i></td></tr>
<tr><th id="2413">2413</th><td><i class="doc"><span class="verb"></span><span class="verb"> -----------------------------------------------------------------------------</span></i></td></tr>
<tr><th id="2414">2414</th><td><i class="doc"><span class="verb"></span><span class="verb"> Suppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)</span></i></td></tr>
<tr><th id="2415">2415</th><td><i class="doc"><span class="verb"></span><span class="verb"> and 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to</span></i></td></tr>
<tr><th id="2416">2416</th><td><i class="doc"><span class="verb"></span><span class="verb"> keep a copy of the input buffers for re-ordering and it allocates following</span></i></td></tr>
<tr><th id="2417">2417</th><td><i class="doc"><span class="verb"></span><span class="verb"> internal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI</span></i></td></tr>
<tr><th id="2418">2418</th><td><i class="doc"><span class="verb"></span><span class="verb"> and the client is not responsible for the allocating or freeing the memory of</span></i></td></tr>
<tr><th id="2419">2419</th><td><i class="doc"><span class="verb"></span><span class="verb"> the internal buffers.</span></i></td></tr>
<tr><th id="2420">2420</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2421">2421</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client calls ::NvEncEncodePicture() API with input buffer I1 and output buffer O1.</span></i></td></tr>
<tr><th id="2422">2422</th><td><i class="doc"><span class="verb"></span><span class="verb"> The NvEncodeAPI decides to encode I1 as P frame and submits it to encoder</span></i></td></tr>
<tr><th id="2423">2423</th><td><i class="doc"><span class="verb"></span><span class="verb"> HW and returns ::NV_ENC_SUCCESS.</span></i></td></tr>
<tr><th id="2424">2424</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client can now read the encoded data by locking the output O1 by calling</span></i></td></tr>
<tr><th id="2425">2425</th><td><i class="doc"><span class="verb"></span><span class="verb"> NvEncLockBitstream API.</span></i></td></tr>
<tr><th id="2426">2426</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2427">2427</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client calls ::NvEncEncodePicture() API with input buffer I2 and output buffer O2.</span></i></td></tr>
<tr><th id="2428">2428</th><td><i class="doc"><span class="verb"></span><span class="verb"> The NvEncodeAPI decides to encode I2 as B frame and buffers I2 by copying it</span></i></td></tr>
<tr><th id="2429">2429</th><td><i class="doc"><span class="verb"></span><span class="verb"> to internal buffer and returns ::NV_ENC_ERR_NEED_MORE_INPUT.</span></i></td></tr>
<tr><th id="2430">2430</th><td><i class="doc"><span class="verb"></span><span class="verb"> The error is not fatal and it notifies client that it cannot read the encoded</span></i></td></tr>
<tr><th id="2431">2431</th><td><i class="doc"><span class="verb"></span><span class="verb"> data by locking the output O2 by calling ::NvEncLockBitstream() API without submitting</span></i></td></tr>
<tr><th id="2432">2432</th><td><i class="doc"><span class="verb"></span><span class="verb"> more work to the NvEncodeAPI interface.</span></i></td></tr>
<tr><th id="2433">2433</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2434">2434</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client calls ::NvEncEncodePicture() with input buffer I3 and output buffer O3.</span></i></td></tr>
<tr><th id="2435">2435</th><td><i class="doc"><span class="verb"></span><span class="verb"> The NvEncodeAPI decides to encode I3 as P frame and it first submits I3 for</span></i></td></tr>
<tr><th id="2436">2436</th><td><i class="doc"><span class="verb"></span><span class="verb"> encoding which will be used as backward reference frame for I2.</span></i></td></tr>
<tr><th id="2437">2437</th><td><i class="doc"><span class="verb"></span><span class="verb"> The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS. Both</span></i></td></tr>
<tr><th id="2438">2438</th><td><i class="doc"><span class="verb"></span><span class="verb"> the submission are part of the same ::NvEncEncodePicture() function call.</span></i></td></tr>
<tr><th id="2439">2439</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client can now read the encoded data for both the frames by locking the output</span></i></td></tr>
<tr><th id="2440">2440</th><td><i class="doc"><span class="verb"></span><span class="verb"> O2 followed by  O3 ,by calling ::NvEncLockBitstream() API.</span></i></td></tr>
<tr><th id="2441">2441</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2442">2442</th><td><i class="doc"><span class="verb"></span><span class="verb"> The client must always lock the output in the same order in which it has submitted</span></i></td></tr>
<tr><th id="2443">2443</th><td><i class="doc"><span class="verb"></span><span class="verb"> to receive the encoded bitstream in correct encoding order.</span></i></td></tr>
<tr><th id="2444">2444</th><td><i class="doc"><span class="verb"></span><span class="verb"></span></i></td></tr>
<tr><th id="2445">2445</th><td><i class="doc"><span class="verb"></span> * \endcode</i></td></tr>
<tr><th id="2446">2446</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2447">2447</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2448">2448</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2449">2449</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">encodePicParams</span></i></td></tr>
<tr><th id="2450">2450</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_PIC_PARAMS structure.</i></td></tr>
<tr><th id="2451">2451</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2452">2452</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2453">2453</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2454">2454</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2455">2455</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2456">2456</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2457">2457</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2458">2458</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2459">2459</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2460">2460</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2461">2461</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_BUSY<span class="command"> \n</span></i></td></tr>
<tr><th id="2462">2462</th><td><i class="doc"> * ::NV_ENC_ERR_NEED_MORE_INPUT<span class="command"> \n</span></i></td></tr>
<tr><th id="2463">2463</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2464">2464</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2465">2465</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2466">2466</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2467">2467</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncEncodePicture" title='NvEncEncodePicture' data-ref="NvEncEncodePicture">NvEncEncodePicture</dfn>                         (<em>void</em>* <dfn class="local col7 decl" id="57encoder" title='encoder' data-type='void *' data-ref="57encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_PIC_PARAMS" title='NV_ENC_PIC_PARAMS' data-type='struct _NV_ENC_PIC_PARAMS' data-ref="NV_ENC_PIC_PARAMS">NV_ENC_PIC_PARAMS</a>* <dfn class="local col8 decl" id="58encodePicParams" title='encodePicParams' data-type='NV_ENC_PIC_PARAMS *' data-ref="58encodePicParams">encodePicParams</dfn>);</td></tr>
<tr><th id="2468">2468</th><td></td></tr>
<tr><th id="2469">2469</th><td></td></tr>
<tr><th id="2470">2470</th><td><i>// NvEncLockBitstream</i></td></tr>
<tr><th id="2471">2471</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2472">2472</th><td><i class="doc"> * <span class="command">\brief</span> Lock output bitstream buffer</i></td></tr>
<tr><th id="2473">2473</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2474">2474</th><td><i class="doc"> * This function is used to lock the bitstream buffer to read the encoded data.</i></td></tr>
<tr><th id="2475">2475</th><td><i class="doc"> * The client can only access the encoded data by calling this function.</i></td></tr>
<tr><th id="2476">2476</th><td><i class="doc"> * The pointer to client accessible encoded data is returned in the</i></td></tr>
<tr><th id="2477">2477</th><td><i class="doc"> * NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr field. The size of the encoded data</i></td></tr>
<tr><th id="2478">2478</th><td><i class="doc"> * in the output buffer is returned in the NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes</i></td></tr>
<tr><th id="2479">2479</th><td><i class="doc"> * The NvEncodeAPI interface also returns the output picture type and picture structure</i></td></tr>
<tr><th id="2480">2480</th><td><i class="doc"> * of the encoded frame in NV_ENC_LOCK_BITSTREAM::pictureType and</i></td></tr>
<tr><th id="2481">2481</th><td><i class="doc"> * NV_ENC_LOCK_BITSTREAM::pictureStruct fields respectively. If the client has</i></td></tr>
<tr><th id="2482">2482</th><td><i class="doc"> * set NV_ENC_LOCK_BITSTREAM::doNotWait to 1, the function might return</i></td></tr>
<tr><th id="2483">2483</th><td><i class="doc"> * ::NV_ENC_ERR_LOCK_BUSY if client is operating in synchronous mode. This is not</i></td></tr>
<tr><th id="2484">2484</th><td><i class="doc"> * a fatal failure if NV_ENC_LOCK_BITSTREAM::doNotWait is set to 1. In the above case the client can</i></td></tr>
<tr><th id="2485">2485</th><td><i class="doc"> * retry the function after few milliseconds.</i></td></tr>
<tr><th id="2486">2486</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2487">2487</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2488">2488</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2489">2489</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">lockBitstreamBufferParams</span></i></td></tr>
<tr><th id="2490">2490</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_LOCK_BITSTREAM structure.</i></td></tr>
<tr><th id="2491">2491</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2492">2492</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2493">2493</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2494">2494</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2495">2495</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2496">2496</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2497">2497</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2498">2498</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2499">2499</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2500">2500</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2501">2501</th><td><i class="doc"> * ::NV_ENC_ERR_LOCK_BUSY<span class="command"> \n</span></i></td></tr>
<tr><th id="2502">2502</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2503">2503</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2504">2504</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2505">2505</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2506">2506</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncLockBitstream" title='NvEncLockBitstream' data-ref="NvEncLockBitstream">NvEncLockBitstream</dfn>                         (<em>void</em>* <dfn class="local col9 decl" id="59encoder" title='encoder' data-type='void *' data-ref="59encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_LOCK_BITSTREAM" title='NV_ENC_LOCK_BITSTREAM' data-type='struct _NV_ENC_LOCK_BITSTREAM' data-ref="NV_ENC_LOCK_BITSTREAM">NV_ENC_LOCK_BITSTREAM</a>* <dfn class="local col0 decl" id="60lockBitstreamBufferParams" title='lockBitstreamBufferParams' data-type='NV_ENC_LOCK_BITSTREAM *' data-ref="60lockBitstreamBufferParams">lockBitstreamBufferParams</dfn>);</td></tr>
<tr><th id="2507">2507</th><td></td></tr>
<tr><th id="2508">2508</th><td></td></tr>
<tr><th id="2509">2509</th><td><i>// NvEncUnlockBitstream</i></td></tr>
<tr><th id="2510">2510</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2511">2511</th><td><i class="doc"> * <span class="command">\brief</span> Unlock the output bitstream buffer</i></td></tr>
<tr><th id="2512">2512</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2513">2513</th><td><i class="doc"> * This function is used to unlock the output bitstream buffer after the client</i></td></tr>
<tr><th id="2514">2514</th><td><i class="doc"> * has read the encoded data from output buffer. The client must call this function</i></td></tr>
<tr><th id="2515">2515</th><td><i class="doc"> * to unlock the output buffer which it has previously locked using ::NvEncLockBitstream()</i></td></tr>
<tr><th id="2516">2516</th><td><i class="doc"> * function. Using a locked bitstream buffer in ::NvEncEncodePicture() API will cause</i></td></tr>
<tr><th id="2517">2517</th><td><i class="doc"> * the function to fail.</i></td></tr>
<tr><th id="2518">2518</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2519">2519</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2520">2520</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2521">2521</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">bitstreamBuffer</span></i></td></tr>
<tr><th id="2522">2522</th><td><i class="doc"> *   bitstream buffer pointer being unlocked</i></td></tr>
<tr><th id="2523">2523</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2524">2524</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2525">2525</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2526">2526</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2527">2527</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2528">2528</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2529">2529</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2530">2530</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2531">2531</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2532">2532</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2533">2533</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2534">2534</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2535">2535</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2536">2536</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncUnlockBitstream" title='NvEncUnlockBitstream' data-ref="NvEncUnlockBitstream">NvEncUnlockBitstream</dfn>                       (<em>void</em>* <dfn class="local col1 decl" id="61encoder" title='encoder' data-type='void *' data-ref="61encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col2 decl" id="62bitstreamBuffer" title='bitstreamBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="62bitstreamBuffer">bitstreamBuffer</dfn>);</td></tr>
<tr><th id="2537">2537</th><td></td></tr>
<tr><th id="2538">2538</th><td></td></tr>
<tr><th id="2539">2539</th><td><i>// NvLockInputBuffer</i></td></tr>
<tr><th id="2540">2540</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2541">2541</th><td><i class="doc"> * <span class="command">\brief</span> Locks an input buffer</i></td></tr>
<tr><th id="2542">2542</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2543">2543</th><td><i class="doc"> * This function is used to lock the input buffer to load the uncompressed YUV</i></td></tr>
<tr><th id="2544">2544</th><td><i class="doc"> * pixel data into input buffer memory. The client must pass the NV_ENC_INPUT_PTR</i></td></tr>
<tr><th id="2545">2545</th><td><i class="doc"> * it had previously allocated using ::NvEncCreateInputBuffer()in the</i></td></tr>
<tr><th id="2546">2546</th><td><i class="doc"> * NV_ENC_LOCK_INPUT_BUFFER::inputBuffer field.</i></td></tr>
<tr><th id="2547">2547</th><td><i class="doc"> * The NvEncodeAPI interface returns pointer to client accessible input buffer</i></td></tr>
<tr><th id="2548">2548</th><td><i class="doc"> * memory in NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr field.</i></td></tr>
<tr><th id="2549">2549</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2550">2550</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2551">2551</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2552">2552</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">lockInputBufferParams</span></i></td></tr>
<tr><th id="2553">2553</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_LOCK_INPUT_BUFFER structure</i></td></tr>
<tr><th id="2554">2554</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2555">2555</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2556">2556</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2557">2557</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2558">2558</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2559">2559</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2560">2560</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2561">2561</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2562">2562</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2563">2563</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2564">2564</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2565">2565</th><td><i class="doc"> * ::NV_ENC_ERR_LOCK_BUSY<span class="command"> \n</span></i></td></tr>
<tr><th id="2566">2566</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2567">2567</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2568">2568</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2569">2569</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2570">2570</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncLockInputBuffer" title='NvEncLockInputBuffer' data-ref="NvEncLockInputBuffer">NvEncLockInputBuffer</dfn>                      (<em>void</em>* <dfn class="local col3 decl" id="63encoder" title='encoder' data-type='void *' data-ref="63encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_LOCK_INPUT_BUFFER" title='NV_ENC_LOCK_INPUT_BUFFER' data-type='struct _NV_ENC_LOCK_INPUT_BUFFER' data-ref="NV_ENC_LOCK_INPUT_BUFFER">NV_ENC_LOCK_INPUT_BUFFER</a>* <dfn class="local col4 decl" id="64lockInputBufferParams" title='lockInputBufferParams' data-type='NV_ENC_LOCK_INPUT_BUFFER *' data-ref="64lockInputBufferParams">lockInputBufferParams</dfn>);</td></tr>
<tr><th id="2571">2571</th><td></td></tr>
<tr><th id="2572">2572</th><td></td></tr>
<tr><th id="2573">2573</th><td><i>// NvUnlockInputBuffer</i></td></tr>
<tr><th id="2574">2574</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2575">2575</th><td><i class="doc"> * <span class="command">\brief</span> Unlocks the input buffer</i></td></tr>
<tr><th id="2576">2576</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2577">2577</th><td><i class="doc"> * This function is used to unlock the input buffer memory previously locked for</i></td></tr>
<tr><th id="2578">2578</th><td><i class="doc"> * uploading YUV pixel data. The input buffer must be unlocked before being used</i></td></tr>
<tr><th id="2579">2579</th><td><i class="doc"> * again for encoding, otherwise NvEncodeAPI will fail the ::NvEncEncodePicture()</i></td></tr>
<tr><th id="2580">2580</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2581">2581</th><td><i class="doc">  * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2582">2582</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2583">2583</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">inputBuffer</span></i></td></tr>
<tr><th id="2584">2584</th><td><i class="doc"> *   Pointer to the input buffer that is being unlocked.</i></td></tr>
<tr><th id="2585">2585</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2586">2586</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2587">2587</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2588">2588</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2589">2589</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2590">2590</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2591">2591</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2592">2592</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2593">2593</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2594">2594</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2595">2595</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2596">2596</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2597">2597</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2598">2598</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2599">2599</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2600">2600</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncUnlockInputBuffer" title='NvEncUnlockInputBuffer' data-ref="NvEncUnlockInputBuffer">NvEncUnlockInputBuffer</dfn>                     (<em>void</em>* <dfn class="local col5 decl" id="65encoder" title='encoder' data-type='void *' data-ref="65encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col6 decl" id="66inputBuffer" title='inputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="66inputBuffer">inputBuffer</dfn>);</td></tr>
<tr><th id="2601">2601</th><td></td></tr>
<tr><th id="2602">2602</th><td></td></tr>
<tr><th id="2603">2603</th><td><i>// NvEncGetEncodeStats</i></td></tr>
<tr><th id="2604">2604</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2605">2605</th><td><i class="doc"> * <span class="command">\brief</span> Get encoding statistics.</i></td></tr>
<tr><th id="2606">2606</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2607">2607</th><td><i class="doc"> * This function is used to retrieve the encoding statistics.</i></td></tr>
<tr><th id="2608">2608</th><td><i class="doc"> * This API is not supported when encode device type is CUDA.</i></td></tr>
<tr><th id="2609">2609</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2610">2610</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2611">2611</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2612">2612</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">encodeStats</span></i></td></tr>
<tr><th id="2613">2613</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_STAT structure.</i></td></tr>
<tr><th id="2614">2614</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2615">2615</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2616">2616</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2617">2617</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2618">2618</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2619">2619</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2620">2620</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2621">2621</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2622">2622</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2623">2623</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2624">2624</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2625">2625</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2626">2626</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2627">2627</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetEncodeStats" title='NvEncGetEncodeStats' data-ref="NvEncGetEncodeStats">NvEncGetEncodeStats</dfn>                        (<em>void</em>* <dfn class="local col7 decl" id="67encoder" title='encoder' data-type='void *' data-ref="67encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_STAT" title='NV_ENC_STAT' data-type='struct _NV_ENC_STAT' data-ref="NV_ENC_STAT">NV_ENC_STAT</a>* <dfn class="local col8 decl" id="68encodeStats" title='encodeStats' data-type='NV_ENC_STAT *' data-ref="68encodeStats">encodeStats</dfn>);</td></tr>
<tr><th id="2628">2628</th><td></td></tr>
<tr><th id="2629">2629</th><td></td></tr>
<tr><th id="2630">2630</th><td><i>// NvEncGetSequenceParams</i></td></tr>
<tr><th id="2631">2631</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2632">2632</th><td><i class="doc"> * <span class="command">\brief</span> Get encoded sequence and picture header.</i></td></tr>
<tr><th id="2633">2633</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2634">2634</th><td><i class="doc"> * This function can be used to retrieve the sequence and picture header out of</i></td></tr>
<tr><th id="2635">2635</th><td><i class="doc"> * band. The client must call this function only after the encoder has been</i></td></tr>
<tr><th id="2636">2636</th><td><i class="doc"> * initialized using ::NvEncInitializeEncoder() function. The client must</i></td></tr>
<tr><th id="2637">2637</th><td><i class="doc"> * allocate the memory where the NvEncodeAPI interface can copy the bitstream</i></td></tr>
<tr><th id="2638">2638</th><td><i class="doc"> * header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer.</i></td></tr>
<tr><th id="2639">2639</th><td><i class="doc"> * The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.</i></td></tr>
<tr><th id="2640">2640</th><td><i class="doc"> * The NvEncodeAPI interface will copy the bitstream header payload and returns</i></td></tr>
<tr><th id="2641">2641</th><td><i class="doc"> * the actual size of the bitstream header in the field</i></td></tr>
<tr><th id="2642">2642</th><td><i class="doc"> * NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize.</i></td></tr>
<tr><th id="2643">2643</th><td><i class="doc"> * The client must call  ::NvEncGetSequenceParams() function from the same thread which is</i></td></tr>
<tr><th id="2644">2644</th><td><i class="doc"> * being used to call ::NvEncEncodePicture() function.</i></td></tr>
<tr><th id="2645">2645</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2646">2646</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2647">2647</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2648">2648</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">sequenceParamPayload</span></i></td></tr>
<tr><th id="2649">2649</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD structure.</i></td></tr>
<tr><th id="2650">2650</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2651">2651</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2652">2652</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2653">2653</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2654">2654</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2655">2655</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2656">2656</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2657">2657</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2658">2658</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2659">2659</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2660">2660</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2661">2661</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2662">2662</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2663">2663</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2664">2664</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncGetSequenceParams" title='NvEncGetSequenceParams' data-ref="NvEncGetSequenceParams">NvEncGetSequenceParams</dfn>                     (<em>void</em>* <dfn class="local col9 decl" id="69encoder" title='encoder' data-type='void *' data-ref="69encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_SEQUENCE_PARAM_PAYLOAD" title='NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-type='struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-ref="NV_ENC_SEQUENCE_PARAM_PAYLOAD">NV_ENC_SEQUENCE_PARAM_PAYLOAD</a>* <dfn class="local col0 decl" id="70sequenceParamPayload" title='sequenceParamPayload' data-type='NV_ENC_SEQUENCE_PARAM_PAYLOAD *' data-ref="70sequenceParamPayload">sequenceParamPayload</dfn>);</td></tr>
<tr><th id="2665">2665</th><td></td></tr>
<tr><th id="2666">2666</th><td></td></tr>
<tr><th id="2667">2667</th><td><i>// NvEncRegisterAsyncEvent</i></td></tr>
<tr><th id="2668">2668</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2669">2669</th><td><i class="doc"> * <span class="command">\brief</span> Register event for notification to encoding completion.</i></td></tr>
<tr><th id="2670">2670</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2671">2671</th><td><i class="doc"> * This function is used to register the completion event with NvEncodeAPI</i></td></tr>
<tr><th id="2672">2672</th><td><i class="doc"> * interface. The event is required when the client has configured the encoder to</i></td></tr>
<tr><th id="2673">2673</th><td><i class="doc"> * work in asynchronous mode. In this mode the client needs to send a completion</i></td></tr>
<tr><th id="2674">2674</th><td><i class="doc"> * event with every output buffer. The NvEncodeAPI interface will signal the</i></td></tr>
<tr><th id="2675">2675</th><td><i class="doc"> * completion of the encoding process using this event. Only after the event is</i></td></tr>
<tr><th id="2676">2676</th><td><i class="doc"> * signalled the client can get the encoded data using ::NvEncLockBitstream() function.</i></td></tr>
<tr><th id="2677">2677</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2678">2678</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2679">2679</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2680">2680</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">eventParams</span></i></td></tr>
<tr><th id="2681">2681</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_EVENT_PARAMS structure.</i></td></tr>
<tr><th id="2682">2682</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2683">2683</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2684">2684</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2685">2685</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2686">2686</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2687">2687</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2688">2688</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2689">2689</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2690">2690</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2691">2691</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2692">2692</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2693">2693</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2694">2694</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2695">2695</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2696">2696</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncRegisterAsyncEvent" title='NvEncRegisterAsyncEvent' data-ref="NvEncRegisterAsyncEvent">NvEncRegisterAsyncEvent</dfn>                    (<em>void</em>* <dfn class="local col1 decl" id="71encoder" title='encoder' data-type='void *' data-ref="71encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_EVENT_PARAMS" title='NV_ENC_EVENT_PARAMS' data-type='struct _NV_ENC_EVENT_PARAMS' data-ref="NV_ENC_EVENT_PARAMS">NV_ENC_EVENT_PARAMS</a>* <dfn class="local col2 decl" id="72eventParams" title='eventParams' data-type='NV_ENC_EVENT_PARAMS *' data-ref="72eventParams">eventParams</dfn>);</td></tr>
<tr><th id="2697">2697</th><td></td></tr>
<tr><th id="2698">2698</th><td></td></tr>
<tr><th id="2699">2699</th><td><i>// NvEncUnregisterAsyncEvent</i></td></tr>
<tr><th id="2700">2700</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2701">2701</th><td><i class="doc"> * <span class="command">\brief</span> Unregister completion event.</i></td></tr>
<tr><th id="2702">2702</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2703">2703</th><td><i class="doc"> * This function is used to unregister completion event which has been previously</i></td></tr>
<tr><th id="2704">2704</th><td><i class="doc"> * registered using ::NvEncRegisterAsyncEvent() function. The client must unregister</i></td></tr>
<tr><th id="2705">2705</th><td><i class="doc"> * all events before destroying the encoder using ::NvEncDestroyEncoder() function.</i></td></tr>
<tr><th id="2706">2706</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2707">2707</th><td><i class="doc">  * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2708">2708</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2709">2709</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">eventParams</span></i></td></tr>
<tr><th id="2710">2710</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_EVENT_PARAMS structure.</i></td></tr>
<tr><th id="2711">2711</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2712">2712</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2713">2713</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2714">2714</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2715">2715</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2716">2716</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2717">2717</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2718">2718</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2719">2719</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2720">2720</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2721">2721</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2722">2722</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2723">2723</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2724">2724</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2725">2725</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncUnregisterAsyncEvent" title='NvEncUnregisterAsyncEvent' data-ref="NvEncUnregisterAsyncEvent">NvEncUnregisterAsyncEvent</dfn>                  (<em>void</em>* <dfn class="local col3 decl" id="73encoder" title='encoder' data-type='void *' data-ref="73encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_EVENT_PARAMS" title='NV_ENC_EVENT_PARAMS' data-type='struct _NV_ENC_EVENT_PARAMS' data-ref="NV_ENC_EVENT_PARAMS">NV_ENC_EVENT_PARAMS</a>* <dfn class="local col4 decl" id="74eventParams" title='eventParams' data-type='NV_ENC_EVENT_PARAMS *' data-ref="74eventParams">eventParams</dfn>);</td></tr>
<tr><th id="2726">2726</th><td></td></tr>
<tr><th id="2727">2727</th><td></td></tr>
<tr><th id="2728">2728</th><td><i>// NvEncMapInputResource</i></td></tr>
<tr><th id="2729">2729</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2730">2730</th><td><i class="doc"> * <span class="command">\brief</span> Map an externally created input resource pointer for encoding.</i></td></tr>
<tr><th id="2731">2731</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2732">2732</th><td><i class="doc"> * Maps an externally allocated input resource [using and returns a NV_ENC_INPUT_PTR</i></td></tr>
<tr><th id="2733">2733</th><td><i class="doc"> * which can be used for encoding in the ::NvEncEncodePicture() function. The</i></td></tr>
<tr><th id="2734">2734</th><td><i class="doc"> * mapped resource is returned in the field NV_ENC_MAP_INPUT_RESOURCE::outputResourcePtr.</i></td></tr>
<tr><th id="2735">2735</th><td><i class="doc"> * The NvEncodeAPI interface also returns the buffer format of the mapped resource</i></td></tr>
<tr><th id="2736">2736</th><td><i class="doc"> * in the field NV_ENC_MAP_INPUT_RESOURCE::outbufferFmt.</i></td></tr>
<tr><th id="2737">2737</th><td><i class="doc"> * This function provides synchronization guarantee that any direct3d or cuda</i></td></tr>
<tr><th id="2738">2738</th><td><i class="doc"> * work submitted on the input buffer is completed before the buffer is used for encoding.</i></td></tr>
<tr><th id="2739">2739</th><td><i class="doc"> * The client should not access any input buffer while they are mapped by the encoder.</i></td></tr>
<tr><th id="2740">2740</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2741">2741</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2742">2742</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2743">2743</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">mapInputResParams</span></i></td></tr>
<tr><th id="2744">2744</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_MAP_INPUT_RESOURCE structure.</i></td></tr>
<tr><th id="2745">2745</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2746">2746</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2747">2747</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2748">2748</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2749">2749</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2750">2750</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2751">2751</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2752">2752</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2753">2753</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2754">2754</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2755">2755</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2756">2756</th><td><i class="doc"> * ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED<span class="command"> \n</span></i></td></tr>
<tr><th id="2757">2757</th><td><i class="doc"> * ::NV_ENC_ERR_MAP_FAILED<span class="command"> \n</span></i></td></tr>
<tr><th id="2758">2758</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2759">2759</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2760">2760</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2761">2761</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncMapInputResource" title='NvEncMapInputResource' data-ref="NvEncMapInputResource">NvEncMapInputResource</dfn>                         (<em>void</em>* <dfn class="local col5 decl" id="75encoder" title='encoder' data-type='void *' data-ref="75encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_MAP_INPUT_RESOURCE" title='NV_ENC_MAP_INPUT_RESOURCE' data-type='struct _NV_ENC_MAP_INPUT_RESOURCE' data-ref="NV_ENC_MAP_INPUT_RESOURCE">NV_ENC_MAP_INPUT_RESOURCE</a>* <dfn class="local col6 decl" id="76mapInputResParams" title='mapInputResParams' data-type='NV_ENC_MAP_INPUT_RESOURCE *' data-ref="76mapInputResParams">mapInputResParams</dfn>);</td></tr>
<tr><th id="2762">2762</th><td></td></tr>
<tr><th id="2763">2763</th><td></td></tr>
<tr><th id="2764">2764</th><td><i>// NvEncUnmapInputResource</i></td></tr>
<tr><th id="2765">2765</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2766">2766</th><td><i class="doc"> * <span class="command">\brief</span>  UnMaps a NV_ENC_INPUT_PTR  which was mapped for encoding</i></td></tr>
<tr><th id="2767">2767</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2768">2768</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2769">2769</th><td><i class="doc"> * UnMaps an input buffer which was previously mapped using ::NvEncMapInputResource()</i></td></tr>
<tr><th id="2770">2770</th><td><i class="doc"> * API. The mapping created using ::NvEncMapInputResource() should be invalidated</i></td></tr>
<tr><th id="2771">2771</th><td><i class="doc"> * using this API before the external resource is destroyed by the client. The client</i></td></tr>
<tr><th id="2772">2772</th><td><i class="doc"> * must unmap the buffer after ::NvEncLockBitstream() API returns succuessfully for encode</i></td></tr>
<tr><th id="2773">2773</th><td><i class="doc"> * work submitted using the mapped input buffer.</i></td></tr>
<tr><th id="2774">2774</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2775">2775</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2776">2776</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2777">2777</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2778">2778</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">mappedInputBuffer</span></i></td></tr>
<tr><th id="2779">2779</th><td><i class="doc"> *   Pointer to the NV_ENC_INPUT_PTR</i></td></tr>
<tr><th id="2780">2780</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2781">2781</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2782">2782</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2783">2783</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2784">2784</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2785">2785</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2786">2786</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2787">2787</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2788">2788</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2789">2789</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2790">2790</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2791">2791</th><td><i class="doc"> * ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED<span class="command"> \n</span></i></td></tr>
<tr><th id="2792">2792</th><td><i class="doc"> * ::NV_ENC_ERR_RESOURCE_NOT_MAPPED<span class="command"> \n</span></i></td></tr>
<tr><th id="2793">2793</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2794">2794</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2795">2795</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2796">2796</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncUnmapInputResource" title='NvEncUnmapInputResource' data-ref="NvEncUnmapInputResource">NvEncUnmapInputResource</dfn>                         (<em>void</em>* <dfn class="local col7 decl" id="77encoder" title='encoder' data-type='void *' data-ref="77encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col8 decl" id="78mappedInputBuffer" title='mappedInputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="78mappedInputBuffer">mappedInputBuffer</dfn>);</td></tr>
<tr><th id="2797">2797</th><td></td></tr>
<tr><th id="2798">2798</th><td><i>// NvEncDestroyEncoder</i></td></tr>
<tr><th id="2799">2799</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2800">2800</th><td><i class="doc"> * <span class="command">\brief</span> Destroy Encoding Session</i></td></tr>
<tr><th id="2801">2801</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2802">2802</th><td><i class="doc"> * Destroys the encoder session previously created using ::NvEncOpenEncodeSession()</i></td></tr>
<tr><th id="2803">2803</th><td><i class="doc"> * function. The client must flush the encoder before freeing any resources. In order</i></td></tr>
<tr><th id="2804">2804</th><td><i class="doc"> * to flush the encoder the client must pass a NULL encode picture packet and either</i></td></tr>
<tr><th id="2805">2805</th><td><i class="doc"> * wait for the ::NvEncEncodePicture() function to return in synchronous mode or wait</i></td></tr>
<tr><th id="2806">2806</th><td><i class="doc"> * for the flush event to be signaled by the encoder in asynchronous mode.</i></td></tr>
<tr><th id="2807">2807</th><td><i class="doc"> * The client must free all the input and output resources created using the</i></td></tr>
<tr><th id="2808">2808</th><td><i class="doc"> * NvEncodeAPI interface before destroying the encoder. If the client is operating</i></td></tr>
<tr><th id="2809">2809</th><td><i class="doc"> * in asynchronous mode, it must also unregister the completion events previously</i></td></tr>
<tr><th id="2810">2810</th><td><i class="doc"> * registered.</i></td></tr>
<tr><th id="2811">2811</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2812">2812</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2813">2813</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2814">2814</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2815">2815</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2816">2816</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2817">2817</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2818">2818</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2819">2819</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2820">2820</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2821">2821</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2822">2822</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2823">2823</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2824">2824</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2825">2825</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2826">2826</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncDestroyEncoder" title='NvEncDestroyEncoder' data-ref="NvEncDestroyEncoder">NvEncDestroyEncoder</dfn>                        (<em>void</em>* <dfn class="local col9 decl" id="79encoder" title='encoder' data-type='void *' data-ref="79encoder">encoder</dfn>);</td></tr>
<tr><th id="2827">2827</th><td></td></tr>
<tr><th id="2828">2828</th><td><i>// NvEncInvalidateRefFrames</i></td></tr>
<tr><th id="2829">2829</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2830">2830</th><td><i class="doc"> * <span class="command">\brief</span> Invalidate reference frames</i></td></tr>
<tr><th id="2831">2831</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2832">2832</th><td><i class="doc"> * Invalidates reference frame based on the time stamp provided by the client.</i></td></tr>
<tr><th id="2833">2833</th><td><i class="doc"> * The encoder marks any reference frames or any frames which have been reconstructed</i></td></tr>
<tr><th id="2834">2834</th><td><i class="doc"> * using the corrupt frame as invalid for motion estimation and uses older reference</i></td></tr>
<tr><th id="2835">2835</th><td><i class="doc"> * frames for motion estimation. The encoded forces the current frame to be encoded</i></td></tr>
<tr><th id="2836">2836</th><td><i class="doc"> * as an intra frame if no reference frames are left after invalidation process.</i></td></tr>
<tr><th id="2837">2837</th><td><i class="doc"> * This is useful for low latency application for error resiliency. The client</i></td></tr>
<tr><th id="2838">2838</th><td><i class="doc"> * is recommended to set NV_ENC_CONFIG_H264::maxNumRefFrames to a large value so</i></td></tr>
<tr><th id="2839">2839</th><td><i class="doc"> * that encoder can keep a backup of older reference frames in the DPB and can use them</i></td></tr>
<tr><th id="2840">2840</th><td><i class="doc"> * for motion estimation when the newer reference frames have been invalidated.</i></td></tr>
<tr><th id="2841">2841</th><td><i class="doc"> * This API can be called multiple times.</i></td></tr>
<tr><th id="2842">2842</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2843">2843</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2844">2844</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2845">2845</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">invalidRefFrameTimeStamp</span></i></td></tr>
<tr><th id="2846">2846</th><td><i class="doc"> *   Timestamp of the invalid reference frames which needs to be invalidated.</i></td></tr>
<tr><th id="2847">2847</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2848">2848</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2849">2849</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2850">2850</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2851">2851</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2852">2852</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2853">2853</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2854">2854</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2855">2855</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2856">2856</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2857">2857</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2858">2858</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2859">2859</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncInvalidateRefFrames" title='NvEncInvalidateRefFrames' data-ref="NvEncInvalidateRefFrames">NvEncInvalidateRefFrames</dfn>(<em>void</em>* <dfn class="local col0 decl" id="80encoder" title='encoder' data-type='void *' data-ref="80encoder">encoder</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="local col1 decl" id="81invalidRefFrameTimeStamp" title='invalidRefFrameTimeStamp' data-type='uint64_t' data-ref="81invalidRefFrameTimeStamp">invalidRefFrameTimeStamp</dfn>);</td></tr>
<tr><th id="2860">2860</th><td></td></tr>
<tr><th id="2861">2861</th><td><i>// NvEncOpenEncodeSessionEx</i></td></tr>
<tr><th id="2862">2862</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2863">2863</th><td><i class="doc"> * <span class="command">\brief</span> Opens an encoding session.</i></td></tr>
<tr><th id="2864">2864</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2865">2865</th><td><i class="doc"> * Opens an encoding session and returns a pointer to the encoder interface in</i></td></tr>
<tr><th id="2866">2866</th><td><i class="doc"> * the<span class="command"> \p</span> <span class="arg">**encoder</span> parameter. The client should start encoding process by calling</i></td></tr>
<tr><th id="2867">2867</th><td><i class="doc"> * this API first.</i></td></tr>
<tr><th id="2868">2868</th><td><i class="doc"> * The client must pass a pointer to IDirect3DDevice9/CUDA interface in the<span class="command"> \p</span> <span class="arg">*device</span> parameter.</i></td></tr>
<tr><th id="2869">2869</th><td><i class="doc"> * If the creation of encoder session fails, the client must call ::NvEncDestroyEncoder API</i></td></tr>
<tr><th id="2870">2870</th><td><i class="doc"> * before exiting.</i></td></tr>
<tr><th id="2871">2871</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2872">2872</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">openSessionExParams</span></i></td></tr>
<tr><th id="2873">2873</th><td><i class="doc"> *    Pointer to a ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS structure.</i></td></tr>
<tr><th id="2874">2874</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2875">2875</th><td><i class="doc"> *    Encode Session pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="2876">2876</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2877">2877</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2878">2878</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2879">2879</th><td><i class="doc"> * ::NV_ENC_ERR_NO_ENCODE_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2880">2880</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2881">2881</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2882">2882</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2883">2883</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2884">2884</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2885">2885</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2886">2886</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2887">2887</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncOpenEncodeSessionEx" title='NvEncOpenEncodeSessionEx' data-ref="NvEncOpenEncodeSessionEx">NvEncOpenEncodeSessionEx</dfn>                   (<a class="typedef" href="#NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS" title='NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS' data-type='struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS' data-ref="NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS">NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS</a> *<dfn class="local col2 decl" id="82openSessionExParams" title='openSessionExParams' data-type='NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *' data-ref="82openSessionExParams">openSessionExParams</dfn>, <em>void</em>** <dfn class="local col3 decl" id="83encoder" title='encoder' data-type='void **' data-ref="83encoder">encoder</dfn>);</td></tr>
<tr><th id="2888">2888</th><td></td></tr>
<tr><th id="2889">2889</th><td><i>// NvEncRegisterResource</i></td></tr>
<tr><th id="2890">2890</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2891">2891</th><td><i class="doc"> * <span class="command">\brief</span> Registers a resource with the Nvidia Video Encoder Interface.</i></td></tr>
<tr><th id="2892">2892</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2893">2893</th><td><i class="doc"> * Registers a resource with the Nvidia Video Encoder Interface for book keeping.</i></td></tr>
<tr><th id="2894">2894</th><td><i class="doc"> * The client is expected to pass the registered resource handle as well, while calling ::NvEncMapInputResource API.</i></td></tr>
<tr><th id="2895">2895</th><td><i class="doc"> * This API is not implemented for the DirectX Interface.</i></td></tr>
<tr><th id="2896">2896</th><td><i class="doc"> * DirectX based clients need not change their implementation.</i></td></tr>
<tr><th id="2897">2897</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2898">2898</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2899">2899</th><td><i class="doc"> *   Pointer to the NVEncodeAPI interface.</i></td></tr>
<tr><th id="2900">2900</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2901">2901</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">registerResParams</span></i></td></tr>
<tr><th id="2902">2902</th><td><i class="doc"> *   Pointer to a ::_NV_ENC_REGISTER_RESOURCE structure</i></td></tr>
<tr><th id="2903">2903</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2904">2904</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2905">2905</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2906">2906</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2907">2907</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2908">2908</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2909">2909</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2910">2910</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2911">2911</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2912">2912</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2913">2913</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2914">2914</th><td><i class="doc"> * ::NV_ENC_ERR_RESOURCE_REGISTER_FAILED<span class="command"> \n</span></i></td></tr>
<tr><th id="2915">2915</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2916">2916</th><td><i class="doc"> * ::NV_ENC_ERR_UNIMPLEMENTED<span class="command"> \n</span></i></td></tr>
<tr><th id="2917">2917</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2918">2918</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2919">2919</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncRegisterResource" title='NvEncRegisterResource' data-ref="NvEncRegisterResource">NvEncRegisterResource</dfn>                      (<em>void</em>* <dfn class="local col4 decl" id="84encoder" title='encoder' data-type='void *' data-ref="84encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_REGISTER_RESOURCE" title='NV_ENC_REGISTER_RESOURCE' data-type='struct _NV_ENC_REGISTER_RESOURCE' data-ref="NV_ENC_REGISTER_RESOURCE">NV_ENC_REGISTER_RESOURCE</a>* <dfn class="local col5 decl" id="85registerResParams" title='registerResParams' data-type='NV_ENC_REGISTER_RESOURCE *' data-ref="85registerResParams">registerResParams</dfn>);</td></tr>
<tr><th id="2920">2920</th><td></td></tr>
<tr><th id="2921">2921</th><td><i>// NvEncUnregisterResource</i></td></tr>
<tr><th id="2922">2922</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2923">2923</th><td><i class="doc"> * <span class="command">\brief</span> Unregisters a resource previously registered with the Nvidia Video Encoder Interface.</i></td></tr>
<tr><th id="2924">2924</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2925">2925</th><td><i class="doc"> * Unregisters a resource previously registered with the Nvidia Video Encoder Interface.</i></td></tr>
<tr><th id="2926">2926</th><td><i class="doc"> * The client is expected to unregister any resource that it has registered with the</i></td></tr>
<tr><th id="2927">2927</th><td><i class="doc"> * Nvidia Video Encoder Interface before destroying the resource.</i></td></tr>
<tr><th id="2928">2928</th><td><i class="doc"> * This API is not implemented for the DirectX Interface.</i></td></tr>
<tr><th id="2929">2929</th><td><i class="doc"> * DirectX based clients need not change their implementation.</i></td></tr>
<tr><th id="2930">2930</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2931">2931</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2932">2932</th><td><i class="doc"> *   Pointer to the NVEncodeAPI interface.</i></td></tr>
<tr><th id="2933">2933</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2934">2934</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">registeredResource</span></i></td></tr>
<tr><th id="2935">2935</th><td><i class="doc"> *   The registered resource pointer that was returned in ::NvEncRegisterResource.</i></td></tr>
<tr><th id="2936">2936</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2937">2937</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2938">2938</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2939">2939</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2940">2940</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2941">2941</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2942">2942</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2943">2943</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="2944">2944</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="2945">2945</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2946">2946</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="2947">2947</th><td><i class="doc"> * ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED<span class="command"> \n</span></i></td></tr>
<tr><th id="2948">2948</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2949">2949</th><td><i class="doc"> * ::NV_ENC_ERR_UNIMPLEMENTED<span class="command"> \n</span></i></td></tr>
<tr><th id="2950">2950</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2951">2951</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2952">2952</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncUnregisterResource" title='NvEncUnregisterResource' data-ref="NvEncUnregisterResource">NvEncUnregisterResource</dfn>                    (<em>void</em>* <dfn class="local col6 decl" id="86encoder" title='encoder' data-type='void *' data-ref="86encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_REGISTERED_PTR" title='NV_ENC_REGISTERED_PTR' data-type='void *' data-ref="NV_ENC_REGISTERED_PTR">NV_ENC_REGISTERED_PTR</a> <dfn class="local col7 decl" id="87registeredResource" title='registeredResource' data-type='NV_ENC_REGISTERED_PTR' data-ref="87registeredResource">registeredResource</dfn>);</td></tr>
<tr><th id="2953">2953</th><td></td></tr>
<tr><th id="2954">2954</th><td><i>// NvEncReconfigureEncoder</i></td></tr>
<tr><th id="2955">2955</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2956">2956</th><td><i class="doc"> * <span class="command">\brief</span> Reconfigure an existing encoding session.</i></td></tr>
<tr><th id="2957">2957</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2958">2958</th><td><i class="doc"> * Reconfigure an existing encoding session.</i></td></tr>
<tr><th id="2959">2959</th><td><i class="doc"> * The client should call this API to change/reconfigure the parameter passed during</i></td></tr>
<tr><th id="2960">2960</th><td><i class="doc"> * NvEncInitializeEncoder API call.</i></td></tr>
<tr><th id="2961">2961</th><td><i class="doc"> * Currently Reconfiguration of following are not supported.</i></td></tr>
<tr><th id="2962">2962</th><td><i class="doc"> * Change in GOP structure.</i></td></tr>
<tr><th id="2963">2963</th><td><i class="doc"> * Change in sync-Async mode.</i></td></tr>
<tr><th id="2964">2964</th><td><i class="doc"> * Change in MaxWidth &amp; MaxHeight.</i></td></tr>
<tr><th id="2965">2965</th><td><i class="doc"> * Change in PTDmode.</i></td></tr>
<tr><th id="2966">2966</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2967">2967</th><td><i class="doc"> * Resolution change is possible only if maxEncodeWidth &amp; maxEncodeHeight of NV_ENC_INITIALIZE_PARAMS</i></td></tr>
<tr><th id="2968">2968</th><td><i class="doc"> * is set while creating encoder session.</i></td></tr>
<tr><th id="2969">2969</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2970">2970</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="2971">2971</th><td><i class="doc"> *   Pointer to the NVEncodeAPI interface.</i></td></tr>
<tr><th id="2972">2972</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2973">2973</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">reInitEncodeParams</span></i></td></tr>
<tr><th id="2974">2974</th><td><i class="doc"> *    Pointer to a ::NV_ENC_RECONFIGURE_PARAMS structure.</i></td></tr>
<tr><th id="2975">2975</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="2976">2976</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="2977">2977</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="2978">2978</th><td><i class="doc"> * ::NV_ENC_ERR_NO_ENCODE_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2979">2979</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2980">2980</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_DEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="2981">2981</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="2982">2982</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="2983">2983</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="2984">2984</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2985">2985</th><td><i class="doc"> */</i></td></tr>
<tr><th id="2986">2986</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncReconfigureEncoder" title='NvEncReconfigureEncoder' data-ref="NvEncReconfigureEncoder">NvEncReconfigureEncoder</dfn>                   (<em>void</em> *<dfn class="local col8 decl" id="88encoder" title='encoder' data-type='void *' data-ref="88encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_RECONFIGURE_PARAMS" title='NV_ENC_RECONFIGURE_PARAMS' data-type='struct _NV_ENC_RECONFIGURE_PARAMS' data-ref="NV_ENC_RECONFIGURE_PARAMS">NV_ENC_RECONFIGURE_PARAMS</a>* <dfn class="local col9 decl" id="89reInitEncodeParams" title='reInitEncodeParams' data-type='NV_ENC_RECONFIGURE_PARAMS *' data-ref="89reInitEncodeParams">reInitEncodeParams</dfn>);</td></tr>
<tr><th id="2987">2987</th><td></td></tr>
<tr><th id="2988">2988</th><td></td></tr>
<tr><th id="2989">2989</th><td></td></tr>
<tr><th id="2990">2990</th><td><i>// NvEncCreateMVBuffer</i></td></tr>
<tr><th id="2991">2991</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2992">2992</th><td><i class="doc"> * <span class="command">\brief</span> Allocates output MV buffer for ME only mode.</i></td></tr>
<tr><th id="2993">2993</th><td><i class="doc"> *</i></td></tr>
<tr><th id="2994">2994</th><td><i class="doc"> * This function is used to allocate an output MV buffer. The size of the mvBuffer is</i></td></tr>
<tr><th id="2995">2995</th><td><i class="doc"> * dependent on the frame height and width of the last ::NvEncCreateInputBuffer() call.</i></td></tr>
<tr><th id="2996">2996</th><td><i class="doc"> * The NV_ENC_OUTPUT_PTR returned by the NvEncodeAPI interface in the</i></td></tr>
<tr><th id="2997">2997</th><td><i class="doc"> * ::NV_ENC_CREATE_MV_BUFFER::mvBuffer field should be used in</i></td></tr>
<tr><th id="2998">2998</th><td><i class="doc"> * ::NvEncRunMotionEstimationOnly() API.</i></td></tr>
<tr><th id="2999">2999</th><td><i class="doc"> * Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.</i></td></tr>
<tr><th id="3000">3000</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3001">3001</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="3002">3002</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="3003">3003</th><td><i class="doc"> * <span class="command">\param</span> [in,out] <span class="arg">createMVBufferParams</span></i></td></tr>
<tr><th id="3004">3004</th><td><i class="doc"> *  Pointer to the ::NV_ENC_CREATE_MV_BUFFER structure.</i></td></tr>
<tr><th id="3005">3005</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3006">3006</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="3007">3007</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="3008">3008</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="3009">3009</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="3010">3010</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="3011">3011</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3012">3012</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="3013">3013</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3014">3014</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="3015">3015</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="3016">3016</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3017">3017</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncCreateMVBuffer" title='NvEncCreateMVBuffer' data-ref="NvEncCreateMVBuffer">NvEncCreateMVBuffer</dfn>                        (<em>void</em>* <dfn class="local col0 decl" id="90encoder" title='encoder' data-type='void *' data-ref="90encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_MV_BUFFER" title='NV_ENC_CREATE_MV_BUFFER' data-type='struct _NV_ENC_CREATE_MV_BUFFER' data-ref="NV_ENC_CREATE_MV_BUFFER">NV_ENC_CREATE_MV_BUFFER</a>* <dfn class="local col1 decl" id="91createMVBufferParams" title='createMVBufferParams' data-type='NV_ENC_CREATE_MV_BUFFER *' data-ref="91createMVBufferParams">createMVBufferParams</dfn>);</td></tr>
<tr><th id="3018">3018</th><td></td></tr>
<tr><th id="3019">3019</th><td></td></tr>
<tr><th id="3020">3020</th><td><i>// NvEncDestroyMVBuffer</i></td></tr>
<tr><th id="3021">3021</th><td><i class="doc">/**</i></td></tr>
<tr><th id="3022">3022</th><td><i class="doc"> * <span class="command">\brief</span> Release an output MV buffer for ME only mode.</i></td></tr>
<tr><th id="3023">3023</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3024">3024</th><td><i class="doc"> * This function is used to release the output MV buffer allocated using</i></td></tr>
<tr><th id="3025">3025</th><td><i class="doc"> * the ::NvEncCreateMVBuffer() function. The client must release the output</i></td></tr>
<tr><th id="3026">3026</th><td><i class="doc"> * mvBuffer using this function before destroying the encoder session.</i></td></tr>
<tr><th id="3027">3027</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3028">3028</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="3029">3029</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="3030">3030</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">mvBuffer</span></i></td></tr>
<tr><th id="3031">3031</th><td><i class="doc"> *   Pointer to the mvBuffer being released.</i></td></tr>
<tr><th id="3032">3032</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3033">3033</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="3034">3034</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="3035">3035</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="3036">3036</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="3037">3037</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="3038">3038</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3039">3039</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="3040">3040</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3041">3041</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="3042">3042</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="3043">3043</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="3044">3044</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3045">3045</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncDestroyMVBuffer" title='NvEncDestroyMVBuffer' data-ref="NvEncDestroyMVBuffer">NvEncDestroyMVBuffer</dfn>                       (<em>void</em>* <dfn class="local col2 decl" id="92encoder" title='encoder' data-type='void *' data-ref="92encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col3 decl" id="93mvBuffer" title='mvBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="93mvBuffer">mvBuffer</dfn>);</td></tr>
<tr><th id="3046">3046</th><td></td></tr>
<tr><th id="3047">3047</th><td></td></tr>
<tr><th id="3048">3048</th><td><i>// NvEncRunMotionEstimationOnly</i></td></tr>
<tr><th id="3049">3049</th><td><i class="doc">/**</i></td></tr>
<tr><th id="3050">3050</th><td><i class="doc"> * <span class="command">\brief</span> Submit an input picture and reference frame for motion estimation in ME only mode.</i></td></tr>
<tr><th id="3051">3051</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3052">3052</th><td><i class="doc"> * This function is used to submit the input frame and reference frame for motion</i></td></tr>
<tr><th id="3053">3053</th><td><i class="doc"> * estimation. The ME parameters are passed using *meOnlyParams which is a pointer</i></td></tr>
<tr><th id="3054">3054</th><td><i class="doc"> * to ::_NV_ENC_MEONLY_PARAMS structure.</i></td></tr>
<tr><th id="3055">3055</th><td><i class="doc"> * Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.</i></td></tr>
<tr><th id="3056">3056</th><td><i class="doc"> * to get motion vector data.</i></td></tr>
<tr><th id="3057">3057</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3058">3058</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">encoder</span></i></td></tr>
<tr><th id="3059">3059</th><td><i class="doc"> *   Pointer to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="3060">3060</th><td><i class="doc"> * <span class="command">\param</span> [in] <span class="arg">meOnlyParams</span></i></td></tr>
<tr><th id="3061">3061</th><td><i class="doc"> *   Pointer to the ::_NV_ENC_MEONLY_PARAMS structure.</i></td></tr>
<tr><th id="3062">3062</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3063">3063</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="3064">3064</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="3065">3065</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="3066">3066</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_ENCODERDEVICE<span class="command"> \n</span></i></td></tr>
<tr><th id="3067">3067</th><td><i class="doc"> * ::NV_ENC_ERR_DEVICE_NOT_EXIST<span class="command"> \n</span></i></td></tr>
<tr><th id="3068">3068</th><td><i class="doc"> * ::NV_ENC_ERR_UNSUPPORTED_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3069">3069</th><td><i class="doc"> * ::NV_ENC_ERR_OUT_OF_MEMORY<span class="command"> \n</span></i></td></tr>
<tr><th id="3070">3070</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PARAM<span class="command"> \n</span></i></td></tr>
<tr><th id="3071">3071</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_VERSION<span class="command"> \n</span></i></td></tr>
<tr><th id="3072">3072</th><td><i class="doc"> * ::NV_ENC_ERR_NEED_MORE_INPUT<span class="command"> \n</span></i></td></tr>
<tr><th id="3073">3073</th><td><i class="doc"> * ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED<span class="command"> \n</span></i></td></tr>
<tr><th id="3074">3074</th><td><i class="doc"> * ::NV_ENC_ERR_GENERIC<span class="command"> \n</span></i></td></tr>
<tr><th id="3075">3075</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3076">3076</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncRunMotionEstimationOnly" title='NvEncRunMotionEstimationOnly' data-ref="NvEncRunMotionEstimationOnly">NvEncRunMotionEstimationOnly</dfn>               (<em>void</em>* <dfn class="local col4 decl" id="94encoder" title='encoder' data-type='void *' data-ref="94encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_MEONLY_PARAMS" title='NV_ENC_MEONLY_PARAMS' data-type='struct _NV_ENC_MEONLY_PARAMS' data-ref="NV_ENC_MEONLY_PARAMS">NV_ENC_MEONLY_PARAMS</a>* <dfn class="local col5 decl" id="95meOnlyParams" title='meOnlyParams' data-type='NV_ENC_MEONLY_PARAMS *' data-ref="95meOnlyParams">meOnlyParams</dfn>);</td></tr>
<tr><th id="3077">3077</th><td></td></tr>
<tr><th id="3078">3078</th><td><i>// NvEncodeAPIGetMaxSupportedVersion</i></td></tr>
<tr><th id="3079">3079</th><td><i class="doc">/**</i></td></tr>
<tr><th id="3080">3080</th><td><i class="doc"> * <span class="command">\brief</span> Get the largest NvEncodeAPI version supported by the driver.</i></td></tr>
<tr><th id="3081">3081</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3082">3082</th><td><i class="doc"> * This function can be used by clients to determine if the driver supports</i></td></tr>
<tr><th id="3083">3083</th><td><i class="doc"> * the NvEncodeAPI header the application was compiled with.</i></td></tr>
<tr><th id="3084">3084</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3085">3085</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">version</span></i></td></tr>
<tr><th id="3086">3086</th><td><i class="doc"> *   Pointer to the requested value. The 4 least significant bits in the returned</i></td></tr>
<tr><th id="3087">3087</th><td><i class="doc"> *   indicate the minor version and the rest of the bits indicate the major</i></td></tr>
<tr><th id="3088">3088</th><td><i class="doc"> *   version of the largest supported version.</i></td></tr>
<tr><th id="3089">3089</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3090">3090</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="3091">3091</th><td><i class="doc"> * ::NV_ENC_SUCCESS<span class="command"> \n</span></i></td></tr>
<tr><th id="3092">3092</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR<span class="command"> \n</span></i></td></tr>
<tr><th id="3093">3093</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3094">3094</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncodeAPIGetMaxSupportedVersion" title='NvEncodeAPIGetMaxSupportedVersion' data-ref="NvEncodeAPIGetMaxSupportedVersion">NvEncodeAPIGetMaxSupportedVersion</dfn>          (<a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col6 decl" id="96version" title='version' data-type='uint32_t *' data-ref="96version">version</dfn>);</td></tr>
<tr><th id="3095">3095</th><td></td></tr>
<tr><th id="3096">3096</th><td></td></tr>
<tr><th id="3097">3097</th><td><i class="doc">///<span class="command"> \cond</span> API PFN</i></td></tr>
<tr><th id="3098">3098</th><td><i>/*</i></td></tr>
<tr><th id="3099">3099</th><td><i> *  Defines API function pointers</i></td></tr>
<tr><th id="3100">3100</th><td><i> */</i></td></tr>
<tr><th id="3101">3101</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCOPENENCODESESSION" title='PNVENCOPENENCODESESSION' data-type='NVENCSTATUS (*)(void *, uint32_t, void **)' data-ref="PNVENCOPENENCODESESSION">PNVENCOPENENCODESESSION</dfn>)         (<em>void</em>* <dfn class="local col7 decl" id="97device" title='device' data-type='void *' data-ref="97device">device</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col8 decl" id="98deviceType" title='deviceType' data-type='uint32_t' data-ref="98deviceType">deviceType</dfn>, <em>void</em>** <dfn class="local col9 decl" id="99encoder" title='encoder' data-type='void **' data-ref="99encoder">encoder</dfn>);</td></tr>
<tr><th id="3102">3102</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEGUIDCOUNT" title='PNVENCGETENCODEGUIDCOUNT' data-type='NVENCSTATUS (*)(void *, uint32_t *)' data-ref="PNVENCGETENCODEGUIDCOUNT">PNVENCGETENCODEGUIDCOUNT</dfn>)        (<em>void</em>* <dfn class="local col0 decl" id="100encoder" title='encoder' data-type='void *' data-ref="100encoder">encoder</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col1 decl" id="101encodeGUIDCount" title='encodeGUIDCount' data-type='uint32_t *' data-ref="101encodeGUIDCount">encodeGUIDCount</dfn>);</td></tr>
<tr><th id="3103">3103</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEGUIDS" title='PNVENCGETENCODEGUIDS' data-type='NVENCSTATUS (*)(void *, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEGUIDS">PNVENCGETENCODEGUIDS</dfn>)            (<em>void</em>* <dfn class="local col2 decl" id="102encoder" title='encoder' data-type='void *' data-ref="102encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col3 decl" id="103GUIDs" title='GUIDs' data-type='GUID *' data-ref="103GUIDs">GUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col4 decl" id="104guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="104guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col5 decl" id="105GUIDCount" title='GUIDCount' data-type='uint32_t *' data-ref="105GUIDCount">GUIDCount</dfn>);</td></tr>
<tr><th id="3104">3104</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEPROFILEGUIDCOUNT" title='PNVENCGETENCODEPROFILEGUIDCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETENCODEPROFILEGUIDCOUNT">PNVENCGETENCODEPROFILEGUIDCOUNT</dfn>) (<em>void</em>* <dfn class="local col6 decl" id="106encoder" title='encoder' data-type='void *' data-ref="106encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col7 decl" id="107encodeGUID" title='encodeGUID' data-type='GUID' data-ref="107encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col8 decl" id="108encodeProfileGUIDCount" title='encodeProfileGUIDCount' data-type='uint32_t *' data-ref="108encodeProfileGUIDCount">encodeProfileGUIDCount</dfn>);</td></tr>
<tr><th id="3105">3105</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEPROFILEGUIDS" title='PNVENCGETENCODEPROFILEGUIDS' data-type='NVENCSTATUS (*)(void *, GUID, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEPROFILEGUIDS">PNVENCGETENCODEPROFILEGUIDS</dfn>)     (<em>void</em>* <dfn class="local col9 decl" id="109encoder" title='encoder' data-type='void *' data-ref="109encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col0 decl" id="110encodeGUID" title='encodeGUID' data-type='GUID' data-ref="110encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col1 decl" id="111profileGUIDs" title='profileGUIDs' data-type='GUID *' data-ref="111profileGUIDs">profileGUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col2 decl" id="112guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="112guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col3 decl" id="113GUIDCount" title='GUIDCount' data-type='uint32_t *' data-ref="113GUIDCount">GUIDCount</dfn>);</td></tr>
<tr><th id="3106">3106</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETINPUTFORMATCOUNT" title='PNVENCGETINPUTFORMATCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETINPUTFORMATCOUNT">PNVENCGETINPUTFORMATCOUNT</dfn>)       (<em>void</em>* <dfn class="local col4 decl" id="114encoder" title='encoder' data-type='void *' data-ref="114encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col5 decl" id="115encodeGUID" title='encodeGUID' data-type='GUID' data-ref="115encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col6 decl" id="116inputFmtCount" title='inputFmtCount' data-type='uint32_t *' data-ref="116inputFmtCount">inputFmtCount</dfn>);</td></tr>
<tr><th id="3107">3107</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETINPUTFORMATS" title='PNVENCGETINPUTFORMATS' data-type='NVENCSTATUS (*)(void *, GUID, NV_ENC_BUFFER_FORMAT *, uint32_t, uint32_t *)' data-ref="PNVENCGETINPUTFORMATS">PNVENCGETINPUTFORMATS</dfn>)           (<em>void</em>* <dfn class="local col7 decl" id="117encoder" title='encoder' data-type='void *' data-ref="117encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col8 decl" id="118encodeGUID" title='encodeGUID' data-type='GUID' data-ref="118encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#NV_ENC_BUFFER_FORMAT" title='NV_ENC_BUFFER_FORMAT' data-type='enum _NV_ENC_BUFFER_FORMAT' data-ref="NV_ENC_BUFFER_FORMAT">NV_ENC_BUFFER_FORMAT</a>* <dfn class="local col9 decl" id="119inputFmts" title='inputFmts' data-type='NV_ENC_BUFFER_FORMAT *' data-ref="119inputFmts">inputFmts</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col0 decl" id="120inputFmtArraySize" title='inputFmtArraySize' data-type='uint32_t' data-ref="120inputFmtArraySize">inputFmtArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col1 decl" id="121inputFmtCount" title='inputFmtCount' data-type='uint32_t *' data-ref="121inputFmtCount">inputFmtCount</dfn>);</td></tr>
<tr><th id="3108">3108</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODECAPS" title='PNVENCGETENCODECAPS' data-type='NVENCSTATUS (*)(void *, GUID, NV_ENC_CAPS_PARAM *, int *)' data-ref="PNVENCGETENCODECAPS">PNVENCGETENCODECAPS</dfn>)             (<em>void</em>* <dfn class="local col2 decl" id="122encoder" title='encoder' data-type='void *' data-ref="122encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col3 decl" id="123encodeGUID" title='encodeGUID' data-type='GUID' data-ref="123encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#NV_ENC_CAPS_PARAM" title='NV_ENC_CAPS_PARAM' data-type='struct _NV_ENC_CAPS_PARAM' data-ref="NV_ENC_CAPS_PARAM">NV_ENC_CAPS_PARAM</a>* <dfn class="local col4 decl" id="124capsParam" title='capsParam' data-type='NV_ENC_CAPS_PARAM *' data-ref="124capsParam">capsParam</dfn>, <em>int</em>* <dfn class="local col5 decl" id="125capsVal" title='capsVal' data-type='int *' data-ref="125capsVal">capsVal</dfn>);</td></tr>
<tr><th id="3109">3109</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEPRESETCOUNT" title='PNVENCGETENCODEPRESETCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETENCODEPRESETCOUNT">PNVENCGETENCODEPRESETCOUNT</dfn>)      (<em>void</em>* <dfn class="local col6 decl" id="126encoder" title='encoder' data-type='void *' data-ref="126encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col7 decl" id="127encodeGUID" title='encodeGUID' data-type='GUID' data-ref="127encodeGUID">encodeGUID</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col8 decl" id="128encodePresetGUIDCount" title='encodePresetGUIDCount' data-type='uint32_t *' data-ref="128encodePresetGUIDCount">encodePresetGUIDCount</dfn>);</td></tr>
<tr><th id="3110">3110</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEPRESETGUIDS" title='PNVENCGETENCODEPRESETGUIDS' data-type='NVENCSTATUS (*)(void *, GUID, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEPRESETGUIDS">PNVENCGETENCODEPRESETGUIDS</dfn>)      (<em>void</em>* <dfn class="local col9 decl" id="129encoder" title='encoder' data-type='void *' data-ref="129encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col0 decl" id="130encodeGUID" title='encodeGUID' data-type='GUID' data-ref="130encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>* <dfn class="local col1 decl" id="131presetGUIDs" title='presetGUIDs' data-type='GUID *' data-ref="131presetGUIDs">presetGUIDs</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col2 decl" id="132guidArraySize" title='guidArraySize' data-type='uint32_t' data-ref="132guidArraySize">guidArraySize</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>* <dfn class="local col3 decl" id="133encodePresetGUIDCount" title='encodePresetGUIDCount' data-type='uint32_t *' data-ref="133encodePresetGUIDCount">encodePresetGUIDCount</dfn>);</td></tr>
<tr><th id="3111">3111</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODEPRESETCONFIG" title='PNVENCGETENCODEPRESETCONFIG' data-type='NVENCSTATUS (*)(void *, GUID, GUID, NV_ENC_PRESET_CONFIG *)' data-ref="PNVENCGETENCODEPRESETCONFIG">PNVENCGETENCODEPRESETCONFIG</dfn>)     (<em>void</em>* <dfn class="local col4 decl" id="134encoder" title='encoder' data-type='void *' data-ref="134encoder">encoder</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a> <dfn class="local col5 decl" id="135encodeGUID" title='encodeGUID' data-type='GUID' data-ref="135encodeGUID">encodeGUID</dfn>, <a class="typedef" href="#GUID" title='GUID' data-type='struct GUID' data-ref="GUID">GUID</a>  <dfn class="local col6 decl" id="136presetGUID" title='presetGUID' data-type='GUID' data-ref="136presetGUID">presetGUID</dfn>, <a class="typedef" href="#NV_ENC_PRESET_CONFIG" title='NV_ENC_PRESET_CONFIG' data-type='struct _NV_ENC_PRESET_CONFIG' data-ref="NV_ENC_PRESET_CONFIG">NV_ENC_PRESET_CONFIG</a>* <dfn class="local col7 decl" id="137presetConfig" title='presetConfig' data-type='NV_ENC_PRESET_CONFIG *' data-ref="137presetConfig">presetConfig</dfn>);</td></tr>
<tr><th id="3112">3112</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCINITIALIZEENCODER" title='PNVENCINITIALIZEENCODER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INITIALIZE_PARAMS *)' data-ref="PNVENCINITIALIZEENCODER">PNVENCINITIALIZEENCODER</dfn>)         (<em>void</em>* <dfn class="local col8 decl" id="138encoder" title='encoder' data-type='void *' data-ref="138encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INITIALIZE_PARAMS" title='NV_ENC_INITIALIZE_PARAMS' data-type='struct _NV_ENC_INITIALIZE_PARAMS' data-ref="NV_ENC_INITIALIZE_PARAMS">NV_ENC_INITIALIZE_PARAMS</a>* <dfn class="local col9 decl" id="139createEncodeParams" title='createEncodeParams' data-type='NV_ENC_INITIALIZE_PARAMS *' data-ref="139createEncodeParams">createEncodeParams</dfn>);</td></tr>
<tr><th id="3113">3113</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCCREATEINPUTBUFFER" title='PNVENCCREATEINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_INPUT_BUFFER *)' data-ref="PNVENCCREATEINPUTBUFFER">PNVENCCREATEINPUTBUFFER</dfn>)         (<em>void</em>* <dfn class="local col0 decl" id="140encoder" title='encoder' data-type='void *' data-ref="140encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_INPUT_BUFFER" title='NV_ENC_CREATE_INPUT_BUFFER' data-type='struct _NV_ENC_CREATE_INPUT_BUFFER' data-ref="NV_ENC_CREATE_INPUT_BUFFER">NV_ENC_CREATE_INPUT_BUFFER</a>* <dfn class="local col1 decl" id="141createInputBufferParams" title='createInputBufferParams' data-type='NV_ENC_CREATE_INPUT_BUFFER *' data-ref="141createInputBufferParams">createInputBufferParams</dfn>);</td></tr>
<tr><th id="3114">3114</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCDESTROYINPUTBUFFER" title='PNVENCDESTROYINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCDESTROYINPUTBUFFER">PNVENCDESTROYINPUTBUFFER</dfn>)        (<em>void</em>* <dfn class="local col2 decl" id="142encoder" title='encoder' data-type='void *' data-ref="142encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col3 decl" id="143inputBuffer" title='inputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="143inputBuffer">inputBuffer</dfn>);</td></tr>
<tr><th id="3115">3115</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCCREATEBITSTREAMBUFFER" title='PNVENCCREATEBITSTREAMBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_BITSTREAM_BUFFER *)' data-ref="PNVENCCREATEBITSTREAMBUFFER">PNVENCCREATEBITSTREAMBUFFER</dfn>)     (<em>void</em>* <dfn class="local col4 decl" id="144encoder" title='encoder' data-type='void *' data-ref="144encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_BITSTREAM_BUFFER" title='NV_ENC_CREATE_BITSTREAM_BUFFER' data-type='struct _NV_ENC_CREATE_BITSTREAM_BUFFER' data-ref="NV_ENC_CREATE_BITSTREAM_BUFFER">NV_ENC_CREATE_BITSTREAM_BUFFER</a>* <dfn class="local col5 decl" id="145createBitstreamBufferParams" title='createBitstreamBufferParams' data-type='NV_ENC_CREATE_BITSTREAM_BUFFER *' data-ref="145createBitstreamBufferParams">createBitstreamBufferParams</dfn>);</td></tr>
<tr><th id="3116">3116</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCDESTROYBITSTREAMBUFFER" title='PNVENCDESTROYBITSTREAMBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCDESTROYBITSTREAMBUFFER">PNVENCDESTROYBITSTREAMBUFFER</dfn>)    (<em>void</em>* <dfn class="local col6 decl" id="146encoder" title='encoder' data-type='void *' data-ref="146encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col7 decl" id="147bitstreamBuffer" title='bitstreamBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="147bitstreamBuffer">bitstreamBuffer</dfn>);</td></tr>
<tr><th id="3117">3117</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCENCODEPICTURE" title='PNVENCENCODEPICTURE' data-type='NVENCSTATUS (*)(void *, NV_ENC_PIC_PARAMS *)' data-ref="PNVENCENCODEPICTURE">PNVENCENCODEPICTURE</dfn>)             (<em>void</em>* <dfn class="local col8 decl" id="148encoder" title='encoder' data-type='void *' data-ref="148encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_PIC_PARAMS" title='NV_ENC_PIC_PARAMS' data-type='struct _NV_ENC_PIC_PARAMS' data-ref="NV_ENC_PIC_PARAMS">NV_ENC_PIC_PARAMS</a>* <dfn class="local col9 decl" id="149encodePicParams" title='encodePicParams' data-type='NV_ENC_PIC_PARAMS *' data-ref="149encodePicParams">encodePicParams</dfn>);</td></tr>
<tr><th id="3118">3118</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCLOCKBITSTREAM" title='PNVENCLOCKBITSTREAM' data-type='NVENCSTATUS (*)(void *, NV_ENC_LOCK_BITSTREAM *)' data-ref="PNVENCLOCKBITSTREAM">PNVENCLOCKBITSTREAM</dfn>)             (<em>void</em>* <dfn class="local col0 decl" id="150encoder" title='encoder' data-type='void *' data-ref="150encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_LOCK_BITSTREAM" title='NV_ENC_LOCK_BITSTREAM' data-type='struct _NV_ENC_LOCK_BITSTREAM' data-ref="NV_ENC_LOCK_BITSTREAM">NV_ENC_LOCK_BITSTREAM</a>* <dfn class="local col1 decl" id="151lockBitstreamBufferParams" title='lockBitstreamBufferParams' data-type='NV_ENC_LOCK_BITSTREAM *' data-ref="151lockBitstreamBufferParams">lockBitstreamBufferParams</dfn>);</td></tr>
<tr><th id="3119">3119</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCUNLOCKBITSTREAM" title='PNVENCUNLOCKBITSTREAM' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCUNLOCKBITSTREAM">PNVENCUNLOCKBITSTREAM</dfn>)           (<em>void</em>* <dfn class="local col2 decl" id="152encoder" title='encoder' data-type='void *' data-ref="152encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col3 decl" id="153bitstreamBuffer" title='bitstreamBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="153bitstreamBuffer">bitstreamBuffer</dfn>);</td></tr>
<tr><th id="3120">3120</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCLOCKINPUTBUFFER" title='PNVENCLOCKINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_LOCK_INPUT_BUFFER *)' data-ref="PNVENCLOCKINPUTBUFFER">PNVENCLOCKINPUTBUFFER</dfn>)           (<em>void</em>* <dfn class="local col4 decl" id="154encoder" title='encoder' data-type='void *' data-ref="154encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_LOCK_INPUT_BUFFER" title='NV_ENC_LOCK_INPUT_BUFFER' data-type='struct _NV_ENC_LOCK_INPUT_BUFFER' data-ref="NV_ENC_LOCK_INPUT_BUFFER">NV_ENC_LOCK_INPUT_BUFFER</a>* <dfn class="local col5 decl" id="155lockInputBufferParams" title='lockInputBufferParams' data-type='NV_ENC_LOCK_INPUT_BUFFER *' data-ref="155lockInputBufferParams">lockInputBufferParams</dfn>);</td></tr>
<tr><th id="3121">3121</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCUNLOCKINPUTBUFFER" title='PNVENCUNLOCKINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCUNLOCKINPUTBUFFER">PNVENCUNLOCKINPUTBUFFER</dfn>)         (<em>void</em>* <dfn class="local col6 decl" id="156encoder" title='encoder' data-type='void *' data-ref="156encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col7 decl" id="157inputBuffer" title='inputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="157inputBuffer">inputBuffer</dfn>);</td></tr>
<tr><th id="3122">3122</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETENCODESTATS" title='PNVENCGETENCODESTATS' data-type='NVENCSTATUS (*)(void *, NV_ENC_STAT *)' data-ref="PNVENCGETENCODESTATS">PNVENCGETENCODESTATS</dfn>)            (<em>void</em>* <dfn class="local col8 decl" id="158encoder" title='encoder' data-type='void *' data-ref="158encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_STAT" title='NV_ENC_STAT' data-type='struct _NV_ENC_STAT' data-ref="NV_ENC_STAT">NV_ENC_STAT</a>* <dfn class="local col9 decl" id="159encodeStats" title='encodeStats' data-type='NV_ENC_STAT *' data-ref="159encodeStats">encodeStats</dfn>);</td></tr>
<tr><th id="3123">3123</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCGETSEQUENCEPARAMS" title='PNVENCGETSEQUENCEPARAMS' data-type='NVENCSTATUS (*)(void *, NV_ENC_SEQUENCE_PARAM_PAYLOAD *)' data-ref="PNVENCGETSEQUENCEPARAMS">PNVENCGETSEQUENCEPARAMS</dfn>)         (<em>void</em>* <dfn class="local col0 decl" id="160encoder" title='encoder' data-type='void *' data-ref="160encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_SEQUENCE_PARAM_PAYLOAD" title='NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-type='struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD' data-ref="NV_ENC_SEQUENCE_PARAM_PAYLOAD">NV_ENC_SEQUENCE_PARAM_PAYLOAD</a>* <dfn class="local col1 decl" id="161sequenceParamPayload" title='sequenceParamPayload' data-type='NV_ENC_SEQUENCE_PARAM_PAYLOAD *' data-ref="161sequenceParamPayload">sequenceParamPayload</dfn>);</td></tr>
<tr><th id="3124">3124</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCREGISTERASYNCEVENT" title='PNVENCREGISTERASYNCEVENT' data-type='NVENCSTATUS (*)(void *, NV_ENC_EVENT_PARAMS *)' data-ref="PNVENCREGISTERASYNCEVENT">PNVENCREGISTERASYNCEVENT</dfn>)        (<em>void</em>* <dfn class="local col2 decl" id="162encoder" title='encoder' data-type='void *' data-ref="162encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_EVENT_PARAMS" title='NV_ENC_EVENT_PARAMS' data-type='struct _NV_ENC_EVENT_PARAMS' data-ref="NV_ENC_EVENT_PARAMS">NV_ENC_EVENT_PARAMS</a>* <dfn class="local col3 decl" id="163eventParams" title='eventParams' data-type='NV_ENC_EVENT_PARAMS *' data-ref="163eventParams">eventParams</dfn>);</td></tr>
<tr><th id="3125">3125</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCUNREGISTERASYNCEVENT" title='PNVENCUNREGISTERASYNCEVENT' data-type='NVENCSTATUS (*)(void *, NV_ENC_EVENT_PARAMS *)' data-ref="PNVENCUNREGISTERASYNCEVENT">PNVENCUNREGISTERASYNCEVENT</dfn>)      (<em>void</em>* <dfn class="local col4 decl" id="164encoder" title='encoder' data-type='void *' data-ref="164encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_EVENT_PARAMS" title='NV_ENC_EVENT_PARAMS' data-type='struct _NV_ENC_EVENT_PARAMS' data-ref="NV_ENC_EVENT_PARAMS">NV_ENC_EVENT_PARAMS</a>* <dfn class="local col5 decl" id="165eventParams" title='eventParams' data-type='NV_ENC_EVENT_PARAMS *' data-ref="165eventParams">eventParams</dfn>);</td></tr>
<tr><th id="3126">3126</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCMAPINPUTRESOURCE" title='PNVENCMAPINPUTRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_MAP_INPUT_RESOURCE *)' data-ref="PNVENCMAPINPUTRESOURCE">PNVENCMAPINPUTRESOURCE</dfn>)          (<em>void</em>* <dfn class="local col6 decl" id="166encoder" title='encoder' data-type='void *' data-ref="166encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_MAP_INPUT_RESOURCE" title='NV_ENC_MAP_INPUT_RESOURCE' data-type='struct _NV_ENC_MAP_INPUT_RESOURCE' data-ref="NV_ENC_MAP_INPUT_RESOURCE">NV_ENC_MAP_INPUT_RESOURCE</a>* <dfn class="local col7 decl" id="167mapInputResParams" title='mapInputResParams' data-type='NV_ENC_MAP_INPUT_RESOURCE *' data-ref="167mapInputResParams">mapInputResParams</dfn>);</td></tr>
<tr><th id="3127">3127</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCUNMAPINPUTRESOURCE" title='PNVENCUNMAPINPUTRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCUNMAPINPUTRESOURCE">PNVENCUNMAPINPUTRESOURCE</dfn>)        (<em>void</em>* <dfn class="local col8 decl" id="168encoder" title='encoder' data-type='void *' data-ref="168encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_INPUT_PTR" title='NV_ENC_INPUT_PTR' data-type='void *' data-ref="NV_ENC_INPUT_PTR">NV_ENC_INPUT_PTR</a> <dfn class="local col9 decl" id="169mappedInputBuffer" title='mappedInputBuffer' data-type='NV_ENC_INPUT_PTR' data-ref="169mappedInputBuffer">mappedInputBuffer</dfn>);</td></tr>
<tr><th id="3128">3128</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCDESTROYENCODER" title='PNVENCDESTROYENCODER' data-type='NVENCSTATUS (*)(void *)' data-ref="PNVENCDESTROYENCODER">PNVENCDESTROYENCODER</dfn>)            (<em>void</em>* <dfn class="local col0 decl" id="170encoder" title='encoder' data-type='void *' data-ref="170encoder">encoder</dfn>);</td></tr>
<tr><th id="3129">3129</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCINVALIDATEREFFRAMES" title='PNVENCINVALIDATEREFFRAMES' data-type='NVENCSTATUS (*)(void *, uint64_t)' data-ref="PNVENCINVALIDATEREFFRAMES">PNVENCINVALIDATEREFFRAMES</dfn>)       (<em>void</em>* <dfn class="local col1 decl" id="171encoder" title='encoder' data-type='void *' data-ref="171encoder">encoder</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="local col2 decl" id="172invalidRefFrameTimeStamp" title='invalidRefFrameTimeStamp' data-type='uint64_t' data-ref="172invalidRefFrameTimeStamp">invalidRefFrameTimeStamp</dfn>);</td></tr>
<tr><th id="3130">3130</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCOPENENCODESESSIONEX" title='PNVENCOPENENCODESESSIONEX' data-type='NVENCSTATUS (*)(NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *, void **)' data-ref="PNVENCOPENENCODESESSIONEX">PNVENCOPENENCODESESSIONEX</dfn>)       (<a class="typedef" href="#NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS" title='NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS' data-type='struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS' data-ref="NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS">NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS</a> *<dfn class="local col3 decl" id="173openSessionExParams" title='openSessionExParams' data-type='NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *' data-ref="173openSessionExParams">openSessionExParams</dfn>, <em>void</em>** <dfn class="local col4 decl" id="174encoder" title='encoder' data-type='void **' data-ref="174encoder">encoder</dfn>);</td></tr>
<tr><th id="3131">3131</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCREGISTERRESOURCE" title='PNVENCREGISTERRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_REGISTER_RESOURCE *)' data-ref="PNVENCREGISTERRESOURCE">PNVENCREGISTERRESOURCE</dfn>)          (<em>void</em>* <dfn class="local col5 decl" id="175encoder" title='encoder' data-type='void *' data-ref="175encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_REGISTER_RESOURCE" title='NV_ENC_REGISTER_RESOURCE' data-type='struct _NV_ENC_REGISTER_RESOURCE' data-ref="NV_ENC_REGISTER_RESOURCE">NV_ENC_REGISTER_RESOURCE</a>* <dfn class="local col6 decl" id="176registerResParams" title='registerResParams' data-type='NV_ENC_REGISTER_RESOURCE *' data-ref="176registerResParams">registerResParams</dfn>);</td></tr>
<tr><th id="3132">3132</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCUNREGISTERRESOURCE" title='PNVENCUNREGISTERRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_REGISTERED_PTR)' data-ref="PNVENCUNREGISTERRESOURCE">PNVENCUNREGISTERRESOURCE</dfn>)        (<em>void</em>* <dfn class="local col7 decl" id="177encoder" title='encoder' data-type='void *' data-ref="177encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_REGISTERED_PTR" title='NV_ENC_REGISTERED_PTR' data-type='void *' data-ref="NV_ENC_REGISTERED_PTR">NV_ENC_REGISTERED_PTR</a> <dfn class="local col8 decl" id="178registeredRes" title='registeredRes' data-type='NV_ENC_REGISTERED_PTR' data-ref="178registeredRes">registeredRes</dfn>);</td></tr>
<tr><th id="3133">3133</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCRECONFIGUREENCODER" title='PNVENCRECONFIGUREENCODER' data-type='NVENCSTATUS (*)(void *, NV_ENC_RECONFIGURE_PARAMS *)' data-ref="PNVENCRECONFIGUREENCODER">PNVENCRECONFIGUREENCODER</dfn>)        (<em>void</em>* <dfn class="local col9 decl" id="179encoder" title='encoder' data-type='void *' data-ref="179encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_RECONFIGURE_PARAMS" title='NV_ENC_RECONFIGURE_PARAMS' data-type='struct _NV_ENC_RECONFIGURE_PARAMS' data-ref="NV_ENC_RECONFIGURE_PARAMS">NV_ENC_RECONFIGURE_PARAMS</a>* <dfn class="local col0 decl" id="180reInitEncodeParams" title='reInitEncodeParams' data-type='NV_ENC_RECONFIGURE_PARAMS *' data-ref="180reInitEncodeParams">reInitEncodeParams</dfn>);</td></tr>
<tr><th id="3134">3134</th><td></td></tr>
<tr><th id="3135">3135</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCCREATEMVBUFFER" title='PNVENCCREATEMVBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_MV_BUFFER *)' data-ref="PNVENCCREATEMVBUFFER">PNVENCCREATEMVBUFFER</dfn>)            (<em>void</em>* <dfn class="local col1 decl" id="181encoder" title='encoder' data-type='void *' data-ref="181encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_CREATE_MV_BUFFER" title='NV_ENC_CREATE_MV_BUFFER' data-type='struct _NV_ENC_CREATE_MV_BUFFER' data-ref="NV_ENC_CREATE_MV_BUFFER">NV_ENC_CREATE_MV_BUFFER</a>* <dfn class="local col2 decl" id="182createMVBufferParams" title='createMVBufferParams' data-type='NV_ENC_CREATE_MV_BUFFER *' data-ref="182createMVBufferParams">createMVBufferParams</dfn>);</td></tr>
<tr><th id="3136">3136</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCDESTROYMVBUFFER" title='PNVENCDESTROYMVBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCDESTROYMVBUFFER">PNVENCDESTROYMVBUFFER</dfn>)           (<em>void</em>* <dfn class="local col3 decl" id="183encoder" title='encoder' data-type='void *' data-ref="183encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_OUTPUT_PTR" title='NV_ENC_OUTPUT_PTR' data-type='void *' data-ref="NV_ENC_OUTPUT_PTR">NV_ENC_OUTPUT_PTR</a> <dfn class="local col4 decl" id="184mvBuffer" title='mvBuffer' data-type='NV_ENC_OUTPUT_PTR' data-ref="184mvBuffer">mvBuffer</dfn>);</td></tr>
<tr><th id="3137">3137</th><td><b>typedef</b> <a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> (<a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a>* <dfn class="typedef" id="PNVENCRUNMOTIONESTIMATIONONLY" title='PNVENCRUNMOTIONESTIMATIONONLY' data-type='NVENCSTATUS (*)(void *, NV_ENC_MEONLY_PARAMS *)' data-ref="PNVENCRUNMOTIONESTIMATIONONLY">PNVENCRUNMOTIONESTIMATIONONLY</dfn>)   (<em>void</em>* <dfn class="local col5 decl" id="185encoder" title='encoder' data-type='void *' data-ref="185encoder">encoder</dfn>, <a class="typedef" href="#NV_ENC_MEONLY_PARAMS" title='NV_ENC_MEONLY_PARAMS' data-type='struct _NV_ENC_MEONLY_PARAMS' data-ref="NV_ENC_MEONLY_PARAMS">NV_ENC_MEONLY_PARAMS</a>* <dfn class="local col6 decl" id="186meOnlyParams" title='meOnlyParams' data-type='NV_ENC_MEONLY_PARAMS *' data-ref="186meOnlyParams">meOnlyParams</dfn>);</td></tr>
<tr><th id="3138">3138</th><td></td></tr>
<tr><th id="3139">3139</th><td></td></tr>
<tr><th id="3140">3140</th><td><i class="doc">///<span class="command"> \endcond</span></i></td></tr>
<tr><th id="3141">3141</th><td></td></tr>
<tr><th id="3142">3142</th><td></td></tr>
<tr><th id="3143">3143</th><td><i class="doc">/** @} */</i> <i>/* END ENCODE_FUNC */</i></td></tr>
<tr><th id="3144">3144</th><td></td></tr>
<tr><th id="3145">3145</th><td><i class="doc">/**</i></td></tr>
<tr><th id="3146">3146</th><td><i class="doc"> * <span class="command">\ingroup</span> <span class="verb">ENCODER_STRUCTURE</span></i></td></tr>
<tr><th id="3147">3147</th><td><i class="doc"> * NV_ENCODE_API_FUNCTION_LIST</i></td></tr>
<tr><th id="3148">3148</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3149">3149</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_NV_ENCODE_API_FUNCTION_LIST" title='_NV_ENCODE_API_FUNCTION_LIST' data-ref="_NV_ENCODE_API_FUNCTION_LIST"><a class="type" href="#_NV_ENCODE_API_FUNCTION_LIST" title='_NV_ENCODE_API_FUNCTION_LIST' data-ref="_NV_ENCODE_API_FUNCTION_LIST">_NV_ENCODE_API_FUNCTION_LIST</a></dfn></td></tr>
<tr><th id="3150">3150</th><td>{</td></tr>
<tr><th id="3151">3151</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::version" title='_NV_ENCODE_API_FUNCTION_LIST::version' data-ref="_NV_ENCODE_API_FUNCTION_LIST::version">version</dfn>;                           <i class="doc">/**&lt; [in]: Client should pass NV_ENCODE_API_FUNCTION_LIST_VER.                               */</i></td></tr>
<tr><th id="3152">3152</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a>                        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::reserved" title='_NV_ENCODE_API_FUNCTION_LIST::reserved' data-ref="_NV_ENCODE_API_FUNCTION_LIST::reserved">reserved</dfn>;                          <i class="doc">/**&lt; [in]: Reserved and should be set to 0.                                                  */</i></td></tr>
<tr><th id="3153">3153</th><td>    <a class="typedef" href="#PNVENCOPENENCODESESSION" title='PNVENCOPENENCODESESSION' data-type='NVENCSTATUS (*)(void *, uint32_t, void **)' data-ref="PNVENCOPENENCODESESSION">PNVENCOPENENCODESESSION</a>         <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSession" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSession' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSession">nvEncOpenEncodeSession</dfn>;            <i class="doc">/**&lt; [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer.        */</i></td></tr>
<tr><th id="3154">3154</th><td>    <a class="typedef" href="#PNVENCGETENCODEGUIDCOUNT" title='PNVENCGETENCODEGUIDCOUNT' data-type='NVENCSTATUS (*)(void *, uint32_t *)' data-ref="PNVENCGETENCODEGUIDCOUNT">PNVENCGETENCODEGUIDCOUNT</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDCount" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDCount' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDCount">nvEncGetEncodeGUIDCount</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeGUIDCount() API through this pointer.       */</i></td></tr>
<tr><th id="3155">3155</th><td>    <a class="typedef" href="#PNVENCGETENCODEPRESETCOUNT" title='PNVENCGETENCODEPRESETCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETENCODEPRESETCOUNT">PNVENCGETENCODEPRESETCOUNT</a>      <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDCount" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDCount' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDCount">nvEncGetEncodeProfileGUIDCount</dfn>;    <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeProfileGUIDCount() API through this pointer.*/</i></td></tr>
<tr><th id="3156">3156</th><td>    <a class="typedef" href="#PNVENCGETENCODEPRESETGUIDS" title='PNVENCGETENCODEPRESETGUIDS' data-type='NVENCSTATUS (*)(void *, GUID, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEPRESETGUIDS">PNVENCGETENCODEPRESETGUIDS</a>      <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDs" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDs' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeProfileGUIDs">nvEncGetEncodeProfileGUIDs</dfn>;        <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeProfileGUIDs() API through this pointer.    */</i></td></tr>
<tr><th id="3157">3157</th><td>    <a class="typedef" href="#PNVENCGETENCODEGUIDS" title='PNVENCGETENCODEGUIDS' data-type='NVENCSTATUS (*)(void *, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEGUIDS">PNVENCGETENCODEGUIDS</a>            <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDs" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDs' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeGUIDs">nvEncGetEncodeGUIDs</dfn>;               <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeGUIDs() API through this pointer.           */</i></td></tr>
<tr><th id="3158">3158</th><td>    <a class="typedef" href="#PNVENCGETINPUTFORMATCOUNT" title='PNVENCGETINPUTFORMATCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETINPUTFORMATCOUNT">PNVENCGETINPUTFORMATCOUNT</a>       <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormatCount" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormatCount' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormatCount">nvEncGetInputFormatCount</dfn>;          <i class="doc">/**&lt; [out]: Client should access ::NvEncGetInputFormatCount() API through this pointer.      */</i></td></tr>
<tr><th id="3159">3159</th><td>    <a class="typedef" href="#PNVENCGETINPUTFORMATS" title='PNVENCGETINPUTFORMATS' data-type='NVENCSTATUS (*)(void *, GUID, NV_ENC_BUFFER_FORMAT *, uint32_t, uint32_t *)' data-ref="PNVENCGETINPUTFORMATS">PNVENCGETINPUTFORMATS</a>           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormats" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormats' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetInputFormats">nvEncGetInputFormats</dfn>;              <i class="doc">/**&lt; [out]: Client should access ::NvEncGetInputFormats() API through this pointer.          */</i></td></tr>
<tr><th id="3160">3160</th><td>    <a class="typedef" href="#PNVENCGETENCODECAPS" title='PNVENCGETENCODECAPS' data-type='NVENCSTATUS (*)(void *, GUID, NV_ENC_CAPS_PARAM *, int *)' data-ref="PNVENCGETENCODECAPS">PNVENCGETENCODECAPS</a>             <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeCaps" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeCaps' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeCaps">nvEncGetEncodeCaps</dfn>;                <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeCaps() API through this pointer.            */</i></td></tr>
<tr><th id="3161">3161</th><td>    <a class="typedef" href="#PNVENCGETENCODEPRESETCOUNT" title='PNVENCGETENCODEPRESETCOUNT' data-type='NVENCSTATUS (*)(void *, GUID, uint32_t *)' data-ref="PNVENCGETENCODEPRESETCOUNT">PNVENCGETENCODEPRESETCOUNT</a>      <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetCount" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetCount' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetCount">nvEncGetEncodePresetCount</dfn>;         <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodePresetCount() API through this pointer.     */</i></td></tr>
<tr><th id="3162">3162</th><td>    <a class="typedef" href="#PNVENCGETENCODEPRESETGUIDS" title='PNVENCGETENCODEPRESETGUIDS' data-type='NVENCSTATUS (*)(void *, GUID, GUID *, uint32_t, uint32_t *)' data-ref="PNVENCGETENCODEPRESETGUIDS">PNVENCGETENCODEPRESETGUIDS</a>      <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetGUIDs" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetGUIDs' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetGUIDs">nvEncGetEncodePresetGUIDs</dfn>;         <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodePresetGUIDs() API through this pointer.     */</i></td></tr>
<tr><th id="3163">3163</th><td>    <a class="typedef" href="#PNVENCGETENCODEPRESETCONFIG" title='PNVENCGETENCODEPRESETCONFIG' data-type='NVENCSTATUS (*)(void *, GUID, GUID, NV_ENC_PRESET_CONFIG *)' data-ref="PNVENCGETENCODEPRESETCONFIG">PNVENCGETENCODEPRESETCONFIG</a>     <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetConfig" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetConfig' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodePresetConfig">nvEncGetEncodePresetConfig</dfn>;        <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodePresetConfig() API through this pointer.    */</i></td></tr>
<tr><th id="3164">3164</th><td>    <a class="typedef" href="#PNVENCINITIALIZEENCODER" title='PNVENCINITIALIZEENCODER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INITIALIZE_PARAMS *)' data-ref="PNVENCINITIALIZEENCODER">PNVENCINITIALIZEENCODER</a>         <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncInitializeEncoder" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncInitializeEncoder' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncInitializeEncoder">nvEncInitializeEncoder</dfn>;            <i class="doc">/**&lt; [out]: Client should access ::NvEncInitializeEncoder() API through this pointer.        */</i></td></tr>
<tr><th id="3165">3165</th><td>    <a class="typedef" href="#PNVENCCREATEINPUTBUFFER" title='PNVENCCREATEINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_INPUT_BUFFER *)' data-ref="PNVENCCREATEINPUTBUFFER">PNVENCCREATEINPUTBUFFER</a>         <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateInputBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateInputBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateInputBuffer">nvEncCreateInputBuffer</dfn>;            <i class="doc">/**&lt; [out]: Client should access ::NvEncCreateInputBuffer() API through this pointer.        */</i></td></tr>
<tr><th id="3166">3166</th><td>    <a class="typedef" href="#PNVENCDESTROYINPUTBUFFER" title='PNVENCDESTROYINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCDESTROYINPUTBUFFER">PNVENCDESTROYINPUTBUFFER</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyInputBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyInputBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyInputBuffer">nvEncDestroyInputBuffer</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncDestroyInputBuffer() API through this pointer.       */</i></td></tr>
<tr><th id="3167">3167</th><td>    <a class="typedef" href="#PNVENCCREATEBITSTREAMBUFFER" title='PNVENCCREATEBITSTREAMBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_BITSTREAM_BUFFER *)' data-ref="PNVENCCREATEBITSTREAMBUFFER">PNVENCCREATEBITSTREAMBUFFER</a>     <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateBitstreamBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateBitstreamBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateBitstreamBuffer">nvEncCreateBitstreamBuffer</dfn>;        <i class="doc">/**&lt; [out]: Client should access ::NvEncCreateBitstreamBuffer() API through this pointer.    */</i></td></tr>
<tr><th id="3168">3168</th><td>    <a class="typedef" href="#PNVENCDESTROYBITSTREAMBUFFER" title='PNVENCDESTROYBITSTREAMBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCDESTROYBITSTREAMBUFFER">PNVENCDESTROYBITSTREAMBUFFER</a>    <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyBitstreamBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyBitstreamBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyBitstreamBuffer">nvEncDestroyBitstreamBuffer</dfn>;       <i class="doc">/**&lt; [out]: Client should access ::NvEncDestroyBitstreamBuffer() API through this pointer.   */</i></td></tr>
<tr><th id="3169">3169</th><td>    <a class="typedef" href="#PNVENCENCODEPICTURE" title='PNVENCENCODEPICTURE' data-type='NVENCSTATUS (*)(void *, NV_ENC_PIC_PARAMS *)' data-ref="PNVENCENCODEPICTURE">PNVENCENCODEPICTURE</a>             <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncEncodePicture" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncEncodePicture' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncEncodePicture">nvEncEncodePicture</dfn>;                <i class="doc">/**&lt; [out]: Client should access ::NvEncEncodePicture() API through this pointer.            */</i></td></tr>
<tr><th id="3170">3170</th><td>    <a class="typedef" href="#PNVENCLOCKBITSTREAM" title='PNVENCLOCKBITSTREAM' data-type='NVENCSTATUS (*)(void *, NV_ENC_LOCK_BITSTREAM *)' data-ref="PNVENCLOCKBITSTREAM">PNVENCLOCKBITSTREAM</a>             <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncLockBitstream" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncLockBitstream' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncLockBitstream">nvEncLockBitstream</dfn>;                <i class="doc">/**&lt; [out]: Client should access ::NvEncLockBitstream() API through this pointer.            */</i></td></tr>
<tr><th id="3171">3171</th><td>    <a class="typedef" href="#PNVENCUNLOCKBITSTREAM" title='PNVENCUNLOCKBITSTREAM' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCUNLOCKBITSTREAM">PNVENCUNLOCKBITSTREAM</a>           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockBitstream" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockBitstream' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockBitstream">nvEncUnlockBitstream</dfn>;              <i class="doc">/**&lt; [out]: Client should access ::NvEncUnlockBitstream() API through this pointer.          */</i></td></tr>
<tr><th id="3172">3172</th><td>    <a class="typedef" href="#PNVENCLOCKINPUTBUFFER" title='PNVENCLOCKINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_LOCK_INPUT_BUFFER *)' data-ref="PNVENCLOCKINPUTBUFFER">PNVENCLOCKINPUTBUFFER</a>           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncLockInputBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncLockInputBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncLockInputBuffer">nvEncLockInputBuffer</dfn>;              <i class="doc">/**&lt; [out]: Client should access ::NvEncLockInputBuffer() API through this pointer.          */</i></td></tr>
<tr><th id="3173">3173</th><td>    <a class="typedef" href="#PNVENCUNLOCKINPUTBUFFER" title='PNVENCUNLOCKINPUTBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCUNLOCKINPUTBUFFER">PNVENCUNLOCKINPUTBUFFER</a>         <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockInputBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockInputBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnlockInputBuffer">nvEncUnlockInputBuffer</dfn>;            <i class="doc">/**&lt; [out]: Client should access ::NvEncUnlockInputBuffer() API through this pointer.        */</i></td></tr>
<tr><th id="3174">3174</th><td>    <a class="typedef" href="#PNVENCGETENCODESTATS" title='PNVENCGETENCODESTATS' data-type='NVENCSTATUS (*)(void *, NV_ENC_STAT *)' data-ref="PNVENCGETENCODESTATS">PNVENCGETENCODESTATS</a>            <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeStats" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeStats' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetEncodeStats">nvEncGetEncodeStats</dfn>;               <i class="doc">/**&lt; [out]: Client should access ::NvEncGetEncodeStats() API through this pointer.           */</i></td></tr>
<tr><th id="3175">3175</th><td>    <a class="typedef" href="#PNVENCGETSEQUENCEPARAMS" title='PNVENCGETSEQUENCEPARAMS' data-type='NVENCSTATUS (*)(void *, NV_ENC_SEQUENCE_PARAM_PAYLOAD *)' data-ref="PNVENCGETSEQUENCEPARAMS">PNVENCGETSEQUENCEPARAMS</a>         <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetSequenceParams" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncGetSequenceParams' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncGetSequenceParams">nvEncGetSequenceParams</dfn>;            <i class="doc">/**&lt; [out]: Client should access ::NvEncGetSequenceParams() API through this pointer.        */</i></td></tr>
<tr><th id="3176">3176</th><td>    <a class="typedef" href="#PNVENCREGISTERASYNCEVENT" title='PNVENCREGISTERASYNCEVENT' data-type='NVENCSTATUS (*)(void *, NV_ENC_EVENT_PARAMS *)' data-ref="PNVENCREGISTERASYNCEVENT">PNVENCREGISTERASYNCEVENT</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterAsyncEvent" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterAsyncEvent' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterAsyncEvent">nvEncRegisterAsyncEvent</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncRegisterAsyncEvent() API through this pointer.       */</i></td></tr>
<tr><th id="3177">3177</th><td>    <a class="typedef" href="#PNVENCUNREGISTERASYNCEVENT" title='PNVENCUNREGISTERASYNCEVENT' data-type='NVENCSTATUS (*)(void *, NV_ENC_EVENT_PARAMS *)' data-ref="PNVENCUNREGISTERASYNCEVENT">PNVENCUNREGISTERASYNCEVENT</a>      <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterAsyncEvent" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterAsyncEvent' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterAsyncEvent">nvEncUnregisterAsyncEvent</dfn>;         <i class="doc">/**&lt; [out]: Client should access ::NvEncUnregisterAsyncEvent() API through this pointer.     */</i></td></tr>
<tr><th id="3178">3178</th><td>    <a class="typedef" href="#PNVENCMAPINPUTRESOURCE" title='PNVENCMAPINPUTRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_MAP_INPUT_RESOURCE *)' data-ref="PNVENCMAPINPUTRESOURCE">PNVENCMAPINPUTRESOURCE</a>          <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncMapInputResource" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncMapInputResource' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncMapInputResource">nvEncMapInputResource</dfn>;             <i class="doc">/**&lt; [out]: Client should access ::NvEncMapInputResource() API through this pointer.         */</i></td></tr>
<tr><th id="3179">3179</th><td>    <a class="typedef" href="#PNVENCUNMAPINPUTRESOURCE" title='PNVENCUNMAPINPUTRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_INPUT_PTR)' data-ref="PNVENCUNMAPINPUTRESOURCE">PNVENCUNMAPINPUTRESOURCE</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnmapInputResource" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncUnmapInputResource' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnmapInputResource">nvEncUnmapInputResource</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncUnmapInputResource() API through this pointer.       */</i></td></tr>
<tr><th id="3180">3180</th><td>    <a class="typedef" href="#PNVENCDESTROYENCODER" title='PNVENCDESTROYENCODER' data-type='NVENCSTATUS (*)(void *)' data-ref="PNVENCDESTROYENCODER">PNVENCDESTROYENCODER</a>            <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyEncoder" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyEncoder' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyEncoder">nvEncDestroyEncoder</dfn>;               <i class="doc">/**&lt; [out]: Client should access ::NvEncDestroyEncoder() API through this pointer.           */</i></td></tr>
<tr><th id="3181">3181</th><td>    <a class="typedef" href="#PNVENCINVALIDATEREFFRAMES" title='PNVENCINVALIDATEREFFRAMES' data-type='NVENCSTATUS (*)(void *, uint64_t)' data-ref="PNVENCINVALIDATEREFFRAMES">PNVENCINVALIDATEREFFRAMES</a>       <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncInvalidateRefFrames" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncInvalidateRefFrames' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncInvalidateRefFrames">nvEncInvalidateRefFrames</dfn>;          <i class="doc">/**&lt; [out]: Client should access ::NvEncInvalidateRefFrames() API through this pointer.      */</i></td></tr>
<tr><th id="3182">3182</th><td>    <a class="typedef" href="#PNVENCOPENENCODESESSIONEX" title='PNVENCOPENENCODESESSIONEX' data-type='NVENCSTATUS (*)(NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS *, void **)' data-ref="PNVENCOPENENCODESESSIONEX">PNVENCOPENENCODESESSIONEX</a>       <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSessionEx" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSessionEx' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncOpenEncodeSessionEx">nvEncOpenEncodeSessionEx</dfn>;          <i class="doc">/**&lt; [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer.        */</i></td></tr>
<tr><th id="3183">3183</th><td>    <a class="typedef" href="#PNVENCREGISTERRESOURCE" title='PNVENCREGISTERRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_REGISTER_RESOURCE *)' data-ref="PNVENCREGISTERRESOURCE">PNVENCREGISTERRESOURCE</a>          <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterResource" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterResource' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncRegisterResource">nvEncRegisterResource</dfn>;             <i class="doc">/**&lt; [out]: Client should access ::NvEncRegisterResource() API through this pointer.         */</i></td></tr>
<tr><th id="3184">3184</th><td>    <a class="typedef" href="#PNVENCUNREGISTERRESOURCE" title='PNVENCUNREGISTERRESOURCE' data-type='NVENCSTATUS (*)(void *, NV_ENC_REGISTERED_PTR)' data-ref="PNVENCUNREGISTERRESOURCE">PNVENCUNREGISTERRESOURCE</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterResource" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterResource' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncUnregisterResource">nvEncUnregisterResource</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncUnregisterResource() API through this pointer.       */</i></td></tr>
<tr><th id="3185">3185</th><td>    <a class="typedef" href="#PNVENCRECONFIGUREENCODER" title='PNVENCRECONFIGUREENCODER' data-type='NVENCSTATUS (*)(void *, NV_ENC_RECONFIGURE_PARAMS *)' data-ref="PNVENCRECONFIGUREENCODER">PNVENCRECONFIGUREENCODER</a>        <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncReconfigureEncoder" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncReconfigureEncoder' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncReconfigureEncoder">nvEncReconfigureEncoder</dfn>;           <i class="doc">/**&lt; [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer.       */</i></td></tr>
<tr><th id="3186">3186</th><td>    <em>void</em>*                           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::reserved1" title='_NV_ENCODE_API_FUNCTION_LIST::reserved1' data-ref="_NV_ENCODE_API_FUNCTION_LIST::reserved1">reserved1</dfn>;</td></tr>
<tr><th id="3187">3187</th><td>    <a class="typedef" href="#PNVENCCREATEMVBUFFER" title='PNVENCCREATEMVBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_CREATE_MV_BUFFER *)' data-ref="PNVENCCREATEMVBUFFER">PNVENCCREATEMVBUFFER</a>            <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateMVBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateMVBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncCreateMVBuffer">nvEncCreateMVBuffer</dfn>;               <i class="doc">/**&lt; [out]: Client should access ::NvEncCreateMVBuffer API through this pointer.             */</i></td></tr>
<tr><th id="3188">3188</th><td>    <a class="typedef" href="#PNVENCDESTROYMVBUFFER" title='PNVENCDESTROYMVBUFFER' data-type='NVENCSTATUS (*)(void *, NV_ENC_OUTPUT_PTR)' data-ref="PNVENCDESTROYMVBUFFER">PNVENCDESTROYMVBUFFER</a>           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyMVBuffer" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyMVBuffer' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncDestroyMVBuffer">nvEncDestroyMVBuffer</dfn>;              <i class="doc">/**&lt; [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer.            */</i></td></tr>
<tr><th id="3189">3189</th><td>    <a class="typedef" href="#PNVENCRUNMOTIONESTIMATIONONLY" title='PNVENCRUNMOTIONESTIMATIONONLY' data-type='NVENCSTATUS (*)(void *, NV_ENC_MEONLY_PARAMS *)' data-ref="PNVENCRUNMOTIONESTIMATIONONLY">PNVENCRUNMOTIONESTIMATIONONLY</a>   <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::nvEncRunMotionEstimationOnly" title='_NV_ENCODE_API_FUNCTION_LIST::nvEncRunMotionEstimationOnly' data-ref="_NV_ENCODE_API_FUNCTION_LIST::nvEncRunMotionEstimationOnly">nvEncRunMotionEstimationOnly</dfn>;      <i class="doc">/**&lt; [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer.    */</i></td></tr>
<tr><th id="3190">3190</th><td>    <em>void</em>*                           <dfn class="decl" id="_NV_ENCODE_API_FUNCTION_LIST::reserved2" title='_NV_ENCODE_API_FUNCTION_LIST::reserved2' data-ref="_NV_ENCODE_API_FUNCTION_LIST::reserved2">reserved2</dfn>[<var>281</var>];                    <i class="doc">/**&lt; [in]:  Reserved and must be set to NULL                                                 */</i></td></tr>
<tr><th id="3191">3191</th><td>} <dfn class="typedef" id="NV_ENCODE_API_FUNCTION_LIST" title='NV_ENCODE_API_FUNCTION_LIST' data-type='struct _NV_ENCODE_API_FUNCTION_LIST' data-ref="NV_ENCODE_API_FUNCTION_LIST">NV_ENCODE_API_FUNCTION_LIST</dfn>;</td></tr>
<tr><th id="3192">3192</th><td></td></tr>
<tr><th id="3193">3193</th><td><i class="doc">/** Macro for constructing the version field of ::_NV_ENCODEAPI_FUNCTION_LIST. */</i></td></tr>
<tr><th id="3194">3194</th><td><u>#define <dfn class="macro" id="_M/NV_ENCODE_API_FUNCTION_LIST_VER" data-ref="_M/NV_ENCODE_API_FUNCTION_LIST_VER">NV_ENCODE_API_FUNCTION_LIST_VER</dfn> NVENCAPI_STRUCT_VERSION(2)</u></td></tr>
<tr><th id="3195">3195</th><td></td></tr>
<tr><th id="3196">3196</th><td><i>// NvEncodeAPICreateInstance</i></td></tr>
<tr><th id="3197">3197</th><td><i class="doc">/**</i></td></tr>
<tr><th id="3198">3198</th><td><i class="doc"> * <span class="command">\ingroup</span> <span class="verb">ENCODE_FUNC</span></i></td></tr>
<tr><th id="3199">3199</th><td><i class="doc"> * Entry Point to the NvEncodeAPI interface.</i></td></tr>
<tr><th id="3200">3200</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3201">3201</th><td><i class="doc"> * Creates an instance of the NvEncodeAPI interface, and populates the</i></td></tr>
<tr><th id="3202">3202</th><td><i class="doc"> * pFunctionList with function pointers to the API routines implemented by the</i></td></tr>
<tr><th id="3203">3203</th><td><i class="doc"> * NvEncodeAPI interface.</i></td></tr>
<tr><th id="3204">3204</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3205">3205</th><td><i class="doc"> * <span class="command">\param</span> [out] <span class="arg">functionList</span></i></td></tr>
<tr><th id="3206">3206</th><td><i class="doc"> *</i></td></tr>
<tr><th id="3207">3207</th><td><i class="doc"> * <span class="command">\return</span></i></td></tr>
<tr><th id="3208">3208</th><td><i class="doc"> * ::NV_ENC_SUCCESS</i></td></tr>
<tr><th id="3209">3209</th><td><i class="doc"> * ::NV_ENC_ERR_INVALID_PTR</i></td></tr>
<tr><th id="3210">3210</th><td><i class="doc"> */</i></td></tr>
<tr><th id="3211">3211</th><td><a class="typedef" href="#NVENCSTATUS" title='NVENCSTATUS' data-type='enum _NVENCSTATUS' data-ref="NVENCSTATUS">NVENCSTATUS</a> <a class="macro" href="#71" title="" data-ref="_M/NVENCAPI">NVENCAPI</a> <dfn class="decl" id="NvEncodeAPICreateInstance" title='NvEncodeAPICreateInstance' data-ref="NvEncodeAPICreateInstance">NvEncodeAPICreateInstance</dfn>(<a class="typedef" href="#NV_ENCODE_API_FUNCTION_LIST" title='NV_ENCODE_API_FUNCTION_LIST' data-type='struct _NV_ENCODE_API_FUNCTION_LIST' data-ref="NV_ENCODE_API_FUNCTION_LIST">NV_ENCODE_API_FUNCTION_LIST</a> *<dfn class="local col7 decl" id="187functionList" title='functionList' data-type='NV_ENCODE_API_FUNCTION_LIST *' data-ref="187functionList">functionList</dfn>);</td></tr>
<tr><th id="3212">3212</th><td></td></tr>
<tr><th id="3213">3213</th><td><u>#<span data-ppcond="3213">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="3214">3214</th><td>}</td></tr>
<tr><th id="3215">3215</th><td><u>#<span data-ppcond="3213">endif</span></u></td></tr>
<tr><th id="3216">3216</th><td></td></tr>
<tr><th id="3217">3217</th><td></td></tr>
<tr><th id="3218">3218</th><td><u>#<span data-ppcond="35">endif</span></u></td></tr>
<tr><th id="3219">3219</th><td></td></tr>
<tr><th id="3220">3220</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../libavcodec/nvenc.c.html'>ffmpeg/libavcodec/nvenc.c</a><br/>Generated on <em>2016-Oct-25</em> from project ffmpeg revision <em>3.0.git</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
