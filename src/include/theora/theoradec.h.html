<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>theoradec.h source code [include/theora/theoradec.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/theora/theoradec.h'; var root_path = '../..'; var data_path = '../../../data';</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>include</a>/<a href='./'>theora</a>/<a href='theoradec.h.html'>theoradec.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/********************************************************************</i></td></tr>
<tr><th id="2">2</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="3">3</th><td><i> * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *</i></td></tr>
<tr><th id="4">4</th><td><i> * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *</i></td></tr>
<tr><th id="5">5</th><td><i> * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *</i></td></tr>
<tr><th id="6">6</th><td><i> * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *</i></td></tr>
<tr><th id="7">7</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="8">8</th><td><i> * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2009                *</i></td></tr>
<tr><th id="9">9</th><td><i> * by the Xiph.Org Foundation <a href="http://www.xiph.org/">http://www.xiph.org/</a>                  *</i></td></tr>
<tr><th id="10">10</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="11">11</th><td><i> ********************************************************************</i></td></tr>
<tr><th id="12">12</th><td><i></i></td></tr>
<tr><th id="13">13</th><td><i>  function:</i></td></tr>
<tr><th id="14">14</th><td><i>  last mod: $Id: theora.h,v 1.8 2004/03/15 22:17:32 derf Exp $</i></td></tr>
<tr><th id="15">15</th><td><i></i></td></tr>
<tr><th id="16">16</th><td><i> ********************************************************************/</i></td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><i class="doc">/*<span class="command">*\file</span></i></td></tr>
<tr><th id="19">19</th><td><i class="doc"> * The <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span> C decoding API.*/</i></td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><u>#<span data-ppcond="21">if</span> !defined(<span class="macro" data-ref="_M/_O_THEORA_THEORADEC_H_">_O_THEORA_THEORADEC_H_</span>)</u></td></tr>
<tr><th id="22">22</th><td><u># define <dfn class="macro" id="_M/_O_THEORA_THEORADEC_H_" data-ref="_M/_O_THEORA_THEORADEC_H_">_O_THEORA_THEORADEC_H_</dfn> (1)</u></td></tr>
<tr><th id="23">23</th><td><u># include &lt;stddef.h&gt;</u></td></tr>
<tr><th id="24">24</th><td><u># include <a href="../ogg/ogg.h.html">&lt;ogg/ogg.h&gt;</a></u></td></tr>
<tr><th id="25">25</th><td><u># include <a href="codec.h.html">"codec.h"</a></u></td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td><u>#<span data-ppcond="27">if</span> defined(<span class="macro" data-ref="_M/__cplusplus">__cplusplus</span>)</u></td></tr>
<tr><th id="28">28</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="27">endif</span></u></td></tr>
<tr><th id="30">30</th><td></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td></td></tr>
<tr><th id="33">33</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">th_decode_ctl() codes</span></i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> *<span class="command"> \anchor</span> decctlcodes</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * These are the available request codes for th_decode_ctl().</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> * By convention, these are odd, to distinguish them from the</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> *  <span class="command">\ref</span> <span class="verb">encctlcodes "encoder control codes".</span></i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * Keep any experimental or vendor-specific values above<span class="command"> \c</span> <span class="arg">0x8000.</span>*/</i></td></tr>
<tr><th id="39">39</th><td><i>/*@{*/</i></td></tr>
<tr><th id="40">40</th><td><i class="doc">/**Gets the maximum post-processing level.</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> * The decoder supports a post-processing filter that can improve</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> * the appearance of the decoded images. This returns the highest</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> * level setting for this post-processor, corresponding to maximum</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> * improvement and computational expense.</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> *</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> int: The maximum post-processing level.</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT <span class="command"> \a</span> <span class="arg">_dec_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL <span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_GET_PPLEVEL_MAX" data-ref="_M/TH_DECCTL_GET_PPLEVEL_MAX">TH_DECCTL_GET_PPLEVEL_MAX</dfn> (1)</u></td></tr>
<tr><th id="51">51</th><td><i class="doc">/**Sets the post-processing level.</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> * By default, post-processing is disabled.</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> *</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> * Sets the level of post-processing to use when decoding the</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> * compressed stream. This must be a value between zero (off)</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> * and the maximum returned by TH_DECCTL_GET_PPLEVEL_MAX.</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> *</i></td></tr>
<tr><th id="58">58</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> int: The new post-processing level.</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> *                      0 to disable; larger values use more CPU.</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT <span class="command"> \a</span> <span class="arg">_dec_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="61">61</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL <span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>, or the</i></td></tr>
<tr><th id="62">62</th><td><i class="doc"> *                     post-processing level is out of bounds.</i></td></tr>
<tr><th id="63">63</th><td><i class="doc"> *                    The maximum post-processing level may be</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> *                     implementation-specific, and can be obtained via</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> *                     #TH_DECCTL_GET_PPLEVEL_MAX.</i></td></tr>
<tr><th id="66">66</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="67">67</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_PPLEVEL" data-ref="_M/TH_DECCTL_SET_PPLEVEL">TH_DECCTL_SET_PPLEVEL</dfn> (3)</u></td></tr>
<tr><th id="68">68</th><td><i class="doc">/**Sets the granule position.</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> * Call this after a seek, before decoding the first frame, to ensure that the</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> *  proper granule position is returned for all subsequent frames.</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> * If you track timestamps yourself and do not use the granule position</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> *  returned by the decoder, then you need not call this function.</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> *</i></td></tr>
<tr><th id="74">74</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>ogg_int64_t<span class="tag">&lt;/tt&gt;</span>: The granule position of the next</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> *                  frame.</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT <span class="command"> \a</span> <span class="arg">_dec_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL <span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(ogg_int64_t)<span class="tag">&lt;/tt&gt;</span>, or the</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> *                     granule position is negative.*/</i></td></tr>
<tr><th id="79">79</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_GRANPOS" data-ref="_M/TH_DECCTL_SET_GRANPOS">TH_DECCTL_SET_GRANPOS</dfn> (5)</u></td></tr>
<tr><th id="80">80</th><td><i class="doc">/**Sets the striped decode callback function.</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> * If set, this function will be called as each piece of a frame is fully</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> *  decoded in th_decode_packetin().</i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> * You can pass in a #th_stripe_callback with</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> *  th_stripe_callback#stripe_decoded set to <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> to disable the</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> *  callbacks at any point.</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> * Enabling striped decode does not prevent you from calling</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> *  th_decode_ycbcr_out() after the frame is fully decoded.</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> *</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> * <span class="command">\param</span>[in]  <span class="arg">_buf</span> #th_stripe_callback: The callback parameters.</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT <span class="command"> \a</span> <span class="arg">_dec_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL <span class="command"> \a</span> <span class="arg">_buf_sz</span> is not</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> *                     <span class="tag">&lt;tt&gt;</span>sizeof(th_stripe_callback)<span class="tag">&lt;/tt&gt;</span>.*/</i></td></tr>
<tr><th id="93">93</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_STRIPE_CB" data-ref="_M/TH_DECCTL_SET_STRIPE_CB">TH_DECCTL_SET_STRIPE_CB</dfn> (7)</u></td></tr>
<tr><th id="94">94</th><td></td></tr>
<tr><th id="95">95</th><td><i class="doc">/**Enables telemetry and sets the macroblock display mode */</i></td></tr>
<tr><th id="96">96</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_TELEMETRY_MBMODE" data-ref="_M/TH_DECCTL_SET_TELEMETRY_MBMODE">TH_DECCTL_SET_TELEMETRY_MBMODE</dfn> (9)</u></td></tr>
<tr><th id="97">97</th><td><i class="doc">/**Enables telemetry and sets the motion vector display mode */</i></td></tr>
<tr><th id="98">98</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_TELEMETRY_MV" data-ref="_M/TH_DECCTL_SET_TELEMETRY_MV">TH_DECCTL_SET_TELEMETRY_MV</dfn> (11)</u></td></tr>
<tr><th id="99">99</th><td><i class="doc">/**Enables telemetry and sets the adaptive quantization display mode */</i></td></tr>
<tr><th id="100">100</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_TELEMETRY_QI" data-ref="_M/TH_DECCTL_SET_TELEMETRY_QI">TH_DECCTL_SET_TELEMETRY_QI</dfn> (13)</u></td></tr>
<tr><th id="101">101</th><td><i class="doc">/**Enables telemetry and sets the bitstream breakdown visualization mode */</i></td></tr>
<tr><th id="102">102</th><td><u>#define <dfn class="macro" id="_M/TH_DECCTL_SET_TELEMETRY_BITS" data-ref="_M/TH_DECCTL_SET_TELEMETRY_BITS">TH_DECCTL_SET_TELEMETRY_BITS</dfn> (15)</u></td></tr>
<tr><th id="103">103</th><td><i>/*@}*/</i></td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td></td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td><i class="doc">/**A callback function for striped decode.</i></td></tr>
<tr><th id="108">108</th><td><i class="doc"> * This is a function pointer to an application-provided function that will be</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> *  called each time a section of the image is fully decoded in</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> *  th_decode_packetin().</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> * This allows the application to process the section immediately, while it is</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> *  still in cache.</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * Note that the frame is decoded bottom to top, so<span class="command"> \a</span> <span class="arg">_yfrag0</span> will steadily</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> *  decrease with each call until it reaches 0, at which point the full frame</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> *  is decoded.</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> * The number of fragment rows made available in each call depends on the pixel</i></td></tr>
<tr><th id="117">117</th><td><i class="doc"> *  format and the number of post-processing filters enabled, and may not even</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> *  be constant for the entire frame.</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> * If a non-<span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span><span class="command"> \a</span> <span class="arg">_granpos</span> pointer is passed to</i></td></tr>
<tr><th id="120">120</th><td><i class="doc"> *  th_decode_packetin(), the granule position for the frame will be stored</i></td></tr>
<tr><th id="121">121</th><td><i class="doc"> *  in it before the first callback is made.</i></td></tr>
<tr><th id="122">122</th><td><i class="doc"> * If an entire frame is dropped (a 0-byte packet), then no callbacks will be</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> *  made at all for that frame.</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_ctx</span>       An application-provided context pointer.</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_buf</span>       The image buffer for the decoded frame.</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_yfrag0</span>    The Y coordinate of the first row of 8x8 fragments</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> *                    decoded.</i></td></tr>
<tr><th id="128">128</th><td><i class="doc"> *                   Multiply this by 8 to obtain the pixel row number in the</i></td></tr>
<tr><th id="129">129</th><td><i class="doc"> *                    luma plane.</i></td></tr>
<tr><th id="130">130</th><td><i class="doc"> *                   If the chroma planes are subsampled in the Y direction,</i></td></tr>
<tr><th id="131">131</th><td><i class="doc"> *                    this will always be divisible by two.</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_yfrag_end</span> The Y coordinate of the first row of 8x8 fragments past</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> *                    the newly decoded section.</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> *                   If the chroma planes are subsampled in the Y direction,</i></td></tr>
<tr><th id="135">135</th><td><i class="doc"> *                    this will always be divisible by two.</i></td></tr>
<tr><th id="136">136</th><td><i class="doc"> *                   I.e., this section contains fragment rows</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> *                    <span class="tag">&lt;tt<span class="command">&gt;\a</span></span> <span class="arg">_yfrag0</span> ..<span class="command">.\a</span> <span class="arg">_yfrag_end</span> -1<span class="tag">&lt;/tt&gt;</span>.*/</i></td></tr>
<tr><th id="138">138</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="th_stripe_decoded_func" title='th_stripe_decoded_func' data-type='void (*)(void *, th_img_plane *, int, int)' data-ref="th_stripe_decoded_func">th_stripe_decoded_func</dfn>)(<em>void</em> *<dfn class="local col1 decl" id="1_ctx" title='_ctx' data-type='void *' data-ref="1_ctx">_ctx</dfn>,<a class="typedef" href="codec.h.html#th_ycbcr_buffer" title='th_ycbcr_buffer' data-type='th_img_plane [3]' data-ref="th_ycbcr_buffer">th_ycbcr_buffer</a> <dfn class="local col2 decl" id="2_buf" title='_buf' data-type='th_img_plane *' data-ref="2_buf">_buf</dfn>,</td></tr>
<tr><th id="139">139</th><td> <em>int</em> <dfn class="local col3 decl" id="3_yfrag0" title='_yfrag0' data-type='int' data-ref="3_yfrag0">_yfrag0</dfn>,<em>int</em> <dfn class="local col4 decl" id="4_yfrag_end" title='_yfrag_end' data-type='int' data-ref="4_yfrag_end">_yfrag_end</dfn>);</td></tr>
<tr><th id="140">140</th><td></td></tr>
<tr><th id="141">141</th><td><i class="doc">/**The striped decode callback data to pass to #TH_DECCTL_SET_STRIPE_CB.*/</i></td></tr>
<tr><th id="142">142</th><td><b>typedef</b> <b>struct</b>{</td></tr>
<tr><th id="143">143</th><td>  <i class="doc">/**An application-provided context pointer.</i></td></tr>
<tr><th id="144">144</th><td><i class="doc">   * This will be passed back verbatim to the application.*/</i></td></tr>
<tr><th id="145">145</th><td>  <em>void</em>                   *<dfn class="decl" id="{anonymous}::ctx" title='&lt;anonymous struct&gt;::ctx' data-ref="{anonymous}::ctx">ctx</dfn>;</td></tr>
<tr><th id="146">146</th><td>  <i class="doc">/**The callback function pointer.*/</i></td></tr>
<tr><th id="147">147</th><td>  <a class="typedef" href="#th_stripe_decoded_func" title='th_stripe_decoded_func' data-type='void (*)(void *, th_img_plane *, int, int)' data-ref="th_stripe_decoded_func">th_stripe_decoded_func</a>  <dfn class="decl" id="{anonymous}::stripe_decoded" title='&lt;anonymous struct&gt;::stripe_decoded' data-ref="{anonymous}::stripe_decoded">stripe_decoded</dfn>;</td></tr>
<tr><th id="148">148</th><td>}<dfn class="typedef" id="th_stripe_callback" title='th_stripe_callback' data-type='struct th_stripe_callback' data-ref="th_stripe_callback">th_stripe_callback</dfn>;</td></tr>
<tr><th id="149">149</th><td></td></tr>
<tr><th id="150">150</th><td></td></tr>
<tr><th id="151">151</th><td></td></tr>
<tr><th id="152">152</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">Decoder state</span></i></td></tr>
<tr><th id="153">153</th><td><i class="doc">   The following data structures are opaque, and their contents are not</i></td></tr>
<tr><th id="154">154</th><td><i class="doc">    publicly defined by this API.</i></td></tr>
<tr><th id="155">155</th><td><i class="doc">   Referring to their internals directly is unsupported, and may break without</i></td></tr>
<tr><th id="156">156</th><td><i class="doc">    warning.*/</i></td></tr>
<tr><th id="157">157</th><td><i>/*@{*/</i></td></tr>
<tr><th id="158">158</th><td><i class="doc">/**The decoder context.*/</i></td></tr>
<tr><th id="159">159</th><td><b>typedef</b> <b>struct</b> <dfn class="type" id="th_dec_ctx" title='th_dec_ctx' data-ref="th_dec_ctx"><a class="type" href="#th_dec_ctx" title='th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a></dfn>    <dfn class="typedef" id="th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</dfn>;</td></tr>
<tr><th id="160">160</th><td><i class="doc">/**Setup information.</i></td></tr>
<tr><th id="161">161</th><td><i class="doc">   This contains auxiliary information (Huffman tables and quantization</i></td></tr>
<tr><th id="162">162</th><td><i class="doc">    parameters) decoded from the setup header by th_decode_headerin() to be</i></td></tr>
<tr><th id="163">163</th><td><i class="doc">    passed to th_decode_alloc().</i></td></tr>
<tr><th id="164">164</th><td><i class="doc">   It can be re-used to initialize any number of decoders, and can be freed</i></td></tr>
<tr><th id="165">165</th><td><i class="doc">    via th_setup_free() at any time.*/</i></td></tr>
<tr><th id="166">166</th><td><b>typedef</b> <b>struct</b> <dfn class="type" id="th_setup_info" title='th_setup_info' data-ref="th_setup_info"><a class="type" href="#th_setup_info" title='th_setup_info' data-ref="th_setup_info">th_setup_info</a></dfn> <dfn class="typedef" id="th_setup_info" title='th_setup_info' data-type='struct th_setup_info' data-ref="th_setup_info">th_setup_info</dfn>;</td></tr>
<tr><th id="167">167</th><td><i>/*@}*/</i></td></tr>
<tr><th id="168">168</th><td></td></tr>
<tr><th id="169">169</th><td></td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><i class="doc">/**<span class="command">\defgroup</span> <span class="verb">decfuncs Functions for Decoding</span>*/</i></td></tr>
<tr><th id="172">172</th><td><i>/*@{*/</i></td></tr>
<tr><th id="173">173</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">Functions for decoding</span></i></td></tr>
<tr><th id="174">174</th><td><i class="doc"> * You must link to <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span> if you use any of the </i></td></tr>
<tr><th id="175">175</th><td><i class="doc"> * functions in this section.</i></td></tr>
<tr><th id="176">176</th><td><i class="doc"> *</i></td></tr>
<tr><th id="177">177</th><td><i class="doc"> * The functions are listed in the order they are used in a typical decode.</i></td></tr>
<tr><th id="178">178</th><td><i class="doc"> * The basic steps are:</i></td></tr>
<tr><th id="179">179</th><td><i class="doc"> * - Parse the header packets by repeatedly calling th_decode_headerin().</i></td></tr>
<tr><th id="180">180</th><td><i class="doc"> * - Allocate a #th_dec_ctx handle with th_decode_alloc().</i></td></tr>
<tr><th id="181">181</th><td><i class="doc"> * - Call th_setup_free() to free any memory used for codec setup</i></td></tr>
<tr><th id="182">182</th><td><i class="doc"> *    information.</i></td></tr>
<tr><th id="183">183</th><td><i class="doc"> * - Perform any additional decoder configuration with th_decode_ctl().</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> * - For each video data packet:</i></td></tr>
<tr><th id="185">185</th><td><i class="doc"> *   - Submit the packet to the decoder via th_decode_packetin().</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> *   - Retrieve the uncompressed video data via th_decode_ycbcr_out().</i></td></tr>
<tr><th id="187">187</th><td><i class="doc"> * - Call th_decode_free() to release all decoder memory.*/</i></td></tr>
<tr><th id="188">188</th><td><i>/*@{*/</i></td></tr>
<tr><th id="189">189</th><td><i class="doc">/**Decodes the header packets of a Theora stream.</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> * This should be called on the initial packets of the stream, in succession,</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> *  until it returns <span class="tag">&lt;tt&gt;</span>0<span class="tag">&lt;/tt&gt;</span>, indicating that all headers have been</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> *  processed, or an error is encountered.</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> * At least three header packets are required, and additional optional header</i></td></tr>
<tr><th id="194">194</th><td><i class="doc"> *  packets may follow.</i></td></tr>
<tr><th id="195">195</th><td><i class="doc"> * This can be used on the first packet of any logical stream to determine if</i></td></tr>
<tr><th id="196">196</th><td><i class="doc"> *  that stream is a Theora stream.</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_info</span>  A #th_info structure to fill in.</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> *               This must have been previously initialized with</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> *                th_info_init().</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> *               The application may immediately begin using the contents of</i></td></tr>
<tr><th id="201">201</th><td><i class="doc"> *                this structure after the first header is decoded, though it</i></td></tr>
<tr><th id="202">202</th><td><i class="doc"> *                must continue to be passed in on all subsequent calls.</i></td></tr>
<tr><th id="203">203</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_tc</span>    A #th_comment structure to fill in.</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> *               The application may immediately begin using the contents of</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> *                this structure after the second header is decoded, though it</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> *                must continue to be passed in on all subsequent calls.</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_setup</span> Returns a pointer to additional, private setup information</i></td></tr>
<tr><th id="208">208</th><td><i class="doc"> *                needed by the decoder.</i></td></tr>
<tr><th id="209">209</th><td><i class="doc"> *               The contents of this pointer must be initialized to</i></td></tr>
<tr><th id="210">210</th><td><i class="doc"> *                <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> on the first call, and the returned value must</i></td></tr>
<tr><th id="211">211</th><td><i class="doc"> *                continue to be passed in on all subsequent calls.</i></td></tr>
<tr><th id="212">212</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_op</span>    An <span class="tag">&lt;tt&gt;</span>ogg_packet<span class="tag">&lt;/tt&gt;</span> structure which contains one of the</i></td></tr>
<tr><th id="213">213</th><td><i class="doc"> *                initial packets of an Ogg logical stream.</i></td></tr>
<tr><th id="214">214</th><td><i class="doc"> * <span class="command">\return</span> A positive value indicates that a Theora header was successfully</i></td></tr>
<tr><th id="215">215</th><td><i class="doc"> *          processed.</i></td></tr>
<tr><th id="216">216</th><td><i class="doc"> *<span class="command"> \retval</span> 0             The first video data packet was encountered after all</i></td></tr>
<tr><th id="217">217</th><td><i class="doc"> *                        required header packets were parsed.</i></td></tr>
<tr><th id="218">218</th><td><i class="doc"> *                       The packet just passed in on this call should be saved</i></td></tr>
<tr><th id="219">219</th><td><i class="doc"> *                        and fed to th_decode_packetin() to begin decoding</i></td></tr>
<tr><th id="220">220</th><td><i class="doc"> *                        video data.</i></td></tr>
<tr><th id="221">221</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT     One of<span class="command"> \a</span> <span class="arg">_info,</span><span class="command"> \a</span> <span class="arg">_tc,</span> or<span class="command"> \a</span> <span class="arg">_setup</span> was</i></td></tr>
<tr><th id="222">222</th><td><i class="doc"> *                        <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="223">223</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EBADHEADER<span class="command"> \a</span> <span class="arg">_op</span> was <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>, the packet was not the next</i></td></tr>
<tr><th id="224">224</th><td><i class="doc"> *                        header packet in the expected sequence, or the format</i></td></tr>
<tr><th id="225">225</th><td><i class="doc"> *                        of the header data was invalid.</i></td></tr>
<tr><th id="226">226</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EVERSION   The packet data was a Theora info header, but for a</i></td></tr>
<tr><th id="227">227</th><td><i class="doc"> *                        bitstream version not decodable with this version of</i></td></tr>
<tr><th id="228">228</th><td><i class="doc"> *                        <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="229">229</th><td><i class="doc"> *<span class="command"> \retval</span> TH_ENOTFORMAT The packet was not a Theora header.</i></td></tr>
<tr><th id="230">230</th><td><i class="doc"> */</i></td></tr>
<tr><th id="231">231</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_decode_headerin" title='th_decode_headerin' data-ref="th_decode_headerin">th_decode_headerin</dfn>(<a class="typedef" href="codec.h.html#th_info" title='th_info' data-type='struct th_info' data-ref="th_info">th_info</a> *<dfn class="local col5 decl" id="5_info" title='_info' data-type='th_info *' data-ref="5_info">_info</dfn>,<a class="typedef" href="codec.h.html#th_comment" title='th_comment' data-type='struct th_comment' data-ref="th_comment">th_comment</a> *<dfn class="local col6 decl" id="6_tc" title='_tc' data-type='th_comment *' data-ref="6_tc">_tc</dfn>,</td></tr>
<tr><th id="232">232</th><td> <a class="typedef" href="#th_setup_info" title='th_setup_info' data-type='struct th_setup_info' data-ref="th_setup_info">th_setup_info</a> **<dfn class="local col7 decl" id="7_setup" title='_setup' data-type='th_setup_info **' data-ref="7_setup">_setup</dfn>,<a class="typedef" href="../ogg/ogg.h.html#ogg_packet" title='ogg_packet' data-type='struct ogg_packet' data-ref="ogg_packet">ogg_packet</a> *<dfn class="local col8 decl" id="8_op" title='_op' data-type='ogg_packet *' data-ref="8_op">_op</dfn>);</td></tr>
<tr><th id="233">233</th><td><i class="doc">/**Allocates a decoder instance.</i></td></tr>
<tr><th id="234">234</th><td><i class="doc"> *</i></td></tr>
<tr><th id="235">235</th><td><i class="doc"> * <span class="tag">&lt;b&gt;</span>Security Warning:<span class="tag">&lt;/b&gt;</span> The Theora format supports very large frame sizes,</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> *  potentially even larger than the address space of a 32-bit machine, and</i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> *  creating a decoder context allocates the space for several frames of data.</i></td></tr>
<tr><th id="238">238</th><td><i class="doc"> * If the allocation fails here, your program will crash, possibly at some</i></td></tr>
<tr><th id="239">239</th><td><i class="doc"> *  future point because the OS kernel returned a valid memory range and will</i></td></tr>
<tr><th id="240">240</th><td><i class="doc"> *  only fail when it tries to map the pages in it the first time they are</i></td></tr>
<tr><th id="241">241</th><td><i class="doc"> *  used.</i></td></tr>
<tr><th id="242">242</th><td><i class="doc"> * Even if it succeeds, you may experience a denial of service if the frame</i></td></tr>
<tr><th id="243">243</th><td><i class="doc"> *  size is large enough to cause excessive paging.</i></td></tr>
<tr><th id="244">244</th><td><i class="doc"> * If you are integrating libtheora in a larger application where such things</i></td></tr>
<tr><th id="245">245</th><td><i class="doc"> *  are undesirable, it is highly recommended that you check the frame size in</i></td></tr>
<tr><th id="246">246</th><td><i class="doc"> * <span class="command"> \a</span> <span class="arg">_info</span> before calling this function and refuse to decode streams where it</i></td></tr>
<tr><th id="247">247</th><td><i class="doc"> *  is larger than some reasonable maximum.</i></td></tr>
<tr><th id="248">248</th><td><i class="doc"> * libtheora will not check this for you, because there may be machines that</i></td></tr>
<tr><th id="249">249</th><td><i class="doc"> *  can handle such streams and applications that wish to.</i></td></tr>
<tr><th id="250">250</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_info</span>  A #th_info struct filled via th_decode_headerin().</i></td></tr>
<tr><th id="251">251</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_setup</span> A #th_setup_info handle returned via</i></td></tr>
<tr><th id="252">252</th><td><i class="doc"> *                th_decode_headerin().</i></td></tr>
<tr><th id="253">253</th><td><i class="doc"> * <span class="command">\return</span> The initialized #th_dec_ctx handle.</i></td></tr>
<tr><th id="254">254</th><td><i class="doc"> *<span class="command"> \retval</span> NULL If the decoding parameters were invalid.*/</i></td></tr>
<tr><th id="255">255</th><td><b>extern</b> <a class="typedef" href="#th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a> *<dfn class="decl" id="th_decode_alloc" title='th_decode_alloc' data-ref="th_decode_alloc">th_decode_alloc</dfn>(<em>const</em> <a class="typedef" href="codec.h.html#th_info" title='th_info' data-type='struct th_info' data-ref="th_info">th_info</a> *<dfn class="local col9 decl" id="9_info" title='_info' data-type='const th_info *' data-ref="9_info">_info</dfn>,</td></tr>
<tr><th id="256">256</th><td> <em>const</em> <a class="typedef" href="#th_setup_info" title='th_setup_info' data-type='struct th_setup_info' data-ref="th_setup_info">th_setup_info</a> *<dfn class="local col0 decl" id="10_setup" title='_setup' data-type='const th_setup_info *' data-ref="10_setup">_setup</dfn>);</td></tr>
<tr><th id="257">257</th><td><i class="doc">/**Releases all storage used for the decoder setup information.</i></td></tr>
<tr><th id="258">258</th><td><i class="doc"> * This should be called after you no longer want to create any decoders for</i></td></tr>
<tr><th id="259">259</th><td><i class="doc"> *  a stream whose headers you have parsed with th_decode_headerin().</i></td></tr>
<tr><th id="260">260</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_setup</span> The setup information to free.</i></td></tr>
<tr><th id="261">261</th><td><i class="doc"> *               This can safely be <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.*/</i></td></tr>
<tr><th id="262">262</th><td><b>extern</b> <em>void</em> <dfn class="decl" id="th_setup_free" title='th_setup_free' data-ref="th_setup_free">th_setup_free</dfn>(<a class="typedef" href="#th_setup_info" title='th_setup_info' data-type='struct th_setup_info' data-ref="th_setup_info">th_setup_info</a> *<dfn class="local col1 decl" id="11_setup" title='_setup' data-type='th_setup_info *' data-ref="11_setup">_setup</dfn>);</td></tr>
<tr><th id="263">263</th><td><i class="doc">/**Decoder control function.</i></td></tr>
<tr><th id="264">264</th><td><i class="doc"> * This is used to provide advanced control of the decoding process.</i></td></tr>
<tr><th id="265">265</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_dec</span>    A #th_dec_ctx handle.</i></td></tr>
<tr><th id="266">266</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_req</span>    The control code to process.</i></td></tr>
<tr><th id="267">267</th><td><i class="doc"> *                See <span class="command">\ref</span> <span class="verb">decctlcodes "the list of available control codes"</span></i></td></tr>
<tr><th id="268">268</th><td><i class="doc"> *                 for details.</i></td></tr>
<tr><th id="269">269</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_buf</span>    The parameters for this control code.</i></td></tr>
<tr><th id="270">270</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_buf_sz</span> The size of the parameter buffer.*/</i></td></tr>
<tr><th id="271">271</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_decode_ctl" title='th_decode_ctl' data-ref="th_decode_ctl">th_decode_ctl</dfn>(<a class="typedef" href="#th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a> *<dfn class="local col2 decl" id="12_dec" title='_dec' data-type='th_dec_ctx *' data-ref="12_dec">_dec</dfn>,<em>int</em> <dfn class="local col3 decl" id="13_req" title='_req' data-type='int' data-ref="13_req">_req</dfn>,<em>void</em> *<dfn class="local col4 decl" id="14_buf" title='_buf' data-type='void *' data-ref="14_buf">_buf</dfn>,</td></tr>
<tr><th id="272">272</th><td> <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col5 decl" id="15_buf_sz" title='_buf_sz' data-type='size_t' data-ref="15_buf_sz">_buf_sz</dfn>);</td></tr>
<tr><th id="273">273</th><td><i class="doc">/**Submits a packet containing encoded video data to the decoder.</i></td></tr>
<tr><th id="274">274</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_dec</span>     A #th_dec_ctx handle.</i></td></tr>
<tr><th id="275">275</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_op</span>      An <span class="tag">&lt;tt&gt;</span>ogg_packet<span class="tag">&lt;/tt&gt;</span> containing encoded video data.</i></td></tr>
<tr><th id="276">276</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_granpos</span> Returns the granule position of the decoded packet.</i></td></tr>
<tr><th id="277">277</th><td><i class="doc"> *                 If non-<span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>, the granule position for this specific</i></td></tr>
<tr><th id="278">278</th><td><i class="doc"> *                  packet is stored in this location.</i></td></tr>
<tr><th id="279">279</th><td><i class="doc"> *                 This is computed incrementally from previously decoded</i></td></tr>
<tr><th id="280">280</th><td><i class="doc"> *                  packets.</i></td></tr>
<tr><th id="281">281</th><td><i class="doc"> *                 After a seek, the correct granule position must be set via</i></td></tr>
<tr><th id="282">282</th><td><i class="doc"> *                  #TH_DECCTL_SET_GRANPOS for this to work properly.</i></td></tr>
<tr><th id="283">283</th><td><i class="doc"> *<span class="command"> \retval</span> 0             Success.</i></td></tr>
<tr><th id="284">284</th><td><i class="doc"> *                       A new decoded frame can be retrieved by calling</i></td></tr>
<tr><th id="285">285</th><td><i class="doc"> *                        th_decode_ycbcr_out().</i></td></tr>
<tr><th id="286">286</th><td><i class="doc"> *<span class="command"> \retval</span> TH_DUPFRAME   The packet represented a dropped (0-byte) frame.</i></td></tr>
<tr><th id="287">287</th><td><i class="doc"> *                       The player can skip the call to th_decode_ycbcr_out(),</i></td></tr>
<tr><th id="288">288</th><td><i class="doc"> *                        as the contents of the decoded frame buffer have not</i></td></tr>
<tr><th id="289">289</th><td><i class="doc"> *                        changed.</i></td></tr>
<tr><th id="290">290</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT    <span class="command"> \a</span> <span class="arg">_dec</span> or<span class="command"> \a</span> <span class="arg">_op</span> was <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="291">291</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EBADPACKET<span class="command"> \a</span> <span class="arg">_op</span> does not contain encoded video data.</i></td></tr>
<tr><th id="292">292</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL      The video data uses bitstream features which this</i></td></tr>
<tr><th id="293">293</th><td><i class="doc"> *                        library does not support.*/</i></td></tr>
<tr><th id="294">294</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_decode_packetin" title='th_decode_packetin' data-ref="th_decode_packetin">th_decode_packetin</dfn>(<a class="typedef" href="#th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a> *<dfn class="local col6 decl" id="16_dec" title='_dec' data-type='th_dec_ctx *' data-ref="16_dec">_dec</dfn>,<em>const</em> <a class="typedef" href="../ogg/ogg.h.html#ogg_packet" title='ogg_packet' data-type='struct ogg_packet' data-ref="ogg_packet">ogg_packet</a> *<dfn class="local col7 decl" id="17_op" title='_op' data-type='const ogg_packet *' data-ref="17_op">_op</dfn>,</td></tr>
<tr><th id="295">295</th><td> <a class="typedef" href="../ogg/config_types.h.html#ogg_int64_t" title='ogg_int64_t' data-type='int64_t' data-ref="ogg_int64_t">ogg_int64_t</a> *<dfn class="local col8 decl" id="18_granpos" title='_granpos' data-type='ogg_int64_t *' data-ref="18_granpos">_granpos</dfn>);</td></tr>
<tr><th id="296">296</th><td><i class="doc">/**Outputs the next available frame of decoded Y'CbCr data.</i></td></tr>
<tr><th id="297">297</th><td><i class="doc"> * If a striped decode callback has been set with #TH_DECCTL_SET_STRIPE_CB,</i></td></tr>
<tr><th id="298">298</th><td><i class="doc"> *  then the application does not need to call this function.</i></td></tr>
<tr><th id="299">299</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_dec</span>   A #th_dec_ctx handle.</i></td></tr>
<tr><th id="300">300</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_ycbcr</span> A video buffer structure to fill in.</i></td></tr>
<tr><th id="301">301</th><td><i class="doc"> *               <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span> will fill in all the members of this</i></td></tr>
<tr><th id="302">302</th><td><i class="doc"> *                structure, including the pointers to the uncompressed video</i></td></tr>
<tr><th id="303">303</th><td><i class="doc"> *                data.</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> *               The memory for this video data is owned by</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> *                <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="306">306</th><td><i class="doc"> *               It may be freed or overwritten without notification when</i></td></tr>
<tr><th id="307">307</th><td><i class="doc"> *                subsequent frames are decoded.</i></td></tr>
<tr><th id="308">308</th><td><i class="doc"> *<span class="command"> \retval</span> 0 Success</i></td></tr>
<tr><th id="309">309</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT    <span class="command"> \a</span> <span class="arg">_dec</span> or<span class="command"> \a</span> <span class="arg">_ycbcr</span> was <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="310">310</th><td><i class="doc"> */</i></td></tr>
<tr><th id="311">311</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_decode_ycbcr_out" title='th_decode_ycbcr_out' data-ref="th_decode_ycbcr_out">th_decode_ycbcr_out</dfn>(<a class="typedef" href="#th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a> *<dfn class="local col9 decl" id="19_dec" title='_dec' data-type='th_dec_ctx *' data-ref="19_dec">_dec</dfn>,</td></tr>
<tr><th id="312">312</th><td> <a class="typedef" href="codec.h.html#th_ycbcr_buffer" title='th_ycbcr_buffer' data-type='th_img_plane [3]' data-ref="th_ycbcr_buffer">th_ycbcr_buffer</a> <dfn class="local col0 decl" id="20_ycbcr" title='_ycbcr' data-type='th_img_plane *' data-ref="20_ycbcr">_ycbcr</dfn>);</td></tr>
<tr><th id="313">313</th><td><i class="doc">/**Frees an allocated decoder instance.</i></td></tr>
<tr><th id="314">314</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_dec</span> A #th_dec_ctx handle.*/</i></td></tr>
<tr><th id="315">315</th><td><b>extern</b> <em>void</em> <dfn class="decl" id="th_decode_free" title='th_decode_free' data-ref="th_decode_free">th_decode_free</dfn>(<a class="typedef" href="#th_dec_ctx" title='th_dec_ctx' data-type='struct th_dec_ctx' data-ref="th_dec_ctx">th_dec_ctx</a> *<dfn class="local col1 decl" id="21_dec" title='_dec' data-type='th_dec_ctx *' data-ref="21_dec">_dec</dfn>);</td></tr>
<tr><th id="316">316</th><td><i>/*@}*/</i></td></tr>
<tr><th id="317">317</th><td><i>/*@}*/</i></td></tr>
<tr><th id="318">318</th><td></td></tr>
<tr><th id="319">319</th><td></td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><u>#<span data-ppcond="321">if</span> defined(<span class="macro" data-ref="_M/__cplusplus">__cplusplus</span>)</u></td></tr>
<tr><th id="322">322</th><td>}</td></tr>
<tr><th id="323">323</th><td><u>#<span data-ppcond="321">endif</span></u></td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><u>#<span data-ppcond="21">endif</span></u></td></tr>
<tr><th id="326">326</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../vlc/modules/codec/theora.c.html'>vlc/modules/codec/theora.c</a><br/>Generated on <em>2016-Oct-25</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
