<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>theoraenc.h source code [include/theora/theoraenc.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/theora/theoraenc.h'; var root_path = '../..'; var data_path = '../../../data';</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>include</a>/<a href='./'>theora</a>/<a href='theoraenc.h.html'>theoraenc.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/********************************************************************</i></td></tr>
<tr><th id="2">2</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="3">3</th><td><i> * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *</i></td></tr>
<tr><th id="4">4</th><td><i> * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *</i></td></tr>
<tr><th id="5">5</th><td><i> * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *</i></td></tr>
<tr><th id="6">6</th><td><i> * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *</i></td></tr>
<tr><th id="7">7</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="8">8</th><td><i> * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2009                *</i></td></tr>
<tr><th id="9">9</th><td><i> * by the Xiph.Org Foundation <a href="http://www.xiph.org/">http://www.xiph.org/</a>                  *</i></td></tr>
<tr><th id="10">10</th><td><i> *                                                                  *</i></td></tr>
<tr><th id="11">11</th><td><i> ********************************************************************</i></td></tr>
<tr><th id="12">12</th><td><i></i></td></tr>
<tr><th id="13">13</th><td><i>  function:</i></td></tr>
<tr><th id="14">14</th><td><i>  last mod: $Id: theora.h,v 1.8 2004/03/15 22:17:32 derf Exp $</i></td></tr>
<tr><th id="15">15</th><td><i></i></td></tr>
<tr><th id="16">16</th><td><i> ********************************************************************/</i></td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><i class="doc">/*<span class="command">*\file</span></i></td></tr>
<tr><th id="19">19</th><td><i class="doc"> * The <span class="tag">&lt;tt&gt;</span>libtheoraenc<span class="tag">&lt;/tt&gt;</span> C encoding API.*/</i></td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><u>#<span data-ppcond="21">if</span> !defined(<span class="macro" data-ref="_M/_O_THEORA_THEORAENC_H_">_O_THEORA_THEORAENC_H_</span>)</u></td></tr>
<tr><th id="22">22</th><td><u># define <dfn class="macro" id="_M/_O_THEORA_THEORAENC_H_" data-ref="_M/_O_THEORA_THEORAENC_H_">_O_THEORA_THEORAENC_H_</dfn> (1)</u></td></tr>
<tr><th id="23">23</th><td><u># include &lt;stddef.h&gt;</u></td></tr>
<tr><th id="24">24</th><td><u># include <a href="../ogg/ogg.h.html">&lt;ogg/ogg.h&gt;</a></u></td></tr>
<tr><th id="25">25</th><td><u># include <a href="codec.h.html">"codec.h"</a></u></td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td><u>#<span data-ppcond="27">if</span> defined(<span class="macro" data-ref="_M/__cplusplus">__cplusplus</span>)</u></td></tr>
<tr><th id="28">28</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="27">endif</span></u></td></tr>
<tr><th id="30">30</th><td></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td></td></tr>
<tr><th id="33">33</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">th_encode_ctl() codes</span></i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> *<span class="command"> \anchor</span> encctlcodes</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * These are the available request codes for th_encode_ctl().</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> * By convention, these are even, to distinguish them from the</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> *  <span class="command">\ref</span> <span class="verb">decctlcodes "decoder control codes".</span></i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * Keep any experimental or vendor-specific values above<span class="command"> \c</span> <span class="arg">0x8000.</span>*/</i></td></tr>
<tr><th id="39">39</th><td><i>/*@{*/</i></td></tr>
<tr><th id="40">40</th><td><i class="doc">/**Sets the Huffman tables to use.</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> * The tables are copied, not stored by reference, so they can be freed after</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> *  this call.</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> * <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> may be specified to revert to the default tables.</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> *</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>#th_huff_code[#TH_NHUFFMAN_TABLES][#TH_NDCT_TOKENS]<span class="tag">&lt;/tt&gt;</span></i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL Encoding has already begun or one or more of the given</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> *                     tables is not full or prefix-free,<span class="command"> \a</span> <span class="arg">_buf</span> is</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> *                     <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> and<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not zero, or<span class="command"> \a</span> <span class="arg">_buf</span> is</i></td></tr>
<tr><th id="50">50</th><td><i class="doc"> *                     non-<span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> and<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not</i></td></tr>
<tr><th id="51">51</th><td><i class="doc"> *                     <span class="tag">&lt;tt&gt;</span>sizeof(#th_huff_code)*#TH_NHUFFMAN_TABLES*#TH_NDCT_TOKENS<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="53">53</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_HUFFMAN_CODES" data-ref="_M/TH_ENCCTL_SET_HUFFMAN_CODES">TH_ENCCTL_SET_HUFFMAN_CODES</dfn> (0)</u></td></tr>
<tr><th id="54">54</th><td><i class="doc">/**Sets the quantization parameters to use.</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> * The parameters are copied, not stored by reference, so they can be freed</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> *  after this call.</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> * <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> may be specified to revert to the default parameters.</i></td></tr>
<tr><th id="58">58</th><td><i class="doc"> *</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> #th_quant_info</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="61">61</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL Encoding has already begun,<span class="command"> \a</span> <span class="arg">_buf</span> is </i></td></tr>
<tr><th id="62">62</th><td><i class="doc"> *                    <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> and<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not zero,</i></td></tr>
<tr><th id="63">63</th><td><i class="doc"> *                    or<span class="command"> \a</span> <span class="arg">_buf</span> is non-<span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> and</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> *                   <span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(#th_quant_info)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="66">66</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_QUANT_PARAMS" data-ref="_M/TH_ENCCTL_SET_QUANT_PARAMS">TH_ENCCTL_SET_QUANT_PARAMS</dfn> (2)</u></td></tr>
<tr><th id="67">67</th><td><i class="doc">/**Sets the maximum distance between key frames.</i></td></tr>
<tr><th id="68">68</th><td><i class="doc"> * This can be changed during an encode, but will be bounded by</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> *  <span class="tag">&lt;tt&gt;</span>1&lt;&lt;th_info#keyframe_granule_shift<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> * If it is set before encoding begins, th_info#keyframe_granule_shift will</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> *  be enlarged appropriately.</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> *</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> * <span class="command">\param</span>[in]  <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>ogg_uint32_t<span class="tag">&lt;/tt&gt;</span>: The maximum distance between key</i></td></tr>
<tr><th id="74">74</th><td><i class="doc"> *                   frames.</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>ogg_uint32_t<span class="tag">&lt;/tt&gt;</span>: The actual maximum distance set.</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(ogg_uint32_t)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="79">79</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE" data-ref="_M/TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE">TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE</dfn> (4)</u></td></tr>
<tr><th id="80">80</th><td><i class="doc">/**Disables any encoder features that would prevent lossless transcoding back</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> *  to VP3.</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> * This primarily means disabling block-adaptive quantization and always coding</i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> *  all four luma blocks in a macro block when 4MV is used.</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * It also includes using the VP3 quantization tables and Huffman codes; if you</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> *  set them explicitly after calling this function, the resulting stream will</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> *  not be VP3-compatible.</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * If you enable VP3-compatibility when encoding 4:2:2 or 4:4:4 source</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> *  material, or when using a picture region smaller than the full frame (e.g.</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> *  a non-multiple-of-16 width or height), then non-VP3 bitstream features will</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> *  still be disabled, but the stream will still not be VP3-compatible, as VP3</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> *  was not capable of encoding such formats.</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> * If you call this after encoding has already begun, then the quantization</i></td></tr>
<tr><th id="93">93</th><td><i class="doc"> *  tables and codebooks cannot be changed, but the frame-level features will</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> *  be enabled or disabled as requested.</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> *</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * <span class="command">\param</span>[in]  <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: a non-zero value to enable VP3 compatibility,</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> *                   or 0 to disable it (the default).</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: 1 if all bitstream features required for</i></td></tr>
<tr><th id="99">99</th><td><i class="doc"> *                   VP3-compatibility could be set, and 0 otherwise.</i></td></tr>
<tr><th id="100">100</th><td><i class="doc"> *                  The latter will be returned if the pixel format is not</i></td></tr>
<tr><th id="101">101</th><td><i class="doc"> *                   4:2:0, the picture region is smaller than the full frame,</i></td></tr>
<tr><th id="102">102</th><td><i class="doc"> *                   or if encoding has begun, preventing the quantization</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> *                   tables and codebooks from being set.</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="107">107</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_VP3_COMPATIBLE" data-ref="_M/TH_ENCCTL_SET_VP3_COMPATIBLE">TH_ENCCTL_SET_VP3_COMPATIBLE</dfn> (10)</u></td></tr>
<tr><th id="108">108</th><td><i class="doc">/**Gets the maximum speed level.</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> * Higher speed levels favor quicker encoding over better quality per bit.</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> * Depending on the encoding mode, and the internal algorithms used, quality</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> *  may actually improve, but in this case bitrate will also likely increase.</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> * In any case, overall rate/distortion performance will probably decrease.</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * The maximum value, and the meaning of each value, may change depending on</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> *  the current encoding mode (VBR vs. constant quality, etc.).</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> *</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The maximum encoding speed level.</i></td></tr>
<tr><th id="117">117</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="120">120</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="121">121</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_GET_SPLEVEL_MAX" data-ref="_M/TH_ENCCTL_GET_SPLEVEL_MAX">TH_ENCCTL_GET_SPLEVEL_MAX</dfn> (12)</u></td></tr>
<tr><th id="122">122</th><td><i class="doc">/**Sets the speed level.</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> * The current speed level may be retrieved using #TH_ENCCTL_GET_SPLEVEL.</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> *</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The new encoding speed level.</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> *                 0 is slowest, larger values use less CPU.</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="128">128</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>, or the</i></td></tr>
<tr><th id="129">129</th><td><i class="doc"> *                    encoding speed level is out of bounds.</i></td></tr>
<tr><th id="130">130</th><td><i class="doc"> *                   The maximum encoding speed level may be</i></td></tr>
<tr><th id="131">131</th><td><i class="doc"> *                    implementation- and encoding mode-specific, and can be</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> *                    obtained via #TH_ENCCTL_GET_SPLEVEL_MAX.</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="135">135</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_SPLEVEL" data-ref="_M/TH_ENCCTL_SET_SPLEVEL">TH_ENCCTL_SET_SPLEVEL</dfn> (14)</u></td></tr>
<tr><th id="136">136</th><td><i class="doc">/**Gets the current speed level.</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> * The default speed level may vary according to encoder implementation, but if</i></td></tr>
<tr><th id="138">138</th><td><i class="doc"> *  this control code is not supported (it returns #TH_EIMPL), the default may</i></td></tr>
<tr><th id="139">139</th><td><i class="doc"> *  be assumed to be the slowest available speed (0).</i></td></tr>
<tr><th id="140">140</th><td><i class="doc"> * The maximum encoding speed level may be implementation- and encoding</i></td></tr>
<tr><th id="141">141</th><td><i class="doc"> *  mode-specific, and can be obtained via #TH_ENCCTL_GET_SPLEVEL_MAX.</i></td></tr>
<tr><th id="142">142</th><td><i class="doc"> *</i></td></tr>
<tr><th id="143">143</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The current encoding speed level.</i></td></tr>
<tr><th id="144">144</th><td><i class="doc"> *                  0 is slowest, larger values use less CPU.</i></td></tr>
<tr><th id="145">145</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="146">146</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="147">147</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="148">148</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="149">149</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_GET_SPLEVEL" data-ref="_M/TH_ENCCTL_GET_SPLEVEL">TH_ENCCTL_GET_SPLEVEL</dfn> (16)</u></td></tr>
<tr><th id="150">150</th><td><i class="doc">/**Sets the number of duplicates of the next frame to produce.</i></td></tr>
<tr><th id="151">151</th><td><i class="doc"> * Although libtheora can encode duplicate frames very cheaply, it costs some</i></td></tr>
<tr><th id="152">152</th><td><i class="doc"> *  amount of CPU to detect them, and a run of duplicates cannot span a</i></td></tr>
<tr><th id="153">153</th><td><i class="doc"> *  keyframe boundary.</i></td></tr>
<tr><th id="154">154</th><td><i class="doc"> * This control code tells the encoder to produce the specified number of extra</i></td></tr>
<tr><th id="155">155</th><td><i class="doc"> *  duplicates of the next frame.</i></td></tr>
<tr><th id="156">156</th><td><i class="doc"> * This allows the encoder to make smarter keyframe placement decisions and</i></td></tr>
<tr><th id="157">157</th><td><i class="doc"> *  rate control decisions, and reduces CPU usage as well, when compared to</i></td></tr>
<tr><th id="158">158</th><td><i class="doc"> *  just submitting the same frame for encoding multiple times.</i></td></tr>
<tr><th id="159">159</th><td><i class="doc"> * This setting only applies to the next frame submitted for encoding.</i></td></tr>
<tr><th id="160">160</th><td><i class="doc"> * You MUST call th_encode_packetout() repeatedly until it returns 0, or the</i></td></tr>
<tr><th id="161">161</th><td><i class="doc"> *  extra duplicate frames will be lost.</i></td></tr>
<tr><th id="162">162</th><td><i class="doc"> *</i></td></tr>
<tr><th id="163">163</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The number of duplicates to produce.</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> *                 If this is negative or zero, no duplicates will be produced.</i></td></tr>
<tr><th id="165">165</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="166">166</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>, or the</i></td></tr>
<tr><th id="167">167</th><td><i class="doc"> *                    number of duplicates is greater than or equal to the</i></td></tr>
<tr><th id="168">168</th><td><i class="doc"> *                    maximum keyframe interval.</i></td></tr>
<tr><th id="169">169</th><td><i class="doc"> *                   In the latter case, NO duplicate frames will be produced.</i></td></tr>
<tr><th id="170">170</th><td><i class="doc"> *                   You must ensure that the maximum keyframe interval is set</i></td></tr>
<tr><th id="171">171</th><td><i class="doc"> *                    larger than the maximum number of duplicates you will</i></td></tr>
<tr><th id="172">172</th><td><i class="doc"> *                    ever wish to insert prior to encoding.</i></td></tr>
<tr><th id="173">173</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="174">174</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="175">175</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_DUP_COUNT" data-ref="_M/TH_ENCCTL_SET_DUP_COUNT">TH_ENCCTL_SET_DUP_COUNT</dfn> (18)</u></td></tr>
<tr><th id="176">176</th><td><i class="doc">/**Modifies the default bitrate management behavior.</i></td></tr>
<tr><th id="177">177</th><td><i class="doc"> * Use to allow or disallow frame dropping, and to enable or disable capping</i></td></tr>
<tr><th id="178">178</th><td><i class="doc"> *  bit reservoir overflows and underflows.</i></td></tr>
<tr><th id="179">179</th><td><i class="doc"> * See <span class="command">\ref</span> <span class="verb">encctlcodes "the list of available flags".</span></i></td></tr>
<tr><th id="180">180</th><td><i class="doc"> * The flags are set by default to</i></td></tr>
<tr><th id="181">181</th><td><i class="doc"> *  <span class="tag">&lt;tt&gt;</span>#TH_RATECTL_DROP_FRAMES|#TH_RATECTL_CAP_OVERFLOW<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="182">182</th><td><i class="doc"> *</i></td></tr>
<tr><th id="183">183</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: Any combination of</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> *                  <span class="command">\ref</span> <span class="verb">ratectlflags "the available flags":</span></i></td></tr>
<tr><th id="185">185</th><td><i class="doc"> *                 - #TH_RATECTL_DROP_FRAMES: Enable frame dropping.</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> *                 - #TH_RATECTL_CAP_OVERFLOW: Don't bank excess bits for later</i></td></tr>
<tr><th id="187">187</th><td><i class="doc"> *                    use.</i></td></tr>
<tr><th id="188">188</th><td><i class="doc"> *                 - #TH_RATECTL_CAP_UNDERFLOW: Don't try to make up shortfalls</i></td></tr>
<tr><th id="189">189</th><td><i class="doc"> *                    later.</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span> or rate control</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> *                    is not enabled.</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="194">194</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="195">195</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_RATE_FLAGS" data-ref="_M/TH_ENCCTL_SET_RATE_FLAGS">TH_ENCCTL_SET_RATE_FLAGS</dfn> (20)</u></td></tr>
<tr><th id="196">196</th><td><i class="doc">/**Sets the size of the bitrate management bit reservoir as a function</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> *  of number of frames.</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> * The reservoir size affects how quickly bitrate management reacts to</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> *  instantaneous changes in the video complexity.</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> * Larger reservoirs react more slowly, and provide better overall quality, but</i></td></tr>
<tr><th id="201">201</th><td><i class="doc"> *  require more buffering by a client, adding more latency to live streams.</i></td></tr>
<tr><th id="202">202</th><td><i class="doc"> * By default, libtheora sets the reservoir to the maximum distance between</i></td></tr>
<tr><th id="203">203</th><td><i class="doc"> *  keyframes, subject to a minimum and maximum limit.</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> * This call may be used to increase or decrease the reservoir, increasing or</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> *  decreasing the allowed temporary variance in bitrate.</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> * An implementation may impose some limits on the size of a reservoir it can</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> *  handle, in which case the actual reservoir size may not be exactly what was</i></td></tr>
<tr><th id="208">208</th><td><i class="doc"> *  requested.</i></td></tr>
<tr><th id="209">209</th><td><i class="doc"> * The actual value set will be returned.</i></td></tr>
<tr><th id="210">210</th><td><i class="doc"> *</i></td></tr>
<tr><th id="211">211</th><td><i class="doc"> * <span class="command">\param</span>[in]  <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: Requested size of the reservoir measured in</i></td></tr>
<tr><th id="212">212</th><td><i class="doc"> *                   frames.</i></td></tr>
<tr><th id="213">213</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The actual size of the reservoir set.</i></td></tr>
<tr><th id="214">214</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="215">215</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(int)<span class="tag">&lt;/tt&gt;</span>, or rate control</i></td></tr>
<tr><th id="216">216</th><td><i class="doc"> *                    is not enabled.  The buffer has an implementation</i></td></tr>
<tr><th id="217">217</th><td><i class="doc"> *                    defined minimum and maximum size and the value in _buf</i></td></tr>
<tr><th id="218">218</th><td><i class="doc"> *                    will be adjusted to match the actual value set.</i></td></tr>
<tr><th id="219">219</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation in the current</i></td></tr>
<tr><th id="220">220</th><td><i class="doc"> *                    encoding mode.*/</i></td></tr>
<tr><th id="221">221</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_RATE_BUFFER" data-ref="_M/TH_ENCCTL_SET_RATE_BUFFER">TH_ENCCTL_SET_RATE_BUFFER</dfn> (22)</u></td></tr>
<tr><th id="222">222</th><td><i class="doc">/**Enable pass 1 of two-pass encoding mode and retrieve the first pass metrics.</i></td></tr>
<tr><th id="223">223</th><td><i class="doc"> * Pass 1 mode must be enabled before the first frame is encoded, and a target</i></td></tr>
<tr><th id="224">224</th><td><i class="doc"> *  bitrate must have already been specified to the encoder.</i></td></tr>
<tr><th id="225">225</th><td><i class="doc"> * Although this does not have to be the exact rate that will be used in the</i></td></tr>
<tr><th id="226">226</th><td><i class="doc"> *  second pass, closer values may produce better results.</i></td></tr>
<tr><th id="227">227</th><td><i class="doc"> * The first call returns the size of the two-pass header data, along with some</i></td></tr>
<tr><th id="228">228</th><td><i class="doc"> *  placeholder content, and sets the encoder into pass 1 mode implicitly.</i></td></tr>
<tr><th id="229">229</th><td><i class="doc"> * This call sets the encoder to pass 1 mode implicitly.</i></td></tr>
<tr><th id="230">230</th><td><i class="doc"> * Then, a subsequent call must be made after each call to</i></td></tr>
<tr><th id="231">231</th><td><i class="doc"> *  th_encode_ycbcr_in() to retrieve the metrics for that frame.</i></td></tr>
<tr><th id="232">232</th><td><i class="doc"> * An additional, final call must be made to retrieve the summary data,</i></td></tr>
<tr><th id="233">233</th><td><i class="doc"> *  containing such information as the total number of frames, etc.</i></td></tr>
<tr><th id="234">234</th><td><i class="doc"> * This must be stored in place of the placeholder data that was returned</i></td></tr>
<tr><th id="235">235</th><td><i class="doc"> *  in the first call, before the frame metrics data.</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> * All of this data must be presented back to the encoder during pass 2 using</i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> *  #TH_ENCCTL_2PASS_IN.</i></td></tr>
<tr><th id="238">238</th><td><i class="doc"> *</i></td></tr>
<tr><th id="239">239</th><td><i class="doc"> * <span class="command">\param</span>[out] <span class="tag">&lt;tt&gt;</span>char *<span class="tag">&lt;/tt&gt;</span>_buf: Returns a pointer to internal storage</i></td></tr>
<tr><th id="240">240</th><td><i class="doc"> *              containing the two pass metrics data.</i></td></tr>
<tr><th id="241">241</th><td><i class="doc"> *             This storage is only valid until the next call, or until the</i></td></tr>
<tr><th id="242">242</th><td><i class="doc"> *              encoder context is freed, and must be copied by the</i></td></tr>
<tr><th id="243">243</th><td><i class="doc"> *              application.</i></td></tr>
<tr><th id="244">244</th><td><i class="doc"> *<span class="command"> \retval</span> &gt;=0       The number of bytes of metric data available in the</i></td></tr>
<tr><th id="245">245</th><td><i class="doc"> *                    returned buffer.</i></td></tr>
<tr><th id="246">246</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="247">247</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL<span class="command"> \a</span> <span class="arg">_buf_sz</span> is not <span class="tag">&lt;tt&gt;</span>sizeof(char *)<span class="tag">&lt;/tt&gt;</span>, no target</i></td></tr>
<tr><th id="248">248</th><td><i class="doc"> *                    bitrate has been set, or the first call was made after</i></td></tr>
<tr><th id="249">249</th><td><i class="doc"> *                    the first frame was submitted for encoding.</i></td></tr>
<tr><th id="250">250</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL   Not supported by this implementation.*/</i></td></tr>
<tr><th id="251">251</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_2PASS_OUT" data-ref="_M/TH_ENCCTL_2PASS_OUT">TH_ENCCTL_2PASS_OUT</dfn> (24)</u></td></tr>
<tr><th id="252">252</th><td><i class="doc">/**Submits two-pass encoding metric data collected the first encoding pass to</i></td></tr>
<tr><th id="253">253</th><td><i class="doc"> *  the second pass.</i></td></tr>
<tr><th id="254">254</th><td><i class="doc"> * The first call must be made before the first frame is encoded, and a target</i></td></tr>
<tr><th id="255">255</th><td><i class="doc"> *  bitrate must have already been specified to the encoder.</i></td></tr>
<tr><th id="256">256</th><td><i class="doc"> * It sets the encoder to pass 2 mode implicitly; this cannot be disabled.</i></td></tr>
<tr><th id="257">257</th><td><i class="doc"> * The encoder may require reading data from some or all of the frames in</i></td></tr>
<tr><th id="258">258</th><td><i class="doc"> *  advance, depending on, e.g., the reservoir size used in the second pass.</i></td></tr>
<tr><th id="259">259</th><td><i class="doc"> * You must call this function repeatedly before each frame to provide data</i></td></tr>
<tr><th id="260">260</th><td><i class="doc"> *  until either a) it fails to consume all of the data presented or b) all of</i></td></tr>
<tr><th id="261">261</th><td><i class="doc"> *  the pass 1 data has been consumed.</i></td></tr>
<tr><th id="262">262</th><td><i class="doc"> * In the first case, you must save the remaining data to be presented after</i></td></tr>
<tr><th id="263">263</th><td><i class="doc"> *  the next frame.</i></td></tr>
<tr><th id="264">264</th><td><i class="doc"> * You can call this function with a NULL argument to get an upper bound on</i></td></tr>
<tr><th id="265">265</th><td><i class="doc"> *  the number of bytes that will be required before the next frame.</i></td></tr>
<tr><th id="266">266</th><td><i class="doc"> *</i></td></tr>
<tr><th id="267">267</th><td><i class="doc"> * When pass 2 is first enabled, the default bit reservoir is set to the entire</i></td></tr>
<tr><th id="268">268</th><td><i class="doc"> *  file; this gives maximum flexibility but can lead to very high peak rates.</i></td></tr>
<tr><th id="269">269</th><td><i class="doc"> * You can subsequently set it to another value with #TH_ENCCTL_SET_RATE_BUFFER</i></td></tr>
<tr><th id="270">270</th><td><i class="doc"> *  (e.g., to set it to the keyframe interval for non-live streaming), however,</i></td></tr>
<tr><th id="271">271</th><td><i class="doc"> *  you may then need to provide more data before the next frame.</i></td></tr>
<tr><th id="272">272</th><td><i class="doc"> *</i></td></tr>
<tr><th id="273">273</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>char[]<span class="tag">&lt;/tt&gt;</span>: A buffer containing the data returned by</i></td></tr>
<tr><th id="274">274</th><td><i class="doc"> *                  #TH_ENCCTL_2PASS_OUT in pass 1.</i></td></tr>
<tr><th id="275">275</th><td><i class="doc"> *                 You may pass <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span> for<span class="command"> \a</span> <span class="arg">_buf</span> to return an upper</i></td></tr>
<tr><th id="276">276</th><td><i class="doc"> *                  bound on the number of additional bytes needed before the</i></td></tr>
<tr><th id="277">277</th><td><i class="doc"> *                  next frame.</i></td></tr>
<tr><th id="278">278</th><td><i class="doc"> *                 The summary data returned at the end of pass 1 must be at</i></td></tr>
<tr><th id="279">279</th><td><i class="doc"> *                  the head of the buffer on the first call with a</i></td></tr>
<tr><th id="280">280</th><td><i class="doc"> *                  non-<span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span><span class="command"> \a</span> <span class="arg">_buf,</span> and the placeholder data</i></td></tr>
<tr><th id="281">281</th><td><i class="doc"> *                  returned at the start of pass 1 should be omitted.</i></td></tr>
<tr><th id="282">282</th><td><i class="doc"> *                 After each call you should advance this buffer by the number</i></td></tr>
<tr><th id="283">283</th><td><i class="doc"> *                  of bytes consumed.</i></td></tr>
<tr><th id="284">284</th><td><i class="doc"> *<span class="command"> \retval</span> &gt;0            The number of bytes of metric data required/consumed.</i></td></tr>
<tr><th id="285">285</th><td><i class="doc"> *<span class="command"> \retval</span> 0             No more data is required before the next frame.</i></td></tr>
<tr><th id="286">286</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT    <span class="command"> \a</span> <span class="arg">_enc_ctx</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="287">287</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL     No target bitrate has been set, or the first call was</i></td></tr>
<tr><th id="288">288</th><td><i class="doc"> *                        made after the first frame was submitted for</i></td></tr>
<tr><th id="289">289</th><td><i class="doc"> *                        encoding.</i></td></tr>
<tr><th id="290">290</th><td><i class="doc"> *<span class="command"> \retval</span> TH_ENOTFORMAT The data did not appear to be pass 1 from a compatible</i></td></tr>
<tr><th id="291">291</th><td><i class="doc"> *                        implementation of this library.</i></td></tr>
<tr><th id="292">292</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EBADHEADER The data was invalid; this may be returned when</i></td></tr>
<tr><th id="293">293</th><td><i class="doc"> *                        attempting to read an aborted pass 1 file that still</i></td></tr>
<tr><th id="294">294</th><td><i class="doc"> *                        has the placeholder data in place of the summary</i></td></tr>
<tr><th id="295">295</th><td><i class="doc"> *                        data.</i></td></tr>
<tr><th id="296">296</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL       Not supported by this implementation.*/</i></td></tr>
<tr><th id="297">297</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_2PASS_IN" data-ref="_M/TH_ENCCTL_2PASS_IN">TH_ENCCTL_2PASS_IN</dfn> (26)</u></td></tr>
<tr><th id="298">298</th><td><i class="doc">/**Sets the current encoding quality.</i></td></tr>
<tr><th id="299">299</th><td><i class="doc"> * This is only valid so long as no bitrate has been specified, either through</i></td></tr>
<tr><th id="300">300</th><td><i class="doc"> *  the #th_info struct used to initialize the encoder or through</i></td></tr>
<tr><th id="301">301</th><td><i class="doc"> *  #TH_ENCCTL_SET_BITRATE (this restriction may be relaxed in a future</i></td></tr>
<tr><th id="302">302</th><td><i class="doc"> *  version).</i></td></tr>
<tr><th id="303">303</th><td><i class="doc"> * If it is set before the headers are emitted, the target quality encoded in</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> *  them will be updated.</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> *</i></td></tr>
<tr><th id="306">306</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>int<span class="tag">&lt;/tt&gt;</span>: The new target quality, in the range 0...63,</i></td></tr>
<tr><th id="307">307</th><td><i class="doc"> *                  inclusive.</i></td></tr>
<tr><th id="308">308</th><td><i class="doc"> *<span class="command"> \retval</span> 0             Success.</i></td></tr>
<tr><th id="309">309</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT    <span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="310">310</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL     A target bitrate has already been specified, or the</i></td></tr>
<tr><th id="311">311</th><td><i class="doc"> *                        quality index was not in the range 0...63.</i></td></tr>
<tr><th id="312">312</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL       Not supported by this implementation.*/</i></td></tr>
<tr><th id="313">313</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_QUALITY" data-ref="_M/TH_ENCCTL_SET_QUALITY">TH_ENCCTL_SET_QUALITY</dfn> (28)</u></td></tr>
<tr><th id="314">314</th><td><i class="doc">/**Sets the current encoding bitrate.</i></td></tr>
<tr><th id="315">315</th><td><i class="doc"> * Once a bitrate is set, the encoder must use a rate-controlled mode for all</i></td></tr>
<tr><th id="316">316</th><td><i class="doc"> *  future frames (this restriction may be relaxed in a future version).</i></td></tr>
<tr><th id="317">317</th><td><i class="doc"> * If it is set before the headers are emitted, the target bitrate encoded in</i></td></tr>
<tr><th id="318">318</th><td><i class="doc"> *  them will be updated.</i></td></tr>
<tr><th id="319">319</th><td><i class="doc"> * Due to the buffer delay, the exact bitrate of each section of the encode is</i></td></tr>
<tr><th id="320">320</th><td><i class="doc"> *  not guaranteed.</i></td></tr>
<tr><th id="321">321</th><td><i class="doc"> * The encoder may have already used more bits than allowed for the frames it</i></td></tr>
<tr><th id="322">322</th><td><i class="doc"> *  has encoded, expecting to make them up in future frames, or it may have</i></td></tr>
<tr><th id="323">323</th><td><i class="doc"> *  used fewer, holding the excess in reserve.</i></td></tr>
<tr><th id="324">324</th><td><i class="doc"> * The exact transition between the two bitrates is not well-defined by this</i></td></tr>
<tr><th id="325">325</th><td><i class="doc"> *  API, but may be affected by flags set with #TH_ENCCTL_SET_RATE_FLAGS.</i></td></tr>
<tr><th id="326">326</th><td><i class="doc"> * After a number of frames equal to the buffer delay, one may expect further</i></td></tr>
<tr><th id="327">327</th><td><i class="doc"> *  output to average at the target bitrate.</i></td></tr>
<tr><th id="328">328</th><td><i class="doc"> *</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> * <span class="command">\param</span>[in] <span class="arg">_buf</span> <span class="tag">&lt;tt&gt;</span>long<span class="tag">&lt;/tt&gt;</span>: The new target bitrate, in bits per second.</i></td></tr>
<tr><th id="330">330</th><td><i class="doc"> *<span class="command"> \retval</span> 0             Success.</i></td></tr>
<tr><th id="331">331</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT    <span class="command"> \a</span> <span class="arg">_enc_ctx</span> or<span class="command"> \a</span> <span class="arg">_buf</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="332">332</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL     The target bitrate was not positive.</i></td></tr>
<tr><th id="333">333</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EIMPL       Not supported by this implementation.*/</i></td></tr>
<tr><th id="334">334</th><td><u>#define <dfn class="macro" id="_M/TH_ENCCTL_SET_BITRATE" data-ref="_M/TH_ENCCTL_SET_BITRATE">TH_ENCCTL_SET_BITRATE</dfn> (30)</u></td></tr>
<tr><th id="335">335</th><td></td></tr>
<tr><th id="336">336</th><td><i>/*@}*/</i></td></tr>
<tr><th id="337">337</th><td></td></tr>
<tr><th id="338">338</th><td></td></tr>
<tr><th id="339">339</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">TH_ENCCTL_SET_RATE_FLAGS flags</span></i></td></tr>
<tr><th id="340">340</th><td><i class="doc"> *<span class="command"> \anchor</span> ratectlflags</i></td></tr>
<tr><th id="341">341</th><td><i class="doc"> * These are the flags available for use with #TH_ENCCTL_SET_RATE_FLAGS.*/</i></td></tr>
<tr><th id="342">342</th><td><i>/*@{*/</i></td></tr>
<tr><th id="343">343</th><td><i class="doc">/**Drop frames to keep within bitrate buffer constraints.</i></td></tr>
<tr><th id="344">344</th><td><i class="doc"> * This can have a severe impact on quality, but is the only way to ensure that</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"> *  bitrate targets are met at low rates during sudden bursts of activity.*/</i></td></tr>
<tr><th id="346">346</th><td><u>#define <dfn class="macro" id="_M/TH_RATECTL_DROP_FRAMES" data-ref="_M/TH_RATECTL_DROP_FRAMES">TH_RATECTL_DROP_FRAMES</dfn>   (0x1)</u></td></tr>
<tr><th id="347">347</th><td><i class="doc">/**Ignore bitrate buffer overflows.</i></td></tr>
<tr><th id="348">348</th><td><i class="doc"> * If the encoder uses so few bits that the reservoir of available bits</i></td></tr>
<tr><th id="349">349</th><td><i class="doc"> *  overflows, ignore the excess.</i></td></tr>
<tr><th id="350">350</th><td><i class="doc"> * The encoder will not try to use these extra bits in future frames.</i></td></tr>
<tr><th id="351">351</th><td><i class="doc"> * At high rates this may cause the result to be undersized, but allows a</i></td></tr>
<tr><th id="352">352</th><td><i class="doc"> *  client to play the stream using a finite buffer; it should normally be</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"> *  enabled.*/</i></td></tr>
<tr><th id="354">354</th><td><u>#define <dfn class="macro" id="_M/TH_RATECTL_CAP_OVERFLOW" data-ref="_M/TH_RATECTL_CAP_OVERFLOW">TH_RATECTL_CAP_OVERFLOW</dfn>  (0x2)</u></td></tr>
<tr><th id="355">355</th><td><i class="doc">/**Ignore bitrate buffer underflows.</i></td></tr>
<tr><th id="356">356</th><td><i class="doc"> * If the encoder uses so many bits that the reservoir of available bits</i></td></tr>
<tr><th id="357">357</th><td><i class="doc"> *  underflows, ignore the deficit.</i></td></tr>
<tr><th id="358">358</th><td><i class="doc"> * The encoder will not try to make up these extra bits in future frames.</i></td></tr>
<tr><th id="359">359</th><td><i class="doc"> * At low rates this may cause the result to be oversized; it should normally</i></td></tr>
<tr><th id="360">360</th><td><i class="doc"> *  be disabled.*/</i></td></tr>
<tr><th id="361">361</th><td><u>#define <dfn class="macro" id="_M/TH_RATECTL_CAP_UNDERFLOW" data-ref="_M/TH_RATECTL_CAP_UNDERFLOW">TH_RATECTL_CAP_UNDERFLOW</dfn> (0x4)</u></td></tr>
<tr><th id="362">362</th><td><i>/*@}*/</i></td></tr>
<tr><th id="363">363</th><td></td></tr>
<tr><th id="364">364</th><td></td></tr>
<tr><th id="365">365</th><td></td></tr>
<tr><th id="366">366</th><td><i class="doc">/**The quantization parameters used by VP3.*/</i></td></tr>
<tr><th id="367">367</th><td><b>extern</b> <em>const</em> <a class="typedef" href="codec.h.html#th_quant_info" title='th_quant_info' data-type='struct th_quant_info' data-ref="th_quant_info">th_quant_info</a> <dfn class="decl" id="TH_VP31_QUANT_INFO" title='TH_VP31_QUANT_INFO' data-ref="TH_VP31_QUANT_INFO">TH_VP31_QUANT_INFO</dfn>;</td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td><i class="doc">/**The Huffman tables used by VP3.*/</i></td></tr>
<tr><th id="370">370</th><td><b>extern</b> <em>const</em> <a class="typedef" href="codec.h.html#th_huff_code" title='th_huff_code' data-type='struct th_huff_code' data-ref="th_huff_code">th_huff_code</a></td></tr>
<tr><th id="371">371</th><td> <dfn class="decl" id="TH_VP31_HUFF_CODES" title='TH_VP31_HUFF_CODES' data-ref="TH_VP31_HUFF_CODES">TH_VP31_HUFF_CODES</dfn>[<a class="macro" href="codec.h.html#423" title="(80)" data-ref="_M/TH_NHUFFMAN_TABLES">TH_NHUFFMAN_TABLES</a>][<a class="macro" href="codec.h.html#425" title="(32)" data-ref="_M/TH_NDCT_TOKENS">TH_NDCT_TOKENS</a>];</td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td></td></tr>
<tr><th id="374">374</th><td></td></tr>
<tr><th id="375">375</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">Encoder state</span></i></td></tr>
<tr><th id="376">376</th><td><i class="doc">   The following data structure is opaque, and its contents are not publicly</i></td></tr>
<tr><th id="377">377</th><td><i class="doc">    defined by this API.</i></td></tr>
<tr><th id="378">378</th><td><i class="doc">   Referring to its internals directly is unsupported, and may break without</i></td></tr>
<tr><th id="379">379</th><td><i class="doc">    warning.*/</i></td></tr>
<tr><th id="380">380</th><td><i>/*@{*/</i></td></tr>
<tr><th id="381">381</th><td><i class="doc">/**The encoder context.*/</i></td></tr>
<tr><th id="382">382</th><td><b>typedef</b> <b>struct</b> <dfn class="type" id="th_enc_ctx" title='th_enc_ctx' data-ref="th_enc_ctx"><a class="type" href="#th_enc_ctx" title='th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a></dfn>    <dfn class="typedef" id="th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</dfn>;</td></tr>
<tr><th id="383">383</th><td><i>/*@}*/</i></td></tr>
<tr><th id="384">384</th><td></td></tr>
<tr><th id="385">385</th><td></td></tr>
<tr><th id="386">386</th><td></td></tr>
<tr><th id="387">387</th><td><i class="doc">/**<span class="command">\defgroup</span> <span class="verb">encfuncs Functions for Encoding</span>*/</i></td></tr>
<tr><th id="388">388</th><td><i>/*@{*/</i></td></tr>
<tr><th id="389">389</th><td><i class="doc">/**<span class="command">\name</span> <span class="verb">Functions for encoding</span></i></td></tr>
<tr><th id="390">390</th><td><i class="doc"> * You must link to <span class="tag">&lt;tt&gt;</span>libtheoraenc<span class="tag">&lt;/tt&gt;</span> and <span class="tag">&lt;tt&gt;</span>libtheoradec<span class="tag">&lt;/tt&gt;</span></i></td></tr>
<tr><th id="391">391</th><td><i class="doc"> *  if you use any of the functions in this section.</i></td></tr>
<tr><th id="392">392</th><td><i class="doc"> *</i></td></tr>
<tr><th id="393">393</th><td><i class="doc"> * The functions are listed in the order they are used in a typical encode.</i></td></tr>
<tr><th id="394">394</th><td><i class="doc"> * The basic steps are:</i></td></tr>
<tr><th id="395">395</th><td><i class="doc"> * - Fill in a #th_info structure with details on the format of the video you</i></td></tr>
<tr><th id="396">396</th><td><i class="doc"> *    wish to encode.</i></td></tr>
<tr><th id="397">397</th><td><i class="doc"> * - Allocate a #th_enc_ctx handle with th_encode_alloc().</i></td></tr>
<tr><th id="398">398</th><td><i class="doc"> * - Perform any additional encoder configuration required with</i></td></tr>
<tr><th id="399">399</th><td><i class="doc"> *    th_encode_ctl().</i></td></tr>
<tr><th id="400">400</th><td><i class="doc"> * - Repeatedly call th_encode_flushheader() to retrieve all the header</i></td></tr>
<tr><th id="401">401</th><td><i class="doc"> *    packets.</i></td></tr>
<tr><th id="402">402</th><td><i class="doc"> * - For each uncompressed frame:</i></td></tr>
<tr><th id="403">403</th><td><i class="doc"> *   - Submit the uncompressed frame via th_encode_ycbcr_in()</i></td></tr>
<tr><th id="404">404</th><td><i class="doc"> *   - Repeatedly call th_encode_packetout() to retrieve any video data packets</i></td></tr>
<tr><th id="405">405</th><td><i class="doc"> *      that are ready.</i></td></tr>
<tr><th id="406">406</th><td><i class="doc"> * - Call th_encode_free() to release all encoder memory.*/</i></td></tr>
<tr><th id="407">407</th><td><i>/*@{*/</i></td></tr>
<tr><th id="408">408</th><td><i class="doc">/**Allocates an encoder instance.</i></td></tr>
<tr><th id="409">409</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_info</span> A #th_info struct filled with the desired encoding parameters.</i></td></tr>
<tr><th id="410">410</th><td><i class="doc"> * <span class="command">\return</span> The initialized #th_enc_ctx handle.</i></td></tr>
<tr><th id="411">411</th><td><i class="doc"> *<span class="command"> \retval</span> NULL If the encoding parameters were invalid.*/</i></td></tr>
<tr><th id="412">412</th><td><b>extern</b> <a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="decl" id="th_encode_alloc" title='th_encode_alloc' data-ref="th_encode_alloc">th_encode_alloc</dfn>(<em>const</em> <a class="typedef" href="codec.h.html#th_info" title='th_info' data-type='struct th_info' data-ref="th_info">th_info</a> *<dfn class="local col9 decl" id="139_info" title='_info' data-type='const th_info *' data-ref="139_info">_info</dfn>);</td></tr>
<tr><th id="413">413</th><td><i class="doc">/**Encoder control function.</i></td></tr>
<tr><th id="414">414</th><td><i class="doc"> * This is used to provide advanced control the encoding process.</i></td></tr>
<tr><th id="415">415</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_enc</span>    A #th_enc_ctx handle.</i></td></tr>
<tr><th id="416">416</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_req</span>    The control code to process.</i></td></tr>
<tr><th id="417">417</th><td><i class="doc"> *                See <span class="command">\ref</span> <span class="verb">encctlcodes "the list of available control codes"</span></i></td></tr>
<tr><th id="418">418</th><td><i class="doc"> *                 for details.</i></td></tr>
<tr><th id="419">419</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_buf</span>    The parameters for this control code.</i></td></tr>
<tr><th id="420">420</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_buf_sz</span> The size of the parameter buffer.*/</i></td></tr>
<tr><th id="421">421</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_encode_ctl" title='th_encode_ctl' data-ref="th_encode_ctl">th_encode_ctl</dfn>(<a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="local col0 decl" id="140_enc" title='_enc' data-type='th_enc_ctx *' data-ref="140_enc">_enc</dfn>,<em>int</em> <dfn class="local col1 decl" id="141_req" title='_req' data-type='int' data-ref="141_req">_req</dfn>,<em>void</em> *<dfn class="local col2 decl" id="142_buf" title='_buf' data-type='void *' data-ref="142_buf">_buf</dfn>,<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col3 decl" id="143_buf_sz" title='_buf_sz' data-type='size_t' data-ref="143_buf_sz">_buf_sz</dfn>);</td></tr>
<tr><th id="422">422</th><td><i class="doc">/**Outputs the next header packet.</i></td></tr>
<tr><th id="423">423</th><td><i class="doc"> * This should be called repeatedly after encoder initialization until it</i></td></tr>
<tr><th id="424">424</th><td><i class="doc"> *  returns 0 in order to get all of the header packets, in order, before</i></td></tr>
<tr><th id="425">425</th><td><i class="doc"> *  encoding actual video data.</i></td></tr>
<tr><th id="426">426</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_enc</span>      A #th_enc_ctx handle.</i></td></tr>
<tr><th id="427">427</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_comments</span> The metadata to place in the comment header, when it is</i></td></tr>
<tr><th id="428">428</th><td><i class="doc"> *                   encoded.</i></td></tr>
<tr><th id="429">429</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_op</span>       An <span class="tag">&lt;tt&gt;</span>ogg_packet<span class="tag">&lt;/tt&gt;</span> structure to fill.</i></td></tr>
<tr><th id="430">430</th><td><i class="doc"> *                  All of the elements of this structure will be set,</i></td></tr>
<tr><th id="431">431</th><td><i class="doc"> *                   including a pointer to the header data.</i></td></tr>
<tr><th id="432">432</th><td><i class="doc"> *                  The memory for the header data is owned by</i></td></tr>
<tr><th id="433">433</th><td><i class="doc"> *                   <span class="tag">&lt;tt&gt;</span>libtheoraenc<span class="tag">&lt;/tt&gt;</span>, and may be invalidated when the</i></td></tr>
<tr><th id="434">434</th><td><i class="doc"> *                   next encoder function is called.</i></td></tr>
<tr><th id="435">435</th><td><i class="doc"> * <span class="command">\return</span> A positive value indicates that a header packet was successfully</i></td></tr>
<tr><th id="436">436</th><td><i class="doc"> *          produced.</i></td></tr>
<tr><th id="437">437</th><td><i class="doc"> *<span class="command"> \retval</span> 0         No packet was produced, and no more header packets remain.</i></td></tr>
<tr><th id="438">438</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc,</span><span class="command"> \a</span> <span class="arg">_comments,</span> or<span class="command"> \a</span> <span class="arg">_op</span> was <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.*/</i></td></tr>
<tr><th id="439">439</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_encode_flushheader" title='th_encode_flushheader' data-ref="th_encode_flushheader">th_encode_flushheader</dfn>(<a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="local col4 decl" id="144_enc" title='_enc' data-type='th_enc_ctx *' data-ref="144_enc">_enc</dfn>,</td></tr>
<tr><th id="440">440</th><td> <a class="typedef" href="codec.h.html#th_comment" title='th_comment' data-type='struct th_comment' data-ref="th_comment">th_comment</a> *<dfn class="local col5 decl" id="145_comments" title='_comments' data-type='th_comment *' data-ref="145_comments">_comments</dfn>,<a class="typedef" href="../ogg/ogg.h.html#ogg_packet" title='ogg_packet' data-type='struct ogg_packet' data-ref="ogg_packet">ogg_packet</a> *<dfn class="local col6 decl" id="146_op" title='_op' data-type='ogg_packet *' data-ref="146_op">_op</dfn>);</td></tr>
<tr><th id="441">441</th><td><i class="doc">/**Submits an uncompressed frame to the encoder.</i></td></tr>
<tr><th id="442">442</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_enc</span>   A #th_enc_ctx handle.</i></td></tr>
<tr><th id="443">443</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_ycbcr</span> A buffer of Y'CbCr data to encode.</i></td></tr>
<tr><th id="444">444</th><td><i class="doc"> *<span class="command"> \retval</span> 0         Success.</i></td></tr>
<tr><th id="445">445</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc</span> or<span class="command"> \a</span> <span class="arg">_ycbcr</span> is <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.</i></td></tr>
<tr><th id="446">446</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EINVAL The buffer size does not match the frame size the encoder</i></td></tr>
<tr><th id="447">447</th><td><i class="doc"> *                    was initialized with, or encoding has already</i></td></tr>
<tr><th id="448">448</th><td><i class="doc"> *                    completed.*/</i></td></tr>
<tr><th id="449">449</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_encode_ycbcr_in" title='th_encode_ycbcr_in' data-ref="th_encode_ycbcr_in">th_encode_ycbcr_in</dfn>(<a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="local col7 decl" id="147_enc" title='_enc' data-type='th_enc_ctx *' data-ref="147_enc">_enc</dfn>,<a class="typedef" href="codec.h.html#th_ycbcr_buffer" title='th_ycbcr_buffer' data-type='th_img_plane [3]' data-ref="th_ycbcr_buffer">th_ycbcr_buffer</a> <dfn class="local col8 decl" id="148_ycbcr" title='_ycbcr' data-type='th_img_plane *' data-ref="148_ycbcr">_ycbcr</dfn>);</td></tr>
<tr><th id="450">450</th><td><i class="doc">/**Retrieves encoded video data packets.</i></td></tr>
<tr><th id="451">451</th><td><i class="doc"> * This should be called repeatedly after each frame is submitted to flush any</i></td></tr>
<tr><th id="452">452</th><td><i class="doc"> *  encoded packets, until it returns 0.</i></td></tr>
<tr><th id="453">453</th><td><i class="doc"> * The encoder will not buffer these packets as subsequent frames are</i></td></tr>
<tr><th id="454">454</th><td><i class="doc"> *  compressed, so a failure to do so will result in lost video data.</i></td></tr>
<tr><th id="455">455</th><td><i class="doc"> * <span class="command">\note</span> Currently the encoder operates in a one-frame-in, one-packet-out</i></td></tr>
<tr><th id="456">456</th><td><i class="doc"> *        manner.</i></td></tr>
<tr><th id="457">457</th><td><i class="doc"> *       However, this may be changed in the future.</i></td></tr>
<tr><th id="458">458</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_enc</span>  A #th_enc_ctx handle.</i></td></tr>
<tr><th id="459">459</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_last</span> Set this flag to a non-zero value if no more uncompressed</i></td></tr>
<tr><th id="460">460</th><td><i class="doc"> *               frames will be submitted.</i></td></tr>
<tr><th id="461">461</th><td><i class="doc"> *              This ensures that a proper EOS flag is set on the last packet.</i></td></tr>
<tr><th id="462">462</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_op</span>   An <span class="tag">&lt;tt&gt;</span>ogg_packet<span class="tag">&lt;/tt&gt;</span> structure to fill.</i></td></tr>
<tr><th id="463">463</th><td><i class="doc"> *              All of the elements of this structure will be set, including a</i></td></tr>
<tr><th id="464">464</th><td><i class="doc"> *               pointer to the video data.</i></td></tr>
<tr><th id="465">465</th><td><i class="doc"> *              The memory for the video data is owned by</i></td></tr>
<tr><th id="466">466</th><td><i class="doc"> *               <span class="tag">&lt;tt&gt;</span>libtheoraenc<span class="tag">&lt;/tt&gt;</span>, and may be invalidated when the next</i></td></tr>
<tr><th id="467">467</th><td><i class="doc"> *               encoder function is called.</i></td></tr>
<tr><th id="468">468</th><td><i class="doc"> * <span class="command">\return</span> A positive value indicates that a video data packet was successfully</i></td></tr>
<tr><th id="469">469</th><td><i class="doc"> *          produced.</i></td></tr>
<tr><th id="470">470</th><td><i class="doc"> *<span class="command"> \retval</span> 0         No packet was produced, and no more encoded video data</i></td></tr>
<tr><th id="471">471</th><td><i class="doc"> *                    remains.</i></td></tr>
<tr><th id="472">472</th><td><i class="doc"> *<span class="command"> \retval</span> TH_EFAULT<span class="command"> \a</span> <span class="arg">_enc</span> or<span class="command"> \a</span> <span class="arg">_op</span> was <span class="tag">&lt;tt&gt;</span>NULL<span class="tag">&lt;/tt&gt;</span>.*/</i></td></tr>
<tr><th id="473">473</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="th_encode_packetout" title='th_encode_packetout' data-ref="th_encode_packetout">th_encode_packetout</dfn>(<a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="local col9 decl" id="149_enc" title='_enc' data-type='th_enc_ctx *' data-ref="149_enc">_enc</dfn>,<em>int</em> <dfn class="local col0 decl" id="150_last" title='_last' data-type='int' data-ref="150_last">_last</dfn>,<a class="typedef" href="../ogg/ogg.h.html#ogg_packet" title='ogg_packet' data-type='struct ogg_packet' data-ref="ogg_packet">ogg_packet</a> *<dfn class="local col1 decl" id="151_op" title='_op' data-type='ogg_packet *' data-ref="151_op">_op</dfn>);</td></tr>
<tr><th id="474">474</th><td><i class="doc">/**Frees an allocated encoder instance.</i></td></tr>
<tr><th id="475">475</th><td><i class="doc"> * <span class="command">\param</span> <span class="arg">_enc</span> A #th_enc_ctx handle.*/</i></td></tr>
<tr><th id="476">476</th><td><b>extern</b> <em>void</em> <dfn class="decl" id="th_encode_free" title='th_encode_free' data-ref="th_encode_free">th_encode_free</dfn>(<a class="typedef" href="#th_enc_ctx" title='th_enc_ctx' data-type='struct th_enc_ctx' data-ref="th_enc_ctx">th_enc_ctx</a> *<dfn class="local col2 decl" id="152_enc" title='_enc' data-type='th_enc_ctx *' data-ref="152_enc">_enc</dfn>);</td></tr>
<tr><th id="477">477</th><td><i>/*@}*/</i></td></tr>
<tr><th id="478">478</th><td><i>/*@}*/</i></td></tr>
<tr><th id="479">479</th><td></td></tr>
<tr><th id="480">480</th><td></td></tr>
<tr><th id="481">481</th><td></td></tr>
<tr><th id="482">482</th><td><u>#<span data-ppcond="482">if</span> defined(<span class="macro" data-ref="_M/__cplusplus">__cplusplus</span>)</u></td></tr>
<tr><th id="483">483</th><td>}</td></tr>
<tr><th id="484">484</th><td><u>#<span data-ppcond="482">endif</span></u></td></tr>
<tr><th id="485">485</th><td></td></tr>
<tr><th id="486">486</th><td><u>#<span data-ppcond="21">endif</span></u></td></tr>
<tr><th id="487">487</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../ffmpeg/libavcodec/libtheoraenc.c.html'>ffmpeg/libavcodec/libtheoraenc.c</a><br/>Generated on <em>2016-Oct-25</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
