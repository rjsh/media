<dec f='ffmpeg/libavformat/avio.h' l='588' type='int avio_get_str(AVIOContext * pb, int maxlen, char * buf, int buflen)'/>
<doc f='ffmpeg/libavformat/avio.h' l='576'>/**
 * Read a string from pb into buf. The reading will terminate when either
 * a NULL character was encountered, maxlen bytes have been read, or nothing
 * more can be read from pb. The result is guaranteed to be NULL-terminated, it
 * will be truncated if buf is too small.
 * Note that the string is not interpreted or validated in any way, it
 * might get truncated in the middle of a sequence for multi-byte encodings.
 *
 * @return number of bytes read (is always &lt;= maxlen).
 * If reading ends on EOF or error, the return value will be one more than
 * bytes actually read.
 */</doc>
<use f='ffmpeg/libavformat/apetag.c' l='70' u='c' c='ape_tag_read_field'/>
<def f='ffmpeg/libavformat/aviobuf.c' l='782' type='int avio_get_str(AVIOContext * s, int maxlen, char * buf, int buflen)'/>
<use f='ffmpeg/libavformat/cafdec.c' l='223' u='c' c='read_info_chunk'/>
<use f='ffmpeg/libavformat/cafdec.c' l='224' u='c' c='read_info_chunk'/>
<use f='ffmpeg/libavformat/cinedec.c' l='252' u='c' c='cine_read_header'/>
<use f='ffmpeg/libavformat/ffmdec.c' l='396' u='c' c='ffm2_read_header'/>
<use f='ffmpeg/libavformat/ffmdec.c' l='450' u='c' c='ffm2_read_header'/>
<use f='ffmpeg/libavformat/ffmdec.c' l='465' u='c' c='ffm2_read_header'/>
<use f='ffmpeg/libavformat/ffmdec.c' l='480' u='c' c='ffm2_read_header'/>
<use f='ffmpeg/libavformat/ffmdec.c' l='596' u='c' c='ffm_read_header'/>
<use f='ffmpeg/libavformat/id3v2.c' l='612' u='c' c='read_apic'/>
<use f='ffmpeg/libavformat/mov.c' l='239' u='c' c='mov_metadata_loci'/>
<use f='ffmpeg/libavformat/mov.c' l='5156' u='c' c='mov_read_chapters'/>
<use f='ffmpeg/libavformat/mpeg.c' l='147' u='c' c='mpegps_read_header'/>
<use f='ffmpeg/libavformat/mvdec.c' l='68' u='c' c='var_read_string'/>
<use f='ffmpeg/libavformat/rmdec.c' l='1230' u='c' c='ivr_read_header'/>
<use f='ffmpeg/libavformat/rmdec.c' l='1233' u='c' c='ivr_read_header'/>
<use f='ffmpeg/libavformat/rmdec.c' l='1269' u='c' c='ivr_read_header'/>
<use f='ffmpeg/libavformat/rmdec.c' l='1272' u='c' c='ivr_read_header'/>
<dec f='include/libavformat/avio.h' l='274' type='int avio_get_str(AVIOContext * pb, int maxlen, char * buf, int buflen)'/>
<doc f='include/libavformat/avio.h' l='262'>/**
 * Read a string from pb into buf. The reading will terminate when either
 * a NULL character was encountered, maxlen bytes have been read, or nothing
 * more can be read from pb. The result is guaranteed to be NULL-terminated, it
 * will be truncated if buf is too small.
 * Note that the string is not interpreted or validated in any way, it
 * might get truncated in the middle of a sequence for multi-byte encodings.
 *
 * @return number of bytes read (is always &lt;= maxlen).
 * If reading ends on EOF or error, the return value will be one more than
 * bytes actually read.
 */</doc>
