<dec f='ffmpeg/libavutil/eval.h' l='111' type='double av_strtod(const char * numstr, char ** tail)'/>
<doc f='ffmpeg/libavutil/eval.h' l='94'>/**
 * Parse the string in numstr and return its value as a double. If
 * the string is empty, contains only whitespaces, or does not contain
 * an initial substring that has the expected syntax for a
 * floating-point number, no conversion is performed. In this case,
 * returns a value of zero and the value returned in tail is the value
 * of numstr.
 *
 * @param numstr a string representing a number, may contain one of
 * the International System number postfixes, for example &apos;K&apos;, &apos;M&apos;,
 * &apos;G&apos;. If &apos;i&apos; is appended after the postfix, powers of 2 are used
 * instead of powers of 10. The &apos;B&apos; postfix multiplies the value by
 * 8, and can be appended after another postfix or used alone. This
 * allows using for example &apos;KB&apos;, &apos;MiB&apos;, &apos;G&apos; and &apos;B&apos; as postfix.
 * @param tail if non-NULL puts here the pointer to the char next
 * after the last parsed character
 */</doc>
<use f='ffmpeg/libavfilter/af_atempo.c' l='327' u='c' c='yae_set_tempo'/>
<use f='ffmpeg/libavfilter/formats.c' l='653' u='c' c='ff_parse_sample_rate'/>
<use f='ffmpeg/libavfilter/vf_curves.c' l='164' u='c' c='parse_points_str'/>
<use f='ffmpeg/libavfilter/vf_curves.c' l='165' u='c' c='parse_points_str'/>
<use f='ffmpeg/cmdutils.c' l='142' u='c' c='parse_number_or_die'/>
<use f='ffmpeg/cmdutils.c' l='2088' u='c' c='get_rotation'/>
<use f='ffmpeg/libavcodec/libx264.c' l='576' u='c' c='X264_init'/>
<use f='ffmpeg/libavformat/mvdec.c' l='91' u='c' c='var_read_float'/>
<def f='ffmpeg/libavutil/eval.c' l='98' type='double av_strtod(const char * numstr, char ** tail)'/>
<use f='ffmpeg/libavutil/eval.c' l='338' u='c' c='parse_primary'/>
