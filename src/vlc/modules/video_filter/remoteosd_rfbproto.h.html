<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>remoteosd_rfbproto.h source code [vlc/modules/video_filter/remoteosd_rfbproto.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'vlc/modules/video_filter/remoteosd_rfbproto.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>vlc</a>/<a href='..'>modules</a>/<a href='./'>video_filter</a>/<a href='remoteosd_rfbproto.h.html'>remoteosd_rfbproto.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> *  Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.</i></td></tr>
<tr><th id="3">3</th><td><i> *  Copyright (C) 1999 AT&amp;T Laboratories Cambridge.  All Rights Reserved.</i></td></tr>
<tr><th id="4">4</th><td><i> *</i></td></tr>
<tr><th id="5">5</th><td><i> *  This is free software; you can redistribute it and/or modify</i></td></tr>
<tr><th id="6">6</th><td><i> *  it under the terms of the GNU General Public License as published by</i></td></tr>
<tr><th id="7">7</th><td><i> *  the Free Software Foundation; either version 2 of the License, or</i></td></tr>
<tr><th id="8">8</th><td><i> *  (at your option) any later version.</i></td></tr>
<tr><th id="9">9</th><td><i> *</i></td></tr>
<tr><th id="10">10</th><td><i> *  This software is distributed in the hope that it will be useful,</i></td></tr>
<tr><th id="11">11</th><td><i> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</i></td></tr>
<tr><th id="12">12</th><td><i> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</i></td></tr>
<tr><th id="13">13</th><td><i> *  GNU General Public License for more details.</i></td></tr>
<tr><th id="14">14</th><td><i> *</i></td></tr>
<tr><th id="15">15</th><td><i> *  You should have received a copy of the GNU General Public License</i></td></tr>
<tr><th id="16">16</th><td><i> *  along with this software; if not, write to the Free Software</i></td></tr>
<tr><th id="17">17</th><td><i> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,</i></td></tr>
<tr><th id="18">18</th><td><i> *  USA.</i></td></tr>
<tr><th id="19">19</th><td><i> */</i></td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><i>/*</i></td></tr>
<tr><th id="22">22</th><td><i> * rfbproto.h - header file for the RFB protocol version 3.3</i></td></tr>
<tr><th id="23">23</th><td><i> *</i></td></tr>
<tr><th id="24">24</th><td><i> * Uses types CARD&lt;n&gt; for an n-bit unsigned integer, INT&lt;n&gt; for an n-bit signed</i></td></tr>
<tr><th id="25">25</th><td><i> * integer (for n = 8, 16 and 32).</i></td></tr>
<tr><th id="26">26</th><td><i> *</i></td></tr>
<tr><th id="27">27</th><td><i> * All multiple byte integers are in big endian (network) order (most</i></td></tr>
<tr><th id="28">28</th><td><i> * significant byte first).  Unless noted otherwise there is no special</i></td></tr>
<tr><th id="29">29</th><td><i> * alignment of protocol structures.</i></td></tr>
<tr><th id="30">30</th><td><i> *</i></td></tr>
<tr><th id="31">31</th><td><i> *</i></td></tr>
<tr><th id="32">32</th><td><i> * Once the initial handshaking is done, all messages start with a type byte,</i></td></tr>
<tr><th id="33">33</th><td><i> * (usually) followed by message-specific data.  The order of definitions in</i></td></tr>
<tr><th id="34">34</th><td><i> * this file is as follows:</i></td></tr>
<tr><th id="35">35</th><td><i> *</i></td></tr>
<tr><th id="36">36</th><td><i> *  (1) Structures used in several types of message.</i></td></tr>
<tr><th id="37">37</th><td><i> *  (2) Structures used in the initial handshaking.</i></td></tr>
<tr><th id="38">38</th><td><i> *  (3) Message types.</i></td></tr>
<tr><th id="39">39</th><td><i> *  (4) Encoding types.</i></td></tr>
<tr><th id="40">40</th><td><i> *  (5) For each message type, the form of the data following the type byte.</i></td></tr>
<tr><th id="41">41</th><td><i> *      Sometimes this is defined by a single structure but the more complex</i></td></tr>
<tr><th id="42">42</th><td><i> *      messages have to be explained by comments.</i></td></tr>
<tr><th id="43">43</th><td><i> */</i></td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="46">46</th><td><i> *</i></td></tr>
<tr><th id="47">47</th><td><i> * Structures used in several messages</i></td></tr>
<tr><th id="48">48</th><td><i> *</i></td></tr>
<tr><th id="49">49</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="50">50</th><td></td></tr>
<tr><th id="51">51</th><td><u>#include <a href="../../../include/inttypes.h.html">"inttypes.h"</a></u></td></tr>
<tr><th id="52">52</th><td><u>#define <dfn class="macro" id="_M/CARD8" data-ref="_M/CARD8">CARD8</dfn>  <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a></u></td></tr>
<tr><th id="53">53</th><td><u>#define <dfn class="macro" id="_M/CARD16" data-ref="_M/CARD16">CARD16</dfn> <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a></u></td></tr>
<tr><th id="54">54</th><td><u>#define <dfn class="macro" id="_M/CARD32" data-ref="_M/CARD32">CARD32</dfn> <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a></u></td></tr>
<tr><th id="55">55</th><td></td></tr>
<tr><th id="56">56</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="57">57</th><td><i> * Structure used to specify a rectangle.  This structure is a multiple of 4</i></td></tr>
<tr><th id="58">58</th><td><i> * bytes so that it can be interspersed with 32-bit pixel data without</i></td></tr>
<tr><th id="59">59</th><td><i> * affecting alignment.</i></td></tr>
<tr><th id="60">60</th><td><i> */</i></td></tr>
<tr><th id="61">61</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="62">62</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::x" title='&lt;anonymous struct&gt;::x' data-ref="{anonymous}::x">x</dfn>;</td></tr>
<tr><th id="63">63</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::y" title='&lt;anonymous struct&gt;::y' data-ref="{anonymous}::y">y</dfn>;</td></tr>
<tr><th id="64">64</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::w" title='&lt;anonymous struct&gt;::w' data-ref="{anonymous}::w">w</dfn>;</td></tr>
<tr><th id="65">65</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::h" title='&lt;anonymous struct&gt;::h' data-ref="{anonymous}::h">h</dfn>;</td></tr>
<tr><th id="66">66</th><td>} <dfn class="typedef" id="rfbRectangle" title='rfbRectangle' data-type='struct rfbRectangle' data-ref="rfbRectangle">rfbRectangle</dfn>;</td></tr>
<tr><th id="67">67</th><td></td></tr>
<tr><th id="68">68</th><td><u>#define <dfn class="macro" id="_M/sz_rfbRectangle" data-ref="_M/sz_rfbRectangle">sz_rfbRectangle</dfn> 8</u></td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="72">72</th><td><i> * Structure used to specify pixel format.</i></td></tr>
<tr><th id="73">73</th><td><i> */</i></td></tr>
<tr><th id="74">74</th><td></td></tr>
<tr><th id="75">75</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::bitsPerPixel" title='&lt;anonymous struct&gt;::bitsPerPixel' data-ref="{anonymous}::bitsPerPixel">bitsPerPixel</dfn>;		<i>/* 8,16,32 only */</i></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::depth" title='&lt;anonymous struct&gt;::depth' data-ref="{anonymous}::depth">depth</dfn>;		<i>/* 8 to 32 */</i></td></tr>
<tr><th id="80">80</th><td></td></tr>
<tr><th id="81">81</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::bigEndian" title='&lt;anonymous struct&gt;::bigEndian' data-ref="{anonymous}::bigEndian">bigEndian</dfn>;		<i>/* True if multi-byte pixels are interpreted</i></td></tr>
<tr><th id="82">82</th><td><i>				   as big endian, or if single-bit-per-pixel</i></td></tr>
<tr><th id="83">83</th><td><i>				   has most significant bit of the byte</i></td></tr>
<tr><th id="84">84</th><td><i>				   corresponding to first (leftmost) pixel. Of</i></td></tr>
<tr><th id="85">85</th><td><i>				   course this is meaningless for 8 bits/pix */</i></td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::trueColour" title='&lt;anonymous struct&gt;::trueColour' data-ref="{anonymous}::trueColour">trueColour</dfn>;		<i>/* If false then we need a "colour map" to</i></td></tr>
<tr><th id="88">88</th><td><i>				   convert pixels to RGB.  If true, xxxMax and</i></td></tr>
<tr><th id="89">89</th><td><i>				   xxxShift specify bits used for red, green</i></td></tr>
<tr><th id="90">90</th><td><i>				   and blue */</i></td></tr>
<tr><th id="91">91</th><td></td></tr>
<tr><th id="92">92</th><td>    <i>/* the following fields are only meaningful if trueColour is true */</i></td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::redMax" title='&lt;anonymous struct&gt;::redMax' data-ref="{anonymous}::redMax">redMax</dfn>;		<i>/* maximum red value (= 2^n - 1 where n is the</i></td></tr>
<tr><th id="95">95</th><td><i>				   number of bits used for red). Note this</i></td></tr>
<tr><th id="96">96</th><td><i>				   value is always in big endian order. */</i></td></tr>
<tr><th id="97">97</th><td></td></tr>
<tr><th id="98">98</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::greenMax" title='&lt;anonymous struct&gt;::greenMax' data-ref="{anonymous}::greenMax">greenMax</dfn>;		<i>/* similar for green */</i></td></tr>
<tr><th id="99">99</th><td></td></tr>
<tr><th id="100">100</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::blueMax" title='&lt;anonymous struct&gt;::blueMax' data-ref="{anonymous}::blueMax">blueMax</dfn>;		<i>/* and blue */</i></td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::redShift" title='&lt;anonymous struct&gt;::redShift' data-ref="{anonymous}::redShift">redShift</dfn>;		<i>/* number of shifts needed to get the red</i></td></tr>
<tr><th id="103">103</th><td><i>				   value in a pixel to the least significant</i></td></tr>
<tr><th id="104">104</th><td><i>				   bit. To find the red value from a given</i></td></tr>
<tr><th id="105">105</th><td><i>				   pixel, do the following:</i></td></tr>
<tr><th id="106">106</th><td><i>				   1) Swap pixel value according to bigEndian</i></td></tr>
<tr><th id="107">107</th><td><i>				      (e.g. if bigEndian is false and host byte</i></td></tr>
<tr><th id="108">108</th><td><i>				      order is big endian, then swap).</i></td></tr>
<tr><th id="109">109</th><td><i>				   2) Shift right by redShift.</i></td></tr>
<tr><th id="110">110</th><td><i>				   3) AND with redMax (in host byte order).</i></td></tr>
<tr><th id="111">111</th><td><i>				   4) You now have the red value between 0 and</i></td></tr>
<tr><th id="112">112</th><td><i>				      redMax. */</i></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::greenShift" title='&lt;anonymous struct&gt;::greenShift' data-ref="{anonymous}::greenShift">greenShift</dfn>;		<i>/* similar for green */</i></td></tr>
<tr><th id="115">115</th><td></td></tr>
<tr><th id="116">116</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::blueShift" title='&lt;anonymous struct&gt;::blueShift' data-ref="{anonymous}::blueShift">blueShift</dfn>;		<i>/* and blue */</i></td></tr>
<tr><th id="117">117</th><td></td></tr>
<tr><th id="118">118</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad1" title='&lt;anonymous struct&gt;::pad1' data-ref="{anonymous}::pad1">pad1</dfn>;</td></tr>
<tr><th id="119">119</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td>} <dfn class="typedef" id="rfbPixelFormat" title='rfbPixelFormat' data-type='struct rfbPixelFormat' data-ref="rfbPixelFormat">rfbPixelFormat</dfn>;</td></tr>
<tr><th id="122">122</th><td></td></tr>
<tr><th id="123">123</th><td><u>#define <dfn class="macro" id="_M/sz_rfbPixelFormat" data-ref="_M/sz_rfbPixelFormat">sz_rfbPixelFormat</dfn> 16</u></td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td></td></tr>
<tr><th id="126">126</th><td></td></tr>
<tr><th id="127">127</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="128">128</th><td><i> *</i></td></tr>
<tr><th id="129">129</th><td><i> * Initial handshaking messages</i></td></tr>
<tr><th id="130">130</th><td><i> *</i></td></tr>
<tr><th id="131">131</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="134">134</th><td><i> * Protocol Version</i></td></tr>
<tr><th id="135">135</th><td><i> *</i></td></tr>
<tr><th id="136">136</th><td><i> * The server always sends 12 bytes to start which identifies the latest RFB</i></td></tr>
<tr><th id="137">137</th><td><i> * protocol version number which it supports.  These bytes are interpreted</i></td></tr>
<tr><th id="138">138</th><td><i> * as a string of 12 ASCII characters in the format "RFB xxx.yyy\n" where</i></td></tr>
<tr><th id="139">139</th><td><i> * xxx and yyy are the major and minor version numbers (for version 3.3</i></td></tr>
<tr><th id="140">140</th><td><i> * this is "RFB 003.003\n").</i></td></tr>
<tr><th id="141">141</th><td><i> *</i></td></tr>
<tr><th id="142">142</th><td><i> * The client then replies with a similar 12-byte message giving the version</i></td></tr>
<tr><th id="143">143</th><td><i> * number of the protocol which should actually be used (which may be different</i></td></tr>
<tr><th id="144">144</th><td><i> * to that quoted by the server).</i></td></tr>
<tr><th id="145">145</th><td><i> *</i></td></tr>
<tr><th id="146">146</th><td><i> * It is intended that both clients and servers may provide some level of</i></td></tr>
<tr><th id="147">147</th><td><i> * backwards compatibility by this mechanism.  Servers in particular should</i></td></tr>
<tr><th id="148">148</th><td><i> * attempt to provide backwards compatibility, and even forwards compatibility</i></td></tr>
<tr><th id="149">149</th><td><i> * to some extent.  For example if a client demands version 3.1 of the</i></td></tr>
<tr><th id="150">150</th><td><i> * protocol, a 3.0 server can probably assume that by ignoring requests for</i></td></tr>
<tr><th id="151">151</th><td><i> * encoding types it doesn't understand, everything will still work OK.  This</i></td></tr>
<tr><th id="152">152</th><td><i> * will probably not be the case for changes in the major version number.</i></td></tr>
<tr><th id="153">153</th><td><i> *</i></td></tr>
<tr><th id="154">154</th><td><i> * The format string below can be used in sprintf or sscanf to generate or</i></td></tr>
<tr><th id="155">155</th><td><i> * decode the version string respectively.</i></td></tr>
<tr><th id="156">156</th><td><i> */</i></td></tr>
<tr><th id="157">157</th><td></td></tr>
<tr><th id="158">158</th><td><u>#define <dfn class="macro" id="_M/rfbProtocolVersionFormat" data-ref="_M/rfbProtocolVersionFormat">rfbProtocolVersionFormat</dfn> "RFB %03d.%03d\n"</u></td></tr>
<tr><th id="159">159</th><td><u>#define <dfn class="macro" id="_M/rfbProtocolMajorVersion" data-ref="_M/rfbProtocolMajorVersion">rfbProtocolMajorVersion</dfn> 3</u></td></tr>
<tr><th id="160">160</th><td><u>#define <dfn class="macro" id="_M/rfbProtocolMinorVersion" data-ref="_M/rfbProtocolMinorVersion">rfbProtocolMinorVersion</dfn> 3</u></td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><b>typedef</b> <em>char</em> <dfn class="typedef" id="rfbProtocolVersionMsg" title='rfbProtocolVersionMsg' data-type='char [13]' data-ref="rfbProtocolVersionMsg">rfbProtocolVersionMsg</dfn>[<var>13</var>];	<i>/* allow extra byte for null */</i></td></tr>
<tr><th id="163">163</th><td></td></tr>
<tr><th id="164">164</th><td><u>#define <dfn class="macro" id="_M/sz_rfbProtocolVersionMsg" data-ref="_M/sz_rfbProtocolVersionMsg">sz_rfbProtocolVersionMsg</dfn> 12</u></td></tr>
<tr><th id="165">165</th><td></td></tr>
<tr><th id="166">166</th><td></td></tr>
<tr><th id="167">167</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="168">168</th><td><i> * Authentication</i></td></tr>
<tr><th id="169">169</th><td><i> *</i></td></tr>
<tr><th id="170">170</th><td><i> * Once the protocol version has been decided, the server then sends a 32-bit</i></td></tr>
<tr><th id="171">171</th><td><i> * word indicating whether any authentication is needed on the connection.</i></td></tr>
<tr><th id="172">172</th><td><i> * The value of this word determines the authentication scheme in use.  For</i></td></tr>
<tr><th id="173">173</th><td><i> * version 3.0 of the protocol this may have one of the following values:</i></td></tr>
<tr><th id="174">174</th><td><i> */</i></td></tr>
<tr><th id="175">175</th><td></td></tr>
<tr><th id="176">176</th><td><u>#define <dfn class="macro" id="_M/rfbConnFailed" data-ref="_M/rfbConnFailed">rfbConnFailed</dfn> 0</u></td></tr>
<tr><th id="177">177</th><td><u>#define <dfn class="macro" id="_M/rfbNoAuth" data-ref="_M/rfbNoAuth">rfbNoAuth</dfn> 1</u></td></tr>
<tr><th id="178">178</th><td><u>#define <dfn class="macro" id="_M/rfbVncAuth" data-ref="_M/rfbVncAuth">rfbVncAuth</dfn> 2</u></td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><i>/*</i></td></tr>
<tr><th id="181">181</th><td><i> * rfbConnFailed:	For some reason the connection failed (e.g. the server</i></td></tr>
<tr><th id="182">182</th><td><i> *			cannot support the desired protocol version).  This is</i></td></tr>
<tr><th id="183">183</th><td><i> *			followed by a string describing the reason (where a</i></td></tr>
<tr><th id="184">184</th><td><i> *			string is specified as a 32-bit length followed by that</i></td></tr>
<tr><th id="185">185</th><td><i> *			many ASCII characters).</i></td></tr>
<tr><th id="186">186</th><td><i> *</i></td></tr>
<tr><th id="187">187</th><td><i> * rfbNoAuth:		No authentication is needed.</i></td></tr>
<tr><th id="188">188</th><td><i> *</i></td></tr>
<tr><th id="189">189</th><td><i> * rfbVncAuth:		The VNC authentication scheme is to be used.  A 16-byte</i></td></tr>
<tr><th id="190">190</th><td><i> *			challenge follows, which the client encrypts as</i></td></tr>
<tr><th id="191">191</th><td><i> *			appropriate using the password and sends the resulting</i></td></tr>
<tr><th id="192">192</th><td><i> *			16-byte response.  If the response is correct, the</i></td></tr>
<tr><th id="193">193</th><td><i> *			server sends the 32-bit word rfbVncAuthOK.  If a simple</i></td></tr>
<tr><th id="194">194</th><td><i> *			failure happens, the server sends rfbVncAuthFailed and</i></td></tr>
<tr><th id="195">195</th><td><i> *			closes the connection. If the server decides that too</i></td></tr>
<tr><th id="196">196</th><td><i> *			many failures have occurred, it sends rfbVncAuthTooMany</i></td></tr>
<tr><th id="197">197</th><td><i> *			and closes the connection.  In the latter case, the</i></td></tr>
<tr><th id="198">198</th><td><i> *			server should not allow an immediate reconnection by</i></td></tr>
<tr><th id="199">199</th><td><i> *			the client.</i></td></tr>
<tr><th id="200">200</th><td><i> */</i></td></tr>
<tr><th id="201">201</th><td></td></tr>
<tr><th id="202">202</th><td><u>#define <dfn class="macro" id="_M/rfbVncAuthOK" data-ref="_M/rfbVncAuthOK">rfbVncAuthOK</dfn> 0</u></td></tr>
<tr><th id="203">203</th><td><u>#define <dfn class="macro" id="_M/rfbVncAuthFailed" data-ref="_M/rfbVncAuthFailed">rfbVncAuthFailed</dfn> 1</u></td></tr>
<tr><th id="204">204</th><td><u>#define <dfn class="macro" id="_M/rfbVncAuthTooMany" data-ref="_M/rfbVncAuthTooMany">rfbVncAuthTooMany</dfn> 2</u></td></tr>
<tr><th id="205">205</th><td></td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="208">208</th><td><i> * Client Initialisation Message</i></td></tr>
<tr><th id="209">209</th><td><i> *</i></td></tr>
<tr><th id="210">210</th><td><i> * Once the client and server are sure that they're happy to talk to one</i></td></tr>
<tr><th id="211">211</th><td><i> * another, the client sends an initialisation message.  At present this</i></td></tr>
<tr><th id="212">212</th><td><i> * message only consists of a boolean indicating whether the server should try</i></td></tr>
<tr><th id="213">213</th><td><i> * to share the desktop by leaving other clients connected, or give exclusive</i></td></tr>
<tr><th id="214">214</th><td><i> * access to this client by disconnecting all other clients.</i></td></tr>
<tr><th id="215">215</th><td><i> */</i></td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="218">218</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::shared" title='&lt;anonymous struct&gt;::shared' data-ref="{anonymous}::shared">shared</dfn>;</td></tr>
<tr><th id="219">219</th><td>} <dfn class="typedef" id="rfbClientInitMsg" title='rfbClientInitMsg' data-type='struct rfbClientInitMsg' data-ref="rfbClientInitMsg">rfbClientInitMsg</dfn>;</td></tr>
<tr><th id="220">220</th><td></td></tr>
<tr><th id="221">221</th><td><u>#define <dfn class="macro" id="_M/sz_rfbClientInitMsg" data-ref="_M/sz_rfbClientInitMsg">sz_rfbClientInitMsg</dfn> 1</u></td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="225">225</th><td><i> * Server Initialisation Message</i></td></tr>
<tr><th id="226">226</th><td><i> *</i></td></tr>
<tr><th id="227">227</th><td><i> * After the client initialisation message, the server sends one of its own.</i></td></tr>
<tr><th id="228">228</th><td><i> * This tells the client the width and height of the server's framebuffer,</i></td></tr>
<tr><th id="229">229</th><td><i> * its pixel format and the name associated with the desktop.</i></td></tr>
<tr><th id="230">230</th><td><i> */</i></td></tr>
<tr><th id="231">231</th><td></td></tr>
<tr><th id="232">232</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="233">233</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::framebufferWidth" title='&lt;anonymous struct&gt;::framebufferWidth' data-ref="{anonymous}::framebufferWidth">framebufferWidth</dfn>;</td></tr>
<tr><th id="234">234</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::framebufferHeight" title='&lt;anonymous struct&gt;::framebufferHeight' data-ref="{anonymous}::framebufferHeight">framebufferHeight</dfn>;</td></tr>
<tr><th id="235">235</th><td>    <a class="typedef" href="#rfbPixelFormat" title='rfbPixelFormat' data-type='struct rfbPixelFormat' data-ref="rfbPixelFormat">rfbPixelFormat</a> <dfn class="decl" id="{anonymous}::format" title='&lt;anonymous struct&gt;::format' data-ref="{anonymous}::format">format</dfn>;	<i>/* the server's preferred pixel format */</i></td></tr>
<tr><th id="236">236</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::nameLength" title='&lt;anonymous struct&gt;::nameLength' data-ref="{anonymous}::nameLength">nameLength</dfn>;</td></tr>
<tr><th id="237">237</th><td>    <i>/* followed by char name[nameLength] */</i></td></tr>
<tr><th id="238">238</th><td>} <dfn class="typedef" id="rfbServerInitMsg" title='rfbServerInitMsg' data-type='struct rfbServerInitMsg' data-ref="rfbServerInitMsg">rfbServerInitMsg</dfn>;</td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td><u>#define <dfn class="macro" id="_M/sz_rfbServerInitMsg" data-ref="_M/sz_rfbServerInitMsg">sz_rfbServerInitMsg</dfn> (8 + sz_rfbPixelFormat)</u></td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td><i>/*</i></td></tr>
<tr><th id="244">244</th><td><i> * Following the server initialisation message it's up to the client to send</i></td></tr>
<tr><th id="245">245</th><td><i> * whichever protocol messages it wants.  Typically it will send a</i></td></tr>
<tr><th id="246">246</th><td><i> * SetPixelFormat message and a SetEncodings message, followed by a</i></td></tr>
<tr><th id="247">247</th><td><i> * FramebufferUpdateRequest.  From then on the server will send</i></td></tr>
<tr><th id="248">248</th><td><i> * FramebufferUpdate messages in response to the client's</i></td></tr>
<tr><th id="249">249</th><td><i> * FramebufferUpdateRequest messages.  The client should send</i></td></tr>
<tr><th id="250">250</th><td><i> * FramebufferUpdateRequest messages with incremental set to true when it has</i></td></tr>
<tr><th id="251">251</th><td><i> * finished processing one FramebufferUpdate and is ready to process another.</i></td></tr>
<tr><th id="252">252</th><td><i> * With a fast client, the rate at which FramebufferUpdateRequests are sent</i></td></tr>
<tr><th id="253">253</th><td><i> * should be regulated to avoid hogging the network.</i></td></tr>
<tr><th id="254">254</th><td><i> */</i></td></tr>
<tr><th id="255">255</th><td></td></tr>
<tr><th id="256">256</th><td></td></tr>
<tr><th id="257">257</th><td></td></tr>
<tr><th id="258">258</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="259">259</th><td><i> *</i></td></tr>
<tr><th id="260">260</th><td><i> * Message types</i></td></tr>
<tr><th id="261">261</th><td><i> *</i></td></tr>
<tr><th id="262">262</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td><i>/* server -&gt; client */</i></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><u>#define <dfn class="macro" id="_M/rfbFramebufferUpdate" data-ref="_M/rfbFramebufferUpdate">rfbFramebufferUpdate</dfn> 0</u></td></tr>
<tr><th id="267">267</th><td><u>#define <dfn class="macro" id="_M/rfbSetColourMapEntries" data-ref="_M/rfbSetColourMapEntries">rfbSetColourMapEntries</dfn> 1</u></td></tr>
<tr><th id="268">268</th><td><u>#define <dfn class="macro" id="_M/rfbBell" data-ref="_M/rfbBell">rfbBell</dfn> 2</u></td></tr>
<tr><th id="269">269</th><td><u>#define <dfn class="macro" id="_M/rfbServerCutText" data-ref="_M/rfbServerCutText">rfbServerCutText</dfn> 3</u></td></tr>
<tr><th id="270">270</th><td><u>#define <dfn class="macro" id="_M/rfbReSizeFrameBuffer" data-ref="_M/rfbReSizeFrameBuffer">rfbReSizeFrameBuffer</dfn> 0xF</u></td></tr>
<tr><th id="271">271</th><td></td></tr>
<tr><th id="272">272</th><td></td></tr>
<tr><th id="273">273</th><td><i>/* client -&gt; server */</i></td></tr>
<tr><th id="274">274</th><td></td></tr>
<tr><th id="275">275</th><td><u>#define <dfn class="macro" id="_M/rfbSetPixelFormat" data-ref="_M/rfbSetPixelFormat">rfbSetPixelFormat</dfn> 0</u></td></tr>
<tr><th id="276">276</th><td><u>#define <dfn class="macro" id="_M/rfbFixColourMapEntries" data-ref="_M/rfbFixColourMapEntries">rfbFixColourMapEntries</dfn> 1	/* not currently supported */</u></td></tr>
<tr><th id="277">277</th><td><u>#define <dfn class="macro" id="_M/rfbSetEncodings" data-ref="_M/rfbSetEncodings">rfbSetEncodings</dfn> 2</u></td></tr>
<tr><th id="278">278</th><td><u>#define <dfn class="macro" id="_M/rfbFramebufferUpdateRequest" data-ref="_M/rfbFramebufferUpdateRequest">rfbFramebufferUpdateRequest</dfn> 3</u></td></tr>
<tr><th id="279">279</th><td><u>#define <dfn class="macro" id="_M/rfbKeyEvent" data-ref="_M/rfbKeyEvent">rfbKeyEvent</dfn> 4</u></td></tr>
<tr><th id="280">280</th><td><u>#define <dfn class="macro" id="_M/rfbPointerEvent" data-ref="_M/rfbPointerEvent">rfbPointerEvent</dfn> 5</u></td></tr>
<tr><th id="281">281</th><td><u>#define <dfn class="macro" id="_M/rfbClientCutText" data-ref="_M/rfbClientCutText">rfbClientCutText</dfn> 6</u></td></tr>
<tr><th id="282">282</th><td><u>#define <dfn class="macro" id="_M/rfbSetScaleFactor" data-ref="_M/rfbSetScaleFactor">rfbSetScaleFactor</dfn> 0xF</u></td></tr>
<tr><th id="283">283</th><td></td></tr>
<tr><th id="284">284</th><td></td></tr>
<tr><th id="285">285</th><td></td></tr>
<tr><th id="286">286</th><td></td></tr>
<tr><th id="287">287</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="288">288</th><td><i> *</i></td></tr>
<tr><th id="289">289</th><td><i> * Encoding types</i></td></tr>
<tr><th id="290">290</th><td><i> *</i></td></tr>
<tr><th id="291">291</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="292">292</th><td></td></tr>
<tr><th id="293">293</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingRaw" data-ref="_M/rfbEncodingRaw">rfbEncodingRaw</dfn> 0</u></td></tr>
<tr><th id="294">294</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingCopyRect" data-ref="_M/rfbEncodingCopyRect">rfbEncodingCopyRect</dfn> 1</u></td></tr>
<tr><th id="295">295</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingRRE" data-ref="_M/rfbEncodingRRE">rfbEncodingRRE</dfn> 2</u></td></tr>
<tr><th id="296">296</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingCoRRE" data-ref="_M/rfbEncodingCoRRE">rfbEncodingCoRRE</dfn> 4</u></td></tr>
<tr><th id="297">297</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingHextile" data-ref="_M/rfbEncodingHextile">rfbEncodingHextile</dfn> 5</u></td></tr>
<tr><th id="298">298</th><td><u>#define <dfn class="macro" id="_M/rfbEncodingZRLE" data-ref="_M/rfbEncodingZRLE">rfbEncodingZRLE</dfn> 16</u></td></tr>
<tr><th id="299">299</th><td></td></tr>
<tr><th id="300">300</th><td></td></tr>
<tr><th id="301">301</th><td></td></tr>
<tr><th id="302">302</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="303">303</th><td><i> *</i></td></tr>
<tr><th id="304">304</th><td><i> * Server -&gt; client message definitions</i></td></tr>
<tr><th id="305">305</th><td><i> *</i></td></tr>
<tr><th id="306">306</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="307">307</th><td></td></tr>
<tr><th id="308">308</th><td></td></tr>
<tr><th id="309">309</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="310">310</th><td><i> * FramebufferUpdate - a block of rectangles to be copied to the framebuffer.</i></td></tr>
<tr><th id="311">311</th><td><i> *</i></td></tr>
<tr><th id="312">312</th><td><i> * This message consists of a header giving the number of rectangles of pixel</i></td></tr>
<tr><th id="313">313</th><td><i> * data followed by the rectangles themselves.  The header is padded so that</i></td></tr>
<tr><th id="314">314</th><td><i> * together with the type byte it is an exact multiple of 4 bytes (to help</i></td></tr>
<tr><th id="315">315</th><td><i> * with alignment of 32-bit pixels):</i></td></tr>
<tr><th id="316">316</th><td><i> */</i></td></tr>
<tr><th id="317">317</th><td></td></tr>
<tr><th id="318">318</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="319">319</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbFramebufferUpdate */</i></td></tr>
<tr><th id="320">320</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad" title='&lt;anonymous struct&gt;::pad' data-ref="{anonymous}::pad">pad</dfn>;</td></tr>
<tr><th id="321">321</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::nRects" title='&lt;anonymous struct&gt;::nRects' data-ref="{anonymous}::nRects">nRects</dfn>;</td></tr>
<tr><th id="322">322</th><td>    <i>/* followed by nRects rectangles */</i></td></tr>
<tr><th id="323">323</th><td>} <dfn class="typedef" id="rfbFramebufferUpdateMsg" title='rfbFramebufferUpdateMsg' data-type='struct rfbFramebufferUpdateMsg' data-ref="rfbFramebufferUpdateMsg">rfbFramebufferUpdateMsg</dfn>;</td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><u>#define <dfn class="macro" id="_M/sz_rfbFramebufferUpdateMsg" data-ref="_M/sz_rfbFramebufferUpdateMsg">sz_rfbFramebufferUpdateMsg</dfn> 4</u></td></tr>
<tr><th id="326">326</th><td></td></tr>
<tr><th id="327">327</th><td><i>/*</i></td></tr>
<tr><th id="328">328</th><td><i> * Each rectangle of pixel data consists of a header describing the position</i></td></tr>
<tr><th id="329">329</th><td><i> * and size of the rectangle and a type word describing the encoding of the</i></td></tr>
<tr><th id="330">330</th><td><i> * pixel data, followed finally by the pixel data.  Note that if the client has</i></td></tr>
<tr><th id="331">331</th><td><i> * not sent a SetEncodings message then it will only receive raw pixel data.</i></td></tr>
<tr><th id="332">332</th><td><i> * Also note again that this structure is a multiple of 4 bytes.</i></td></tr>
<tr><th id="333">333</th><td><i> */</i></td></tr>
<tr><th id="334">334</th><td></td></tr>
<tr><th id="335">335</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="336">336</th><td>    <a class="typedef" href="#rfbRectangle" title='rfbRectangle' data-type='struct rfbRectangle' data-ref="rfbRectangle">rfbRectangle</a> <dfn class="decl" id="{anonymous}::r" title='&lt;anonymous struct&gt;::r' data-ref="{anonymous}::r">r</dfn>;</td></tr>
<tr><th id="337">337</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::encoding" title='&lt;anonymous struct&gt;::encoding' data-ref="{anonymous}::encoding">encoding</dfn>;	<i>/* one of the encoding types rfbEncoding... */</i></td></tr>
<tr><th id="338">338</th><td>} <dfn class="typedef" id="rfbFramebufferUpdateRectHeader" title='rfbFramebufferUpdateRectHeader' data-type='struct rfbFramebufferUpdateRectHeader' data-ref="rfbFramebufferUpdateRectHeader">rfbFramebufferUpdateRectHeader</dfn>;</td></tr>
<tr><th id="339">339</th><td></td></tr>
<tr><th id="340">340</th><td><u>#define <dfn class="macro" id="_M/sz_rfbFramebufferUpdateRectHeader" data-ref="_M/sz_rfbFramebufferUpdateRectHeader">sz_rfbFramebufferUpdateRectHeader</dfn> (sz_rfbRectangle + 4)</u></td></tr>
<tr><th id="341">341</th><td></td></tr>
<tr><th id="342">342</th><td></td></tr>
<tr><th id="343">343</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="344">344</th><td><i> * Raw Encoding.  Pixels are sent in top-to-bottom scanline order,</i></td></tr>
<tr><th id="345">345</th><td><i> * left-to-right within a scanline with no padding in between.</i></td></tr>
<tr><th id="346">346</th><td><i> */</i></td></tr>
<tr><th id="347">347</th><td></td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="350">350</th><td><i> * CopyRect Encoding.  The pixels are specified simply by the x and y position</i></td></tr>
<tr><th id="351">351</th><td><i> * of the source rectangle.</i></td></tr>
<tr><th id="352">352</th><td><i> */</i></td></tr>
<tr><th id="353">353</th><td></td></tr>
<tr><th id="354">354</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="355">355</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::srcX" title='&lt;anonymous struct&gt;::srcX' data-ref="{anonymous}::srcX">srcX</dfn>;</td></tr>
<tr><th id="356">356</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::srcY" title='&lt;anonymous struct&gt;::srcY' data-ref="{anonymous}::srcY">srcY</dfn>;</td></tr>
<tr><th id="357">357</th><td>} <dfn class="typedef" id="rfbCopyRect" title='rfbCopyRect' data-type='struct rfbCopyRect' data-ref="rfbCopyRect">rfbCopyRect</dfn>;</td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td><u>#define <dfn class="macro" id="_M/sz_rfbCopyRect" data-ref="_M/sz_rfbCopyRect">sz_rfbCopyRect</dfn> 4</u></td></tr>
<tr><th id="360">360</th><td></td></tr>
<tr><th id="361">361</th><td></td></tr>
<tr><th id="362">362</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="363">363</th><td><i> * RRE - Rise-and-Run-length Encoding.  We have an rfbRREHeader structure</i></td></tr>
<tr><th id="364">364</th><td><i> * giving the number of subrectangles following.  Finally the data follows in</i></td></tr>
<tr><th id="365">365</th><td><i> * the form [&lt;bgpixel&gt;&lt;subrect&gt;&lt;subrect&gt;...] where each &lt;subrect&gt; is</i></td></tr>
<tr><th id="366">366</th><td><i> * [&lt;pixel&gt;&lt;rfbRectangle&gt;].</i></td></tr>
<tr><th id="367">367</th><td><i> */</i></td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="370">370</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::nSubrects" title='&lt;anonymous struct&gt;::nSubrects' data-ref="{anonymous}::nSubrects">nSubrects</dfn>;</td></tr>
<tr><th id="371">371</th><td>} <dfn class="typedef" id="rfbRREHeader" title='rfbRREHeader' data-type='struct rfbRREHeader' data-ref="rfbRREHeader">rfbRREHeader</dfn>;</td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td><u>#define <dfn class="macro" id="_M/sz_rfbRREHeader" data-ref="_M/sz_rfbRREHeader">sz_rfbRREHeader</dfn> 4</u></td></tr>
<tr><th id="374">374</th><td></td></tr>
<tr><th id="375">375</th><td></td></tr>
<tr><th id="376">376</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="377">377</th><td><i> * CoRRE - Compact RRE Encoding.  We have an rfbRREHeader structure giving</i></td></tr>
<tr><th id="378">378</th><td><i> * the number of subrectangles following.  Finally the data follows in the form</i></td></tr>
<tr><th id="379">379</th><td><i> * [&lt;bgpixel&gt;&lt;subrect&gt;&lt;subrect&gt;...] where each &lt;subrect&gt; is</i></td></tr>
<tr><th id="380">380</th><td><i> * [&lt;pixel&gt;&lt;rfbCoRRERectangle&gt;].  This means that</i></td></tr>
<tr><th id="381">381</th><td><i> * the whole rectangle must be at most 255x255 pixels.</i></td></tr>
<tr><th id="382">382</th><td><i> */</i></td></tr>
<tr><th id="383">383</th><td></td></tr>
<tr><th id="384">384</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="385">385</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::x" title='&lt;anonymous struct&gt;::x' data-ref="{anonymous}::x">x</dfn>;</td></tr>
<tr><th id="386">386</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::y" title='&lt;anonymous struct&gt;::y' data-ref="{anonymous}::y">y</dfn>;</td></tr>
<tr><th id="387">387</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::w" title='&lt;anonymous struct&gt;::w' data-ref="{anonymous}::w">w</dfn>;</td></tr>
<tr><th id="388">388</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::h" title='&lt;anonymous struct&gt;::h' data-ref="{anonymous}::h">h</dfn>;</td></tr>
<tr><th id="389">389</th><td>} <dfn class="typedef" id="rfbCoRRERectangle" title='rfbCoRRERectangle' data-type='struct rfbCoRRERectangle' data-ref="rfbCoRRERectangle">rfbCoRRERectangle</dfn>;</td></tr>
<tr><th id="390">390</th><td></td></tr>
<tr><th id="391">391</th><td><u>#define <dfn class="macro" id="_M/sz_rfbCoRRERectangle" data-ref="_M/sz_rfbCoRRERectangle">sz_rfbCoRRERectangle</dfn> 4</u></td></tr>
<tr><th id="392">392</th><td></td></tr>
<tr><th id="393">393</th><td></td></tr>
<tr><th id="394">394</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="395">395</th><td><i> * Hextile Encoding.  The rectangle is divided up into "tiles" of 16x16 pixels,</i></td></tr>
<tr><th id="396">396</th><td><i> * starting at the top left going in left-to-right, top-to-bottom order.  If</i></td></tr>
<tr><th id="397">397</th><td><i> * the width of the rectangle is not an exact multiple of 16 then the width of</i></td></tr>
<tr><th id="398">398</th><td><i> * the last tile in each row will be correspondingly smaller.  Similarly if the</i></td></tr>
<tr><th id="399">399</th><td><i> * height is not an exact multiple of 16 then the height of each tile in the</i></td></tr>
<tr><th id="400">400</th><td><i> * final row will also be smaller.  Each tile begins with a "subencoding" type</i></td></tr>
<tr><th id="401">401</th><td><i> * byte, which is a mask made up of a number of bits.  If the Raw bit is set</i></td></tr>
<tr><th id="402">402</th><td><i> * then the other bits are irrelevant; w*h pixel values follow (where w and h</i></td></tr>
<tr><th id="403">403</th><td><i> * are the width and height of the tile).  Otherwise the tile is encoded in a</i></td></tr>
<tr><th id="404">404</th><td><i> * similar way to RRE, except that the position and size of each subrectangle</i></td></tr>
<tr><th id="405">405</th><td><i> * can be specified in just two bytes.  The other bits in the mask are as</i></td></tr>
<tr><th id="406">406</th><td><i> * follows:</i></td></tr>
<tr><th id="407">407</th><td><i> *</i></td></tr>
<tr><th id="408">408</th><td><i> * BackgroundSpecified - if set, a pixel value follows which specifies</i></td></tr>
<tr><th id="409">409</th><td><i> *    the background colour for this tile.  The first non-raw tile in a</i></td></tr>
<tr><th id="410">410</th><td><i> *    rectangle must have this bit set.  If this bit isn't set then the</i></td></tr>
<tr><th id="411">411</th><td><i> *    background is the same as the last tile.</i></td></tr>
<tr><th id="412">412</th><td><i> *</i></td></tr>
<tr><th id="413">413</th><td><i> * ForegroundSpecified - if set, a pixel value follows which specifies</i></td></tr>
<tr><th id="414">414</th><td><i> *    the foreground colour to be used for all subrectangles in this tile.</i></td></tr>
<tr><th id="415">415</th><td><i> *    If this bit is set then the SubrectsColoured bit must be zero.</i></td></tr>
<tr><th id="416">416</th><td><i> *</i></td></tr>
<tr><th id="417">417</th><td><i> * AnySubrects - if set, a single byte follows giving the number of</i></td></tr>
<tr><th id="418">418</th><td><i> *    subrectangles following.  If not set, there are no subrectangles (i.e.</i></td></tr>
<tr><th id="419">419</th><td><i> *    the whole tile is just solid background colour).</i></td></tr>
<tr><th id="420">420</th><td><i> *</i></td></tr>
<tr><th id="421">421</th><td><i> * SubrectsColoured - if set then each subrectangle is preceded by a pixel</i></td></tr>
<tr><th id="422">422</th><td><i> *    value giving the colour of that subrectangle.  If not set, all</i></td></tr>
<tr><th id="423">423</th><td><i> *    subrectangles are the same colour, the foreground colour;  if the</i></td></tr>
<tr><th id="424">424</th><td><i> *    ForegroundSpecified bit wasn't set then the foreground is the same as</i></td></tr>
<tr><th id="425">425</th><td><i> *    the last tile.</i></td></tr>
<tr><th id="426">426</th><td><i> *</i></td></tr>
<tr><th id="427">427</th><td><i> * The position and size of each subrectangle is specified in two bytes.  The</i></td></tr>
<tr><th id="428">428</th><td><i> * Pack macros below can be used to generate the two bytes from x, y, w, h,</i></td></tr>
<tr><th id="429">429</th><td><i> * and the Extract macros can be used to extract the x, y, w, h values from</i></td></tr>
<tr><th id="430">430</th><td><i> * the two bytes.</i></td></tr>
<tr><th id="431">431</th><td><i> */</i></td></tr>
<tr><th id="432">432</th><td></td></tr>
<tr><th id="433">433</th><td><u>#define <dfn class="macro" id="_M/rfbHextileRaw" data-ref="_M/rfbHextileRaw">rfbHextileRaw</dfn>			(1 &lt;&lt; 0)</u></td></tr>
<tr><th id="434">434</th><td><u>#define <dfn class="macro" id="_M/rfbHextileBackgroundSpecified" data-ref="_M/rfbHextileBackgroundSpecified">rfbHextileBackgroundSpecified</dfn>	(1 &lt;&lt; 1)</u></td></tr>
<tr><th id="435">435</th><td><u>#define <dfn class="macro" id="_M/rfbHextileForegroundSpecified" data-ref="_M/rfbHextileForegroundSpecified">rfbHextileForegroundSpecified</dfn>	(1 &lt;&lt; 2)</u></td></tr>
<tr><th id="436">436</th><td><u>#define <dfn class="macro" id="_M/rfbHextileAnySubrects" data-ref="_M/rfbHextileAnySubrects">rfbHextileAnySubrects</dfn>		(1 &lt;&lt; 3)</u></td></tr>
<tr><th id="437">437</th><td><u>#define <dfn class="macro" id="_M/rfbHextileSubrectsColoured" data-ref="_M/rfbHextileSubrectsColoured">rfbHextileSubrectsColoured</dfn>	(1 &lt;&lt; 4)</u></td></tr>
<tr><th id="438">438</th><td></td></tr>
<tr><th id="439">439</th><td><u>#define <dfn class="macro" id="_M/rfbHextilePackXY" data-ref="_M/rfbHextilePackXY">rfbHextilePackXY</dfn>(x,y) (((x) &lt;&lt; 4) | (y))</u></td></tr>
<tr><th id="440">440</th><td><u>#define <dfn class="macro" id="_M/rfbHextilePackWH" data-ref="_M/rfbHextilePackWH">rfbHextilePackWH</dfn>(w,h) ((((w)-1) &lt;&lt; 4) | ((h)-1))</u></td></tr>
<tr><th id="441">441</th><td><u>#define <dfn class="macro" id="_M/rfbHextileExtractX" data-ref="_M/rfbHextileExtractX">rfbHextileExtractX</dfn>(byte) ((byte) &gt;&gt; 4)</u></td></tr>
<tr><th id="442">442</th><td><u>#define <dfn class="macro" id="_M/rfbHextileExtractY" data-ref="_M/rfbHextileExtractY">rfbHextileExtractY</dfn>(byte) ((byte) &amp; 0xf)</u></td></tr>
<tr><th id="443">443</th><td><u>#define <dfn class="macro" id="_M/rfbHextileExtractW" data-ref="_M/rfbHextileExtractW">rfbHextileExtractW</dfn>(byte) (((byte) &gt;&gt; 4) + 1)</u></td></tr>
<tr><th id="444">444</th><td><u>#define <dfn class="macro" id="_M/rfbHextileExtractH" data-ref="_M/rfbHextileExtractH">rfbHextileExtractH</dfn>(byte) (((byte) &amp; 0xf) + 1)</u></td></tr>
<tr><th id="445">445</th><td></td></tr>
<tr><th id="446">446</th><td></td></tr>
<tr><th id="447">447</th><td><i>/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</i></td></tr>
<tr><th id="448">448</th><td><i> * ZRLE - encoding combining Zlib compression, tiling, palettisation and</i></td></tr>
<tr><th id="449">449</th><td><i> * run-length encoding.</i></td></tr>
<tr><th id="450">450</th><td><i> */</i></td></tr>
<tr><th id="451">451</th><td></td></tr>
<tr><th id="452">452</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="453">453</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::length" title='&lt;anonymous struct&gt;::length' data-ref="{anonymous}::length">length</dfn>;</td></tr>
<tr><th id="454">454</th><td>} <dfn class="typedef" id="rfbZRLEHeader" title='rfbZRLEHeader' data-type='struct rfbZRLEHeader' data-ref="rfbZRLEHeader">rfbZRLEHeader</dfn>;</td></tr>
<tr><th id="455">455</th><td></td></tr>
<tr><th id="456">456</th><td><u>#define <dfn class="macro" id="_M/sz_rfbZRLEHeader" data-ref="_M/sz_rfbZRLEHeader">sz_rfbZRLEHeader</dfn> 4</u></td></tr>
<tr><th id="457">457</th><td></td></tr>
<tr><th id="458">458</th><td><u>#define <dfn class="macro" id="_M/rfbZRLETileWidth" data-ref="_M/rfbZRLETileWidth">rfbZRLETileWidth</dfn> 64</u></td></tr>
<tr><th id="459">459</th><td><u>#define <dfn class="macro" id="_M/rfbZRLETileHeight" data-ref="_M/rfbZRLETileHeight">rfbZRLETileHeight</dfn> 64</u></td></tr>
<tr><th id="460">460</th><td></td></tr>
<tr><th id="461">461</th><td></td></tr>
<tr><th id="462">462</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="463">463</th><td><i> * SetColourMapEntries - these messages are only sent if the pixel</i></td></tr>
<tr><th id="464">464</th><td><i> * format uses a "colour map" (i.e. trueColour false) and the client has not</i></td></tr>
<tr><th id="465">465</th><td><i> * fixed the entire colour map using FixColourMapEntries.  In addition they</i></td></tr>
<tr><th id="466">466</th><td><i> * will only start being sent after the client has sent its first</i></td></tr>
<tr><th id="467">467</th><td><i> * FramebufferUpdateRequest.  So if the client always tells the server to use</i></td></tr>
<tr><th id="468">468</th><td><i> * trueColour then it never needs to process this type of message.</i></td></tr>
<tr><th id="469">469</th><td><i> */</i></td></tr>
<tr><th id="470">470</th><td></td></tr>
<tr><th id="471">471</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="472">472</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbSetColourMapEntries */</i></td></tr>
<tr><th id="473">473</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad" title='&lt;anonymous struct&gt;::pad' data-ref="{anonymous}::pad">pad</dfn>;</td></tr>
<tr><th id="474">474</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::firstColour" title='&lt;anonymous struct&gt;::firstColour' data-ref="{anonymous}::firstColour">firstColour</dfn>;</td></tr>
<tr><th id="475">475</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::nColours" title='&lt;anonymous struct&gt;::nColours' data-ref="{anonymous}::nColours">nColours</dfn>;</td></tr>
<tr><th id="476">476</th><td></td></tr>
<tr><th id="477">477</th><td>    <i>/* Followed by nColours * 3 * CARD16</i></td></tr>
<tr><th id="478">478</th><td><i>       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */</i></td></tr>
<tr><th id="479">479</th><td></td></tr>
<tr><th id="480">480</th><td>} <dfn class="typedef" id="rfbSetColourMapEntriesMsg" title='rfbSetColourMapEntriesMsg' data-type='struct rfbSetColourMapEntriesMsg' data-ref="rfbSetColourMapEntriesMsg">rfbSetColourMapEntriesMsg</dfn>;</td></tr>
<tr><th id="481">481</th><td></td></tr>
<tr><th id="482">482</th><td><u>#define <dfn class="macro" id="_M/sz_rfbSetColourMapEntriesMsg" data-ref="_M/sz_rfbSetColourMapEntriesMsg">sz_rfbSetColourMapEntriesMsg</dfn> 6</u></td></tr>
<tr><th id="483">483</th><td></td></tr>
<tr><th id="484">484</th><td></td></tr>
<tr><th id="485">485</th><td></td></tr>
<tr><th id="486">486</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="487">487</th><td><i> * Bell - ring a bell on the client if it has one.</i></td></tr>
<tr><th id="488">488</th><td><i> */</i></td></tr>
<tr><th id="489">489</th><td></td></tr>
<tr><th id="490">490</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="491">491</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbBell */</i></td></tr>
<tr><th id="492">492</th><td>} <dfn class="typedef" id="rfbBellMsg" title='rfbBellMsg' data-type='struct rfbBellMsg' data-ref="rfbBellMsg">rfbBellMsg</dfn>;</td></tr>
<tr><th id="493">493</th><td></td></tr>
<tr><th id="494">494</th><td><u>#define <dfn class="macro" id="_M/sz_rfbBellMsg" data-ref="_M/sz_rfbBellMsg">sz_rfbBellMsg</dfn> 1</u></td></tr>
<tr><th id="495">495</th><td></td></tr>
<tr><th id="496">496</th><td></td></tr>
<tr><th id="497">497</th><td></td></tr>
<tr><th id="498">498</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="499">499</th><td><i> * ServerCutText - the server has new text in its cut buffer.</i></td></tr>
<tr><th id="500">500</th><td><i> */</i></td></tr>
<tr><th id="501">501</th><td></td></tr>
<tr><th id="502">502</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="503">503</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbServerCutText */</i></td></tr>
<tr><th id="504">504</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad1" title='&lt;anonymous struct&gt;::pad1' data-ref="{anonymous}::pad1">pad1</dfn>;</td></tr>
<tr><th id="505">505</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="506">506</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::length" title='&lt;anonymous struct&gt;::length' data-ref="{anonymous}::length">length</dfn>;</td></tr>
<tr><th id="507">507</th><td>    <i>/* followed by char text[length] */</i></td></tr>
<tr><th id="508">508</th><td>} <dfn class="typedef" id="rfbServerCutTextMsg" title='rfbServerCutTextMsg' data-type='struct rfbServerCutTextMsg' data-ref="rfbServerCutTextMsg">rfbServerCutTextMsg</dfn>;</td></tr>
<tr><th id="509">509</th><td></td></tr>
<tr><th id="510">510</th><td><u>#define <dfn class="macro" id="_M/sz_rfbServerCutTextMsg" data-ref="_M/sz_rfbServerCutTextMsg">sz_rfbServerCutTextMsg</dfn> 8</u></td></tr>
<tr><th id="511">511</th><td></td></tr>
<tr><th id="512">512</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="513">513</th><td><i> * ReSizeFrameBuffer - tell the RFB client to alter its framebuffer, either</i></td></tr>
<tr><th id="514">514</th><td><i> * due to a resize of the server desktop or a client-requested scaling factor.</i></td></tr>
<tr><th id="515">515</th><td><i> * The pixel format remains unchanged.</i></td></tr>
<tr><th id="516">516</th><td><i> */</i></td></tr>
<tr><th id="517">517</th><td></td></tr>
<tr><th id="518">518</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="519">519</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;                 <i>/* always rfbReSizeFrameBuffer */</i></td></tr>
<tr><th id="520">520</th><td>        <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad1" title='&lt;anonymous struct&gt;::pad1' data-ref="{anonymous}::pad1">pad1</dfn>;</td></tr>
<tr><th id="521">521</th><td>        <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::desktop_w" title='&lt;anonymous struct&gt;::desktop_w' data-ref="{anonymous}::desktop_w">desktop_w</dfn>;       <i>/* Desktop width */</i></td></tr>
<tr><th id="522">522</th><td>        <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::desktop_h" title='&lt;anonymous struct&gt;::desktop_h' data-ref="{anonymous}::desktop_h">desktop_h</dfn>;       <i>/* Desktop height */</i></td></tr>
<tr><th id="523">523</th><td>        <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::buffer_w" title='&lt;anonymous struct&gt;::buffer_w' data-ref="{anonymous}::buffer_w">buffer_w</dfn>;        <i>/* FrameBuffer width */</i></td></tr>
<tr><th id="524">524</th><td>        <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::buffer_h" title='&lt;anonymous struct&gt;::buffer_h' data-ref="{anonymous}::buffer_h">buffer_h</dfn>;        <i>/* Framebuffer height */</i></td></tr>
<tr><th id="525">525</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="526">526</th><td></td></tr>
<tr><th id="527">527</th><td>} <dfn class="typedef" id="rfbReSizeFrameBufferMsg" title='rfbReSizeFrameBufferMsg' data-type='struct rfbReSizeFrameBufferMsg' data-ref="rfbReSizeFrameBufferMsg">rfbReSizeFrameBufferMsg</dfn>;</td></tr>
<tr><th id="528">528</th><td></td></tr>
<tr><th id="529">529</th><td><u>#define <dfn class="macro" id="_M/sz_rfbReSizeFrameBufferMsg" data-ref="_M/sz_rfbReSizeFrameBufferMsg">sz_rfbReSizeFrameBufferMsg</dfn> (12)</u></td></tr>
<tr><th id="530">530</th><td></td></tr>
<tr><th id="531">531</th><td></td></tr>
<tr><th id="532">532</th><td></td></tr>
<tr><th id="533">533</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="534">534</th><td><i> * Union of all server-&gt;client messages.</i></td></tr>
<tr><th id="535">535</th><td><i> */</i></td></tr>
<tr><th id="536">536</th><td></td></tr>
<tr><th id="537">537</th><td><b>typedef</b> <b>union</b> {</td></tr>
<tr><th id="538">538</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous union&gt;::type' data-ref="{anonymous}::type">type</dfn>;</td></tr>
<tr><th id="539">539</th><td>    <a class="typedef" href="#rfbFramebufferUpdateMsg" title='rfbFramebufferUpdateMsg' data-type='struct rfbFramebufferUpdateMsg' data-ref="rfbFramebufferUpdateMsg">rfbFramebufferUpdateMsg</a> <dfn class="decl" id="{anonymous}::fu" title='&lt;anonymous union&gt;::fu' data-ref="{anonymous}::fu">fu</dfn>;</td></tr>
<tr><th id="540">540</th><td>    <a class="typedef" href="#rfbSetColourMapEntriesMsg" title='rfbSetColourMapEntriesMsg' data-type='struct rfbSetColourMapEntriesMsg' data-ref="rfbSetColourMapEntriesMsg">rfbSetColourMapEntriesMsg</a> <dfn class="decl" id="{anonymous}::scme" title='&lt;anonymous union&gt;::scme' data-ref="{anonymous}::scme">scme</dfn>;</td></tr>
<tr><th id="541">541</th><td>    <a class="typedef" href="#rfbBellMsg" title='rfbBellMsg' data-type='struct rfbBellMsg' data-ref="rfbBellMsg">rfbBellMsg</a> <dfn class="decl" id="{anonymous}::b" title='&lt;anonymous union&gt;::b' data-ref="{anonymous}::b">b</dfn>;</td></tr>
<tr><th id="542">542</th><td>    <a class="typedef" href="#rfbServerCutTextMsg" title='rfbServerCutTextMsg' data-type='struct rfbServerCutTextMsg' data-ref="rfbServerCutTextMsg">rfbServerCutTextMsg</a> <dfn class="decl" id="{anonymous}::sct" title='&lt;anonymous union&gt;::sct' data-ref="{anonymous}::sct">sct</dfn>;</td></tr>
<tr><th id="543">543</th><td>    <a class="typedef" href="#rfbReSizeFrameBufferMsg" title='rfbReSizeFrameBufferMsg' data-type='struct rfbReSizeFrameBufferMsg' data-ref="rfbReSizeFrameBufferMsg">rfbReSizeFrameBufferMsg</a> <dfn class="decl" id="{anonymous}::rsfb" title='&lt;anonymous union&gt;::rsfb' data-ref="{anonymous}::rsfb">rsfb</dfn>;</td></tr>
<tr><th id="544">544</th><td>} <dfn class="typedef" id="rfbServerToClientMsg" title='rfbServerToClientMsg' data-type='union rfbServerToClientMsg' data-ref="rfbServerToClientMsg">rfbServerToClientMsg</dfn>;</td></tr>
<tr><th id="545">545</th><td></td></tr>
<tr><th id="546">546</th><td></td></tr>
<tr><th id="547">547</th><td></td></tr>
<tr><th id="548">548</th><td><i>/*****************************************************************************</i></td></tr>
<tr><th id="549">549</th><td><i> *</i></td></tr>
<tr><th id="550">550</th><td><i> * Message definitions (client -&gt; server)</i></td></tr>
<tr><th id="551">551</th><td><i> *</i></td></tr>
<tr><th id="552">552</th><td><i> *****************************************************************************/</i></td></tr>
<tr><th id="553">553</th><td></td></tr>
<tr><th id="554">554</th><td></td></tr>
<tr><th id="555">555</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="556">556</th><td><i> * SetPixelFormat - tell the RFB server the format in which the client wants</i></td></tr>
<tr><th id="557">557</th><td><i> * pixels sent.</i></td></tr>
<tr><th id="558">558</th><td><i> */</i></td></tr>
<tr><th id="559">559</th><td></td></tr>
<tr><th id="560">560</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="561">561</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbSetPixelFormat */</i></td></tr>
<tr><th id="562">562</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad1" title='&lt;anonymous struct&gt;::pad1' data-ref="{anonymous}::pad1">pad1</dfn>;</td></tr>
<tr><th id="563">563</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="564">564</th><td>    <a class="typedef" href="#rfbPixelFormat" title='rfbPixelFormat' data-type='struct rfbPixelFormat' data-ref="rfbPixelFormat">rfbPixelFormat</a> <dfn class="decl" id="{anonymous}::format" title='&lt;anonymous struct&gt;::format' data-ref="{anonymous}::format">format</dfn>;</td></tr>
<tr><th id="565">565</th><td>} <dfn class="typedef" id="rfbSetPixelFormatMsg" title='rfbSetPixelFormatMsg' data-type='struct rfbSetPixelFormatMsg' data-ref="rfbSetPixelFormatMsg">rfbSetPixelFormatMsg</dfn>;</td></tr>
<tr><th id="566">566</th><td></td></tr>
<tr><th id="567">567</th><td><u>#define <dfn class="macro" id="_M/sz_rfbSetPixelFormatMsg" data-ref="_M/sz_rfbSetPixelFormatMsg">sz_rfbSetPixelFormatMsg</dfn> (sz_rfbPixelFormat + 4)</u></td></tr>
<tr><th id="568">568</th><td></td></tr>
<tr><th id="569">569</th><td></td></tr>
<tr><th id="570">570</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="571">571</th><td><i> * FixColourMapEntries - when the pixel format uses a "colour map", fix</i></td></tr>
<tr><th id="572">572</th><td><i> * read-only colour map entries.</i></td></tr>
<tr><th id="573">573</th><td><i> *</i></td></tr>
<tr><th id="574">574</th><td><i> *    ***************** NOT CURRENTLY SUPPORTED *****************</i></td></tr>
<tr><th id="575">575</th><td><i> */</i></td></tr>
<tr><th id="576">576</th><td></td></tr>
<tr><th id="577">577</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="578">578</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbFixColourMapEntries */</i></td></tr>
<tr><th id="579">579</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad" title='&lt;anonymous struct&gt;::pad' data-ref="{anonymous}::pad">pad</dfn>;</td></tr>
<tr><th id="580">580</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::firstColour" title='&lt;anonymous struct&gt;::firstColour' data-ref="{anonymous}::firstColour">firstColour</dfn>;</td></tr>
<tr><th id="581">581</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::nColours" title='&lt;anonymous struct&gt;::nColours' data-ref="{anonymous}::nColours">nColours</dfn>;</td></tr>
<tr><th id="582">582</th><td></td></tr>
<tr><th id="583">583</th><td>    <i>/* Followed by nColours * 3 * CARD16</i></td></tr>
<tr><th id="584">584</th><td><i>       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */</i></td></tr>
<tr><th id="585">585</th><td></td></tr>
<tr><th id="586">586</th><td>} <dfn class="typedef" id="rfbFixColourMapEntriesMsg" title='rfbFixColourMapEntriesMsg' data-type='struct rfbFixColourMapEntriesMsg' data-ref="rfbFixColourMapEntriesMsg">rfbFixColourMapEntriesMsg</dfn>;</td></tr>
<tr><th id="587">587</th><td></td></tr>
<tr><th id="588">588</th><td><u>#define <dfn class="macro" id="_M/sz_rfbFixColourMapEntriesMsg" data-ref="_M/sz_rfbFixColourMapEntriesMsg">sz_rfbFixColourMapEntriesMsg</dfn> 6</u></td></tr>
<tr><th id="589">589</th><td></td></tr>
<tr><th id="590">590</th><td></td></tr>
<tr><th id="591">591</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="592">592</th><td><i> * SetEncodings - tell the RFB server which encoding types we accept.  Put them</i></td></tr>
<tr><th id="593">593</th><td><i> * in order of preference, if we have any.  We may always receive raw</i></td></tr>
<tr><th id="594">594</th><td><i> * encoding, even if we don't specify it here.</i></td></tr>
<tr><th id="595">595</th><td><i> */</i></td></tr>
<tr><th id="596">596</th><td></td></tr>
<tr><th id="597">597</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="598">598</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbSetEncodings */</i></td></tr>
<tr><th id="599">599</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad" title='&lt;anonymous struct&gt;::pad' data-ref="{anonymous}::pad">pad</dfn>;</td></tr>
<tr><th id="600">600</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::nEncodings" title='&lt;anonymous struct&gt;::nEncodings' data-ref="{anonymous}::nEncodings">nEncodings</dfn>;</td></tr>
<tr><th id="601">601</th><td>    <i>/* followed by nEncodings * CARD32 encoding types */</i></td></tr>
<tr><th id="602">602</th><td>} <dfn class="typedef" id="rfbSetEncodingsMsg" title='rfbSetEncodingsMsg' data-type='struct rfbSetEncodingsMsg' data-ref="rfbSetEncodingsMsg">rfbSetEncodingsMsg</dfn>;</td></tr>
<tr><th id="603">603</th><td></td></tr>
<tr><th id="604">604</th><td><u>#define <dfn class="macro" id="_M/sz_rfbSetEncodingsMsg" data-ref="_M/sz_rfbSetEncodingsMsg">sz_rfbSetEncodingsMsg</dfn> 4</u></td></tr>
<tr><th id="605">605</th><td></td></tr>
<tr><th id="606">606</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="607">607</th><td><i> * SetScaleFactor - tell the RFB server to alter the scale factor for the</i></td></tr>
<tr><th id="608">608</th><td><i> * client buffer.</i></td></tr>
<tr><th id="609">609</th><td><i> */</i></td></tr>
<tr><th id="610">610</th><td></td></tr>
<tr><th id="611">611</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="612">612</th><td>	<a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;                 <i>/* always rfbSetScaleFactor */</i></td></tr>
<tr><th id="613">613</th><td>	<a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::scale" title='&lt;anonymous struct&gt;::scale' data-ref="{anonymous}::scale">scale</dfn>;                <i>/* Scale factor (positive non-zero integer) */</i></td></tr>
<tr><th id="614">614</th><td>	<a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="615">615</th><td>} <dfn class="typedef" id="rfbSetScaleFactorMsg" title='rfbSetScaleFactorMsg' data-type='struct rfbSetScaleFactorMsg' data-ref="rfbSetScaleFactorMsg">rfbSetScaleFactorMsg</dfn>;</td></tr>
<tr><th id="616">616</th><td></td></tr>
<tr><th id="617">617</th><td><u>#define <dfn class="macro" id="_M/sz_rfbSetScaleFactorMsg" data-ref="_M/sz_rfbSetScaleFactorMsg">sz_rfbSetScaleFactorMsg</dfn> (4)</u></td></tr>
<tr><th id="618">618</th><td></td></tr>
<tr><th id="619">619</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="620">620</th><td><i> * FramebufferUpdateRequest - request for a framebuffer update.  If incremental</i></td></tr>
<tr><th id="621">621</th><td><i> * is true then the client just wants the changes since the last update.  If</i></td></tr>
<tr><th id="622">622</th><td><i> * false then it wants the whole of the specified rectangle.</i></td></tr>
<tr><th id="623">623</th><td><i> */</i></td></tr>
<tr><th id="624">624</th><td></td></tr>
<tr><th id="625">625</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="626">626</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbFramebufferUpdateRequest */</i></td></tr>
<tr><th id="627">627</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::incremental" title='&lt;anonymous struct&gt;::incremental' data-ref="{anonymous}::incremental">incremental</dfn>;</td></tr>
<tr><th id="628">628</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::x" title='&lt;anonymous struct&gt;::x' data-ref="{anonymous}::x">x</dfn>;</td></tr>
<tr><th id="629">629</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::y" title='&lt;anonymous struct&gt;::y' data-ref="{anonymous}::y">y</dfn>;</td></tr>
<tr><th id="630">630</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::w" title='&lt;anonymous struct&gt;::w' data-ref="{anonymous}::w">w</dfn>;</td></tr>
<tr><th id="631">631</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::h" title='&lt;anonymous struct&gt;::h' data-ref="{anonymous}::h">h</dfn>;</td></tr>
<tr><th id="632">632</th><td>} <dfn class="typedef" id="rfbFramebufferUpdateRequestMsg" title='rfbFramebufferUpdateRequestMsg' data-type='struct rfbFramebufferUpdateRequestMsg' data-ref="rfbFramebufferUpdateRequestMsg">rfbFramebufferUpdateRequestMsg</dfn>;</td></tr>
<tr><th id="633">633</th><td></td></tr>
<tr><th id="634">634</th><td><u>#define <dfn class="macro" id="_M/sz_rfbFramebufferUpdateRequestMsg" data-ref="_M/sz_rfbFramebufferUpdateRequestMsg">sz_rfbFramebufferUpdateRequestMsg</dfn> 10</u></td></tr>
<tr><th id="635">635</th><td></td></tr>
<tr><th id="636">636</th><td></td></tr>
<tr><th id="637">637</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="638">638</th><td><i> * KeyEvent - key press or release</i></td></tr>
<tr><th id="639">639</th><td><i> *</i></td></tr>
<tr><th id="640">640</th><td><i> * Keys are specified using the "keysym" values defined by the X Window System.</i></td></tr>
<tr><th id="641">641</th><td><i> * For most ordinary keys, the keysym is the same as the corresponding ASCII</i></td></tr>
<tr><th id="642">642</th><td><i> * value.  Other common keys are:</i></td></tr>
<tr><th id="643">643</th><td><i> *</i></td></tr>
<tr><th id="644">644</th><td><i> * BackSpace		0xff08</i></td></tr>
<tr><th id="645">645</th><td><i> * Tab			0xff09</i></td></tr>
<tr><th id="646">646</th><td><i> * Return or Enter	0xff0d</i></td></tr>
<tr><th id="647">647</th><td><i> * Escape		0xff1b</i></td></tr>
<tr><th id="648">648</th><td><i> * Insert		0xff63</i></td></tr>
<tr><th id="649">649</th><td><i> * Delete		0xffff</i></td></tr>
<tr><th id="650">650</th><td><i> * Home			0xff50</i></td></tr>
<tr><th id="651">651</th><td><i> * End			0xff57</i></td></tr>
<tr><th id="652">652</th><td><i> * Page Up		0xff55</i></td></tr>
<tr><th id="653">653</th><td><i> * Page Down		0xff56</i></td></tr>
<tr><th id="654">654</th><td><i> * Left			0xff51</i></td></tr>
<tr><th id="655">655</th><td><i> * Up			0xff52</i></td></tr>
<tr><th id="656">656</th><td><i> * Right		0xff53</i></td></tr>
<tr><th id="657">657</th><td><i> * Down			0xff54</i></td></tr>
<tr><th id="658">658</th><td><i> * F1			0xffbe</i></td></tr>
<tr><th id="659">659</th><td><i> * F2			0xffbf</i></td></tr>
<tr><th id="660">660</th><td><i> * ...			...</i></td></tr>
<tr><th id="661">661</th><td><i> * F12			0xffc9</i></td></tr>
<tr><th id="662">662</th><td><i> * Shift		0xffe1</i></td></tr>
<tr><th id="663">663</th><td><i> * Control		0xffe3</i></td></tr>
<tr><th id="664">664</th><td><i> * Meta			0xffe7</i></td></tr>
<tr><th id="665">665</th><td><i> * Alt			0xffe9</i></td></tr>
<tr><th id="666">666</th><td><i> */</i></td></tr>
<tr><th id="667">667</th><td></td></tr>
<tr><th id="668">668</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="669">669</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbKeyEvent */</i></td></tr>
<tr><th id="670">670</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::down" title='&lt;anonymous struct&gt;::down' data-ref="{anonymous}::down">down</dfn>;			<i>/* true if down (press), false if up */</i></td></tr>
<tr><th id="671">671</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad" title='&lt;anonymous struct&gt;::pad' data-ref="{anonymous}::pad">pad</dfn>;</td></tr>
<tr><th id="672">672</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::key" title='&lt;anonymous struct&gt;::key' data-ref="{anonymous}::key">key</dfn>;			<i>/* key is specified as an X keysym */</i></td></tr>
<tr><th id="673">673</th><td>} <dfn class="typedef" id="rfbKeyEventMsg" title='rfbKeyEventMsg' data-type='struct rfbKeyEventMsg' data-ref="rfbKeyEventMsg">rfbKeyEventMsg</dfn>;</td></tr>
<tr><th id="674">674</th><td></td></tr>
<tr><th id="675">675</th><td><u>#define <dfn class="macro" id="_M/sz_rfbKeyEventMsg" data-ref="_M/sz_rfbKeyEventMsg">sz_rfbKeyEventMsg</dfn> 8</u></td></tr>
<tr><th id="676">676</th><td></td></tr>
<tr><th id="677">677</th><td></td></tr>
<tr><th id="678">678</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="679">679</th><td><i> * PointerEvent - mouse/pen move and/or button press.</i></td></tr>
<tr><th id="680">680</th><td><i> */</i></td></tr>
<tr><th id="681">681</th><td></td></tr>
<tr><th id="682">682</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="683">683</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbPointerEvent */</i></td></tr>
<tr><th id="684">684</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::buttonMask" title='&lt;anonymous struct&gt;::buttonMask' data-ref="{anonymous}::buttonMask">buttonMask</dfn>;		<i>/* bits 0-7 are buttons 1-8, 0=up, 1=down */</i></td></tr>
<tr><th id="685">685</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::x" title='&lt;anonymous struct&gt;::x' data-ref="{anonymous}::x">x</dfn>;</td></tr>
<tr><th id="686">686</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::y" title='&lt;anonymous struct&gt;::y' data-ref="{anonymous}::y">y</dfn>;</td></tr>
<tr><th id="687">687</th><td>} <dfn class="typedef" id="rfbPointerEventMsg" title='rfbPointerEventMsg' data-type='struct rfbPointerEventMsg' data-ref="rfbPointerEventMsg">rfbPointerEventMsg</dfn>;</td></tr>
<tr><th id="688">688</th><td></td></tr>
<tr><th id="689">689</th><td><u>#define <dfn class="macro" id="_M/rfbButton1Mask" data-ref="_M/rfbButton1Mask">rfbButton1Mask</dfn> 1</u></td></tr>
<tr><th id="690">690</th><td><u>#define <dfn class="macro" id="_M/rfbButton2Mask" data-ref="_M/rfbButton2Mask">rfbButton2Mask</dfn> 2</u></td></tr>
<tr><th id="691">691</th><td><u>#define <dfn class="macro" id="_M/rfbButton3Mask" data-ref="_M/rfbButton3Mask">rfbButton3Mask</dfn> 4</u></td></tr>
<tr><th id="692">692</th><td><u>#define <dfn class="macro" id="_M/rfbButton4Mask" data-ref="_M/rfbButton4Mask">rfbButton4Mask</dfn> 8</u></td></tr>
<tr><th id="693">693</th><td><u>#define <dfn class="macro" id="_M/rfbButton5Mask" data-ref="_M/rfbButton5Mask">rfbButton5Mask</dfn> 16</u></td></tr>
<tr><th id="694">694</th><td><u>#define <dfn class="macro" id="_M/rfbWheelUpMask" data-ref="_M/rfbWheelUpMask">rfbWheelUpMask</dfn> rfbButton4Mask</u></td></tr>
<tr><th id="695">695</th><td><u>#define <dfn class="macro" id="_M/rfbWheelDownMask" data-ref="_M/rfbWheelDownMask">rfbWheelDownMask</dfn> rfbButton5Mask</u></td></tr>
<tr><th id="696">696</th><td></td></tr>
<tr><th id="697">697</th><td><u>#define <dfn class="macro" id="_M/sz_rfbPointerEventMsg" data-ref="_M/sz_rfbPointerEventMsg">sz_rfbPointerEventMsg</dfn> 6</u></td></tr>
<tr><th id="698">698</th><td></td></tr>
<tr><th id="699">699</th><td></td></tr>
<tr><th id="700">700</th><td></td></tr>
<tr><th id="701">701</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="702">702</th><td><i> * ClientCutText - the client has new text in its cut buffer.</i></td></tr>
<tr><th id="703">703</th><td><i> */</i></td></tr>
<tr><th id="704">704</th><td></td></tr>
<tr><th id="705">705</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="706">706</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous struct&gt;::type' data-ref="{anonymous}::type">type</dfn>;			<i>/* always rfbClientCutText */</i></td></tr>
<tr><th id="707">707</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::pad1" title='&lt;anonymous struct&gt;::pad1' data-ref="{anonymous}::pad1">pad1</dfn>;</td></tr>
<tr><th id="708">708</th><td>    <a class="macro" href="#53" title="uint16_t" data-ref="_M/CARD16">CARD16</a> <dfn class="decl" id="{anonymous}::pad2" title='&lt;anonymous struct&gt;::pad2' data-ref="{anonymous}::pad2">pad2</dfn>;</td></tr>
<tr><th id="709">709</th><td>    <a class="macro" href="#54" title="uint32_t" data-ref="_M/CARD32">CARD32</a> <dfn class="decl" id="{anonymous}::length" title='&lt;anonymous struct&gt;::length' data-ref="{anonymous}::length">length</dfn>;</td></tr>
<tr><th id="710">710</th><td>    <i>/* followed by char text[length] */</i></td></tr>
<tr><th id="711">711</th><td>} <dfn class="typedef" id="rfbClientCutTextMsg" title='rfbClientCutTextMsg' data-type='struct rfbClientCutTextMsg' data-ref="rfbClientCutTextMsg">rfbClientCutTextMsg</dfn>;</td></tr>
<tr><th id="712">712</th><td></td></tr>
<tr><th id="713">713</th><td><u>#define <dfn class="macro" id="_M/sz_rfbClientCutTextMsg" data-ref="_M/sz_rfbClientCutTextMsg">sz_rfbClientCutTextMsg</dfn> 8</u></td></tr>
<tr><th id="714">714</th><td></td></tr>
<tr><th id="715">715</th><td><i>/*-----------------------------------------------------------------------------</i></td></tr>
<tr><th id="716">716</th><td><i> * Union of all client-&gt;server messages.</i></td></tr>
<tr><th id="717">717</th><td><i> */</i></td></tr>
<tr><th id="718">718</th><td></td></tr>
<tr><th id="719">719</th><td><b>typedef</b> <b>union</b> {</td></tr>
<tr><th id="720">720</th><td>    <a class="macro" href="#52" title="uint8_t" data-ref="_M/CARD8">CARD8</a> <dfn class="decl" id="{anonymous}::type" title='&lt;anonymous union&gt;::type' data-ref="{anonymous}::type">type</dfn>;</td></tr>
<tr><th id="721">721</th><td>    <a class="typedef" href="#rfbSetPixelFormatMsg" title='rfbSetPixelFormatMsg' data-type='struct rfbSetPixelFormatMsg' data-ref="rfbSetPixelFormatMsg">rfbSetPixelFormatMsg</a> <dfn class="decl" id="{anonymous}::spf" title='&lt;anonymous union&gt;::spf' data-ref="{anonymous}::spf">spf</dfn>;</td></tr>
<tr><th id="722">722</th><td>    <a class="typedef" href="#rfbSetScaleFactorMsg" title='rfbSetScaleFactorMsg' data-type='struct rfbSetScaleFactorMsg' data-ref="rfbSetScaleFactorMsg">rfbSetScaleFactorMsg</a> <dfn class="decl" id="{anonymous}::ssf" title='&lt;anonymous union&gt;::ssf' data-ref="{anonymous}::ssf">ssf</dfn>;</td></tr>
<tr><th id="723">723</th><td>    <a class="typedef" href="#rfbFixColourMapEntriesMsg" title='rfbFixColourMapEntriesMsg' data-type='struct rfbFixColourMapEntriesMsg' data-ref="rfbFixColourMapEntriesMsg">rfbFixColourMapEntriesMsg</a> <dfn class="decl" id="{anonymous}::fcme" title='&lt;anonymous union&gt;::fcme' data-ref="{anonymous}::fcme">fcme</dfn>;</td></tr>
<tr><th id="724">724</th><td>    <a class="typedef" href="#rfbSetEncodingsMsg" title='rfbSetEncodingsMsg' data-type='struct rfbSetEncodingsMsg' data-ref="rfbSetEncodingsMsg">rfbSetEncodingsMsg</a> <dfn class="decl" id="{anonymous}::se" title='&lt;anonymous union&gt;::se' data-ref="{anonymous}::se">se</dfn>;</td></tr>
<tr><th id="725">725</th><td>    <a class="typedef" href="#rfbFramebufferUpdateRequestMsg" title='rfbFramebufferUpdateRequestMsg' data-type='struct rfbFramebufferUpdateRequestMsg' data-ref="rfbFramebufferUpdateRequestMsg">rfbFramebufferUpdateRequestMsg</a> <dfn class="decl" id="{anonymous}::fur" title='&lt;anonymous union&gt;::fur' data-ref="{anonymous}::fur">fur</dfn>;</td></tr>
<tr><th id="726">726</th><td>    <a class="typedef" href="#rfbKeyEventMsg" title='rfbKeyEventMsg' data-type='struct rfbKeyEventMsg' data-ref="rfbKeyEventMsg">rfbKeyEventMsg</a> <dfn class="decl" id="{anonymous}::ke" title='&lt;anonymous union&gt;::ke' data-ref="{anonymous}::ke">ke</dfn>;</td></tr>
<tr><th id="727">727</th><td>    <a class="typedef" href="#rfbPointerEventMsg" title='rfbPointerEventMsg' data-type='struct rfbPointerEventMsg' data-ref="rfbPointerEventMsg">rfbPointerEventMsg</a> <dfn class="decl" id="{anonymous}::pe" title='&lt;anonymous union&gt;::pe' data-ref="{anonymous}::pe">pe</dfn>;</td></tr>
<tr><th id="728">728</th><td>    <a class="typedef" href="#rfbClientCutTextMsg" title='rfbClientCutTextMsg' data-type='struct rfbClientCutTextMsg' data-ref="rfbClientCutTextMsg">rfbClientCutTextMsg</a> <dfn class="decl" id="{anonymous}::cct" title='&lt;anonymous union&gt;::cct' data-ref="{anonymous}::cct">cct</dfn>;</td></tr>
<tr><th id="729">729</th><td>} <dfn class="typedef" id="rfbClientToServerMsg" title='rfbClientToServerMsg' data-type='union rfbClientToServerMsg' data-ref="rfbClientToServerMsg">rfbClientToServerMsg</dfn>;</td></tr>
<tr><th id="730">730</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='remoteosd.c.html'>vlc/modules/video_filter/remoteosd.c</a><br/>Generated on <em>2016-Oct-25</em> from project vlc revision <em>2.2.0-git</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
